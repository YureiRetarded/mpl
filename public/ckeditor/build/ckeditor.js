(function (t) {
    const e = t["en"] = t["en"] || {};
    e.dictionary = Object.assign(e.dictionary || {}, {
        "%0 of %1": "%0 of %1",
        "Align cell text to the bottom": "Align cell text to the bottom",
        "Align cell text to the center": "Align cell text to the center",
        "Align cell text to the left": "Align cell text to the left",
        "Align cell text to the middle": "Align cell text to the middle",
        "Align cell text to the right": "Align cell text to the right",
        "Align cell text to the top": "Align cell text to the top",
        "Align center": "Align center",
        "Align left": "Align left",
        "Align right": "Align right",
        "Align table to the left": "Align table to the left",
        "Align table to the right": "Align table to the right",
        Alignment: "Alignment",
        "Almost equal to": "Almost equal to",
        Angle: "Angle",
        "Approximately equal to": "Approximately equal to",
        Aquamarine: "Aquamarine",
        "Asterisk operator": "Asterisk operator",
        "Austral sign": "Austral sign",
        "back with leftwards arrow above": "back with leftwards arrow above",
        Background: "Background",
        Big: "Big",
        "Bitcoin sign": "Bitcoin sign",
        Black: "Black",
        "Block quote": "Block quote",
        Blue: "Blue",
        "Blue marker": "Blue marker",
        Bold: "Bold",
        Border: "Border",
        "Break text": "Break text",
        "Bulleted List": "Bulleted List",
        "Bulleted list styles toolbar": "Bulleted list styles toolbar",
        Cancel: "Cancel",
        "Cedi sign": "Cedi sign",
        "Cell properties": "Cell properties",
        "Cent sign": "Cent sign",
        "Center table": "Center table",
        "Centered image": "Centered image",
        "Change image text alternative": "Change image text alternative",
        "Character categories": "Character categories",
        "Characters: %0": "Characters: %0",
        "Choose heading": "Choose heading",
        Circle: "Circle",
        Code: "Code",
        "Colon sign": "Colon sign",
        Color: "Color",
        "Color picker": "Color picker",
        Column: "Column",
        "Contains as member": "Contains as member",
        "Copyright sign": "Copyright sign",
        "Cruzeiro sign": "Cruzeiro sign",
        "Currency sign": "Currency sign",
        Dashed: "Dashed",
        Decimal: "Decimal",
        "Decimal with leading zero": "Decimal with leading zero",
        "Decrease indent": "Decrease indent",
        Default: "Default",
        "Degree sign": "Degree sign",
        "Delete column": "Delete column",
        "Delete row": "Delete row",
        "Dim grey": "Dim grey",
        Dimensions: "Dimensions",
        Disc: "Disc",
        "Division sign": "Division sign",
        "Document colors": "Document colors",
        "Dollar sign": "Dollar sign",
        "Dong sign": "Dong sign",
        Dotted: "Dotted",
        Double: "Double",
        "Double dagger": "Double dagger",
        "Double exclamation mark": "Double exclamation mark",
        "Double low-9 quotation mark": "Double low-9 quotation mark",
        "Double question mark": "Double question mark",
        Downloadable: "Downloadable",
        "downwards arrow to bar": "downwards arrow to bar",
        "downwards dashed arrow": "downwards dashed arrow",
        "downwards double arrow": "downwards double arrow",
        "downwards simple arrow": "downwards simple arrow",
        "Drachma sign": "Drachma sign",
        "Dropdown toolbar": "Dropdown toolbar",
        "Edit block": "Edit block",
        "Edit link": "Edit link",
        "Editor block content toolbar": "Editor block content toolbar",
        "Editor contextual toolbar": "Editor contextual toolbar",
        "Editor editing area: %0": "Editor editing area: %0",
        "Editor toolbar": "Editor toolbar",
        "Element of": "Element of",
        "Em dash": "Em dash",
        "Empty set": "Empty set",
        "En dash": "En dash",
        "end with leftwards arrow above": "end with leftwards arrow above",
        "Enter table caption": "Enter table caption",
        "Euro sign": "Euro sign",
        "Euro-currency sign": "Euro-currency sign",
        "Exclamation question mark": "Exclamation question mark",
        Find: "Find",
        "Find and replace": "Find and replace",
        "Find in text…": "Find in text…",
        "Font Color": "Font Color",
        "Font Family": "Font Family",
        "Font Size": "Font Size",
        "For all": "For all",
        "Fraction slash": "Fraction slash",
        "French franc sign": "French franc sign",
        "Full size image": "Full size image",
        "German penny sign": "German penny sign",
        "Greater-than or equal to": "Greater-than or equal to",
        "Greater-than sign": "Greater-than sign",
        Green: "Green",
        "Green marker": "Green marker",
        "Green pen": "Green pen",
        Grey: "Grey",
        Groove: "Groove",
        "Guarani sign": "Guarani sign",
        "Header column": "Header column",
        "Header row": "Header row",
        Heading: "Heading",
        "Heading 1": "Heading 1",
        "Heading 2": "Heading 2",
        "Heading 3": "Heading 3",
        "Heading 4": "Heading 4",
        "Heading 5": "Heading 5",
        "Heading 6": "Heading 6",
        Height: "Height",
        Highlight: "Highlight",
        "Horizontal ellipsis": "Horizontal ellipsis",
        "Horizontal line": "Horizontal line",
        "Horizontal text alignment toolbar": "Horizontal text alignment toolbar",
        "Hryvnia sign": "Hryvnia sign",
        Huge: "Huge",
        "Identical to": "Identical to",
        "Image resize list": "Image resize list",
        "image widget": "image widget",
        "In line": "In line",
        "Increase indent": "Increase indent",
        "Indian rupee sign": "Indian rupee sign",
        Infinity: "Infinity",
        "Insert code block": "Insert code block",
        "Insert column left": "Insert column left",
        "Insert column right": "Insert column right",
        "Insert image": "Insert image",
        "Insert paragraph after block": "Insert paragraph after block",
        "Insert paragraph before block": "Insert paragraph before block",
        "Insert row above": "Insert row above",
        "Insert row below": "Insert row below",
        "Insert table": "Insert table",
        Inset: "Inset",
        Integral: "Integral",
        Intersection: "Intersection",
        "Inverted exclamation mark": "Inverted exclamation mark",
        "Inverted question mark": "Inverted question mark",
        Italic: "Italic",
        Justify: "Justify",
        "Justify cell text": "Justify cell text",
        "Kip sign": "Kip sign",
        "Latin capital letter a with breve": "Latin capital letter a with breve",
        "Latin capital letter a with macron": "Latin capital letter a with macron",
        "Latin capital letter a with ogonek": "Latin capital letter a with ogonek",
        "Latin capital letter c with acute": "Latin capital letter c with acute",
        "Latin capital letter c with caron": "Latin capital letter c with caron",
        "Latin capital letter c with circumflex": "Latin capital letter c with circumflex",
        "Latin capital letter c with dot above": "Latin capital letter c with dot above",
        "Latin capital letter d with caron": "Latin capital letter d with caron",
        "Latin capital letter d with stroke": "Latin capital letter d with stroke",
        "Latin capital letter e with breve": "Latin capital letter e with breve",
        "Latin capital letter e with caron": "Latin capital letter e with caron",
        "Latin capital letter e with dot above": "Latin capital letter e with dot above",
        "Latin capital letter e with macron": "Latin capital letter e with macron",
        "Latin capital letter e with ogonek": "Latin capital letter e with ogonek",
        "Latin capital letter eng": "Latin capital letter eng",
        "Latin capital letter g with breve": "Latin capital letter g with breve",
        "Latin capital letter g with cedilla": "Latin capital letter g with cedilla",
        "Latin capital letter g with circumflex": "Latin capital letter g with circumflex",
        "Latin capital letter g with dot above": "Latin capital letter g with dot above",
        "Latin capital letter h with circumflex": "Latin capital letter h with circumflex",
        "Latin capital letter h with stroke": "Latin capital letter h with stroke",
        "Latin capital letter i with breve": "Latin capital letter i with breve",
        "Latin capital letter i with dot above": "Latin capital letter i with dot above",
        "Latin capital letter i with macron": "Latin capital letter i with macron",
        "Latin capital letter i with ogonek": "Latin capital letter i with ogonek",
        "Latin capital letter i with tilde": "Latin capital letter i with tilde",
        "Latin capital letter j with circumflex": "Latin capital letter j with circumflex",
        "Latin capital letter k with cedilla": "Latin capital letter k with cedilla",
        "Latin capital letter l with acute": "Latin capital letter l with acute",
        "Latin capital letter l with caron": "Latin capital letter l with caron",
        "Latin capital letter l with cedilla": "Latin capital letter l with cedilla",
        "Latin capital letter l with middle dot": "Latin capital letter l with middle dot",
        "Latin capital letter l with stroke": "Latin capital letter l with stroke",
        "Latin capital letter n with acute": "Latin capital letter n with acute",
        "Latin capital letter n with caron": "Latin capital letter n with caron",
        "Latin capital letter n with cedilla": "Latin capital letter n with cedilla",
        "Latin capital letter o with breve": "Latin capital letter o with breve",
        "Latin capital letter o with double acute": "Latin capital letter o with double acute",
        "Latin capital letter o with macron": "Latin capital letter o with macron",
        "Latin capital letter r with acute": "Latin capital letter r with acute",
        "Latin capital letter r with caron": "Latin capital letter r with caron",
        "Latin capital letter r with cedilla": "Latin capital letter r with cedilla",
        "Latin capital letter s with acute": "Latin capital letter s with acute",
        "Latin capital letter s with caron": "Latin capital letter s with caron",
        "Latin capital letter s with cedilla": "Latin capital letter s with cedilla",
        "Latin capital letter s with circumflex": "Latin capital letter s with circumflex",
        "Latin capital letter t with caron": "Latin capital letter t with caron",
        "Latin capital letter t with cedilla": "Latin capital letter t with cedilla",
        "Latin capital letter t with stroke": "Latin capital letter t with stroke",
        "Latin capital letter u with breve": "Latin capital letter u with breve",
        "Latin capital letter u with double acute": "Latin capital letter u with double acute",
        "Latin capital letter u with macron": "Latin capital letter u with macron",
        "Latin capital letter u with ogonek": "Latin capital letter u with ogonek",
        "Latin capital letter u with ring above": "Latin capital letter u with ring above",
        "Latin capital letter u with tilde": "Latin capital letter u with tilde",
        "Latin capital letter w with circumflex": "Latin capital letter w with circumflex",
        "Latin capital letter y with circumflex": "Latin capital letter y with circumflex",
        "Latin capital letter y with diaeresis": "Latin capital letter y with diaeresis",
        "Latin capital letter z with acute": "Latin capital letter z with acute",
        "Latin capital letter z with caron": "Latin capital letter z with caron",
        "Latin capital letter z with dot above": "Latin capital letter z with dot above",
        "Latin capital ligature ij": "Latin capital ligature ij",
        "Latin capital ligature oe": "Latin capital ligature oe",
        "Latin small letter a with breve": "Latin small letter a with breve",
        "Latin small letter a with macron": "Latin small letter a with macron",
        "Latin small letter a with ogonek": "Latin small letter a with ogonek",
        "Latin small letter c with acute": "Latin small letter c with acute",
        "Latin small letter c with caron": "Latin small letter c with caron",
        "Latin small letter c with circumflex": "Latin small letter c with circumflex",
        "Latin small letter c with dot above": "Latin small letter c with dot above",
        "Latin small letter d with caron": "Latin small letter d with caron",
        "Latin small letter d with stroke": "Latin small letter d with stroke",
        "Latin small letter dotless i": "Latin small letter dotless i",
        "Latin small letter e with breve": "Latin small letter e with breve",
        "Latin small letter e with caron": "Latin small letter e with caron",
        "Latin small letter e with dot above": "Latin small letter e with dot above",
        "Latin small letter e with macron": "Latin small letter e with macron",
        "Latin small letter e with ogonek": "Latin small letter e with ogonek",
        "Latin small letter eng": "Latin small letter eng",
        "Latin small letter f with hook": "Latin small letter f with hook",
        "Latin small letter g with breve": "Latin small letter g with breve",
        "Latin small letter g with cedilla": "Latin small letter g with cedilla",
        "Latin small letter g with circumflex": "Latin small letter g with circumflex",
        "Latin small letter g with dot above": "Latin small letter g with dot above",
        "Latin small letter h with circumflex": "Latin small letter h with circumflex",
        "Latin small letter h with stroke": "Latin small letter h with stroke",
        "Latin small letter i with breve": "Latin small letter i with breve",
        "Latin small letter i with macron": "Latin small letter i with macron",
        "Latin small letter i with ogonek": "Latin small letter i with ogonek",
        "Latin small letter i with tilde": "Latin small letter i with tilde",
        "Latin small letter j with circumflex": "Latin small letter j with circumflex",
        "Latin small letter k with cedilla": "Latin small letter k with cedilla",
        "Latin small letter kra": "Latin small letter kra",
        "Latin small letter l with acute": "Latin small letter l with acute",
        "Latin small letter l with caron": "Latin small letter l with caron",
        "Latin small letter l with cedilla": "Latin small letter l with cedilla",
        "Latin small letter l with middle dot": "Latin small letter l with middle dot",
        "Latin small letter l with stroke": "Latin small letter l with stroke",
        "Latin small letter long s": "Latin small letter long s",
        "Latin small letter n preceded by apostrophe": "Latin small letter n preceded by apostrophe",
        "Latin small letter n with acute": "Latin small letter n with acute",
        "Latin small letter n with caron": "Latin small letter n with caron",
        "Latin small letter n with cedilla": "Latin small letter n with cedilla",
        "Latin small letter o with breve": "Latin small letter o with breve",
        "Latin small letter o with double acute": "Latin small letter o with double acute",
        "Latin small letter o with macron": "Latin small letter o with macron",
        "Latin small letter r with acute": "Latin small letter r with acute",
        "Latin small letter r with caron": "Latin small letter r with caron",
        "Latin small letter r with cedilla": "Latin small letter r with cedilla",
        "Latin small letter s with acute": "Latin small letter s with acute",
        "Latin small letter s with caron": "Latin small letter s with caron",
        "Latin small letter s with cedilla": "Latin small letter s with cedilla",
        "Latin small letter s with circumflex": "Latin small letter s with circumflex",
        "Latin small letter t with caron": "Latin small letter t with caron",
        "Latin small letter t with cedilla": "Latin small letter t with cedilla",
        "Latin small letter t with stroke": "Latin small letter t with stroke",
        "Latin small letter u with breve": "Latin small letter u with breve",
        "Latin small letter u with double acute": "Latin small letter u with double acute",
        "Latin small letter u with macron": "Latin small letter u with macron",
        "Latin small letter u with ogonek": "Latin small letter u with ogonek",
        "Latin small letter u with ring above": "Latin small letter u with ring above",
        "Latin small letter u with tilde": "Latin small letter u with tilde",
        "Latin small letter w with circumflex": "Latin small letter w with circumflex",
        "Latin small letter y with circumflex": "Latin small letter y with circumflex",
        "Latin small letter z with acute": "Latin small letter z with acute",
        "Latin small letter z with caron": "Latin small letter z with caron",
        "Latin small letter z with dot above": "Latin small letter z with dot above",
        "Latin small ligature ij": "Latin small ligature ij",
        "Latin small ligature oe": "Latin small ligature oe",
        "Left aligned image": "Left aligned image",
        "Left double quotation mark": "Left double quotation mark",
        "Left single quotation mark": "Left single quotation mark",
        "Left-pointing double angle quotation mark": "Left-pointing double angle quotation mark",
        "leftwards arrow to bar": "leftwards arrow to bar",
        "leftwards dashed arrow": "leftwards dashed arrow",
        "leftwards double arrow": "leftwards double arrow",
        "leftwards simple arrow": "leftwards simple arrow",
        "Less-than or equal to": "Less-than or equal to",
        "Less-than sign": "Less-than sign",
        "Light blue": "Light blue",
        "Light green": "Light green",
        "Light grey": "Light grey",
        Link: "Link",
        "Link URL": "Link URL",
        "Lira sign": "Lira sign",
        "List properties": "List properties",
        "Livre tournois sign": "Livre tournois sign",
        "Logical and": "Logical and",
        "Logical or": "Logical or",
        "Lower-latin": "Lower-latin",
        "Lower–roman": "Lower–roman",
        Macron: "Macron",
        "Manat sign": "Manat sign",
        "Match case": "Match case",
        "Merge cell down": "Merge cell down",
        "Merge cell left": "Merge cell left",
        "Merge cell right": "Merge cell right",
        "Merge cell up": "Merge cell up",
        "Merge cells": "Merge cells",
        "Mill sign": "Mill sign",
        "Minus sign": "Minus sign",
        "Multiplication sign": "Multiplication sign",
        "N-ary product": "N-ary product",
        "N-ary summation": "N-ary summation",
        Nabla: "Nabla",
        "Naira sign": "Naira sign",
        "New sheqel sign": "New sheqel sign",
        Next: "Next",
        "Next result": "Next result",
        None: "None",
        "Nordic mark sign": "Nordic mark sign",
        "Not an element of": "Not an element of",
        "Not equal to": "Not equal to",
        "Not sign": "Not sign",
        "Numbered List": "Numbered List",
        "Numbered list styles toolbar": "Numbered list styles toolbar",
        "on with exclamation mark with left right arrow above": "on with exclamation mark with left right arrow above",
        "Open in a new tab": "Open in a new tab",
        "Open link in new tab": "Open link in new tab",
        Orange: "Orange",
        Original: "Original",
        Outset: "Outset",
        Overline: "Overline",
        Padding: "Padding",
        Paragraph: "Paragraph",
        "Paragraph sign": "Paragraph sign",
        "Partial differential": "Partial differential",
        "Per mille sign": "Per mille sign",
        "Per ten thousand sign": "Per ten thousand sign",
        "Peseta sign": "Peseta sign",
        "Peso sign": "Peso sign",
        "Pink marker": "Pink marker",
        "Plain text": "Plain text",
        "Plus-minus sign": "Plus-minus sign",
        "Pound sign": "Pound sign",
        "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget",
        Previous: "Previous",
        "Previous result": "Previous result",
        "Proportional to": "Proportional to",
        Purple: "Purple",
        "Question exclamation mark": "Question exclamation mark",
        Red: "Red",
        "Red pen": "Red pen",
        Redo: "Redo",
        "Registered sign": "Registered sign",
        "Remove color": "Remove color",
        "Remove Format": "Remove Format",
        "Remove highlight": "Remove highlight",
        Replace: "Replace",
        "Replace all": "Replace all",
        "Replace with…": "Replace with…",
        "Resize image": "Resize image",
        "Resize image to %0": "Resize image to %0",
        "Resize image to the original size": "Resize image to the original size",
        "Restore default": "Restore default",
        "Reversed order": "Reversed order",
        "Reversed paragraph sign": "Reversed paragraph sign",
        "Rich Text Editor": "Rich Text Editor",
        Ridge: "Ridge",
        "Right aligned image": "Right aligned image",
        "Right double quotation mark": "Right double quotation mark",
        "Right single quotation mark": "Right single quotation mark",
        "Right-pointing double angle quotation mark": "Right-pointing double angle quotation mark",
        "rightwards arrow to bar": "rightwards arrow to bar",
        "rightwards dashed arrow": "rightwards dashed arrow",
        "rightwards double arrow": "rightwards double arrow",
        "rightwards simple arrow": "rightwards simple arrow",
        Row: "Row",
        "Ruble sign": "Ruble sign",
        "Rupee sign": "Rupee sign",
        Save: "Save",
        "Section sign": "Section sign",
        "Select all": "Select all",
        "Select column": "Select column",
        "Select row": "Select row",
        "Show more items": "Show more items",
        "Show options": "Show options",
        "Side image": "Side image",
        "Single left-pointing angle quotation mark": "Single left-pointing angle quotation mark",
        "Single low-9 quotation mark": "Single low-9 quotation mark",
        "Single right-pointing angle quotation mark": "Single right-pointing angle quotation mark",
        Small: "Small",
        Solid: "Solid",
        "soon with rightwards arrow above": "soon with rightwards arrow above",
        "Special characters": "Special characters",
        "Spesmilo sign": "Spesmilo sign",
        "Split cell horizontally": "Split cell horizontally",
        "Split cell vertically": "Split cell vertically",
        Square: "Square",
        "Square root": "Square root",
        "Start at": "Start at",
        "Start index must be greater than 0.": "Start index must be greater than 0.",
        Strikethrough: "Strikethrough",
        Style: "Style",
        Subscript: "Subscript",
        Superscript: "Superscript",
        "Table alignment toolbar": "Table alignment toolbar",
        "Table cell text alignment": "Table cell text alignment",
        "Table properties": "Table properties",
        "Table toolbar": "Table toolbar",
        "Tenge sign": "Tenge sign",
        "Text alignment": "Text alignment",
        "Text alignment toolbar": "Text alignment toolbar",
        "Text alternative": "Text alternative",
        "Text highlight toolbar": "Text highlight toolbar",
        "Text to find must not be empty.": "Text to find must not be empty.",
        'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
        'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".',
        "There exists": "There exists",
        "This link has no URL": "This link has no URL",
        "Tilde operator": "Tilde operator",
        Tiny: "Tiny",
        "Tip: Find some text first in order to replace it.": "Tip: Find some text first in order to replace it.",
        "Toggle caption off": "Toggle caption off",
        "Toggle caption on": "Toggle caption on",
        "Toggle the circle list style": "Toggle the circle list style",
        "Toggle the decimal list style": "Toggle the decimal list style",
        "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style",
        "Toggle the disc list style": "Toggle the disc list style",
        "Toggle the lower–latin list style": "Toggle the lower–latin list style",
        "Toggle the lower–roman list style": "Toggle the lower–roman list style",
        "Toggle the square list style": "Toggle the square list style",
        "Toggle the upper–latin list style": "Toggle the upper–latin list style",
        "Toggle the upper–roman list style": "Toggle the upper–roman list style",
        "top with upwards arrow above": "top with upwards arrow above",
        "Trade mark sign": "Trade mark sign",
        "Tugrik sign": "Tugrik sign",
        "Turkish lira sign": "Turkish lira sign",
        Turquoise: "Turquoise",
        "Two dot leader": "Two dot leader",
        "Type or paste your content here.": "Type or paste your content here.",
        "Type your title": "Type your title",
        Underline: "Underline",
        Undo: "Undo",
        Union: "Union",
        Unlink: "Unlink",
        "up down arrow with base": "up down arrow with base",
        "Upload failed": "Upload failed",
        "Upload in progress": "Upload in progress",
        "Upper-latin": "Upper-latin",
        "Upper-roman": "Upper-roman",
        "upwards arrow to bar": "upwards arrow to bar",
        "upwards dashed arrow": "upwards dashed arrow",
        "upwards double arrow": "upwards double arrow",
        "upwards simple arrow": "upwards simple arrow",
        "Vertical text alignment toolbar": "Vertical text alignment toolbar",
        "Vulgar fraction one half": "Vulgar fraction one half",
        "Vulgar fraction one quarter": "Vulgar fraction one quarter",
        "Vulgar fraction three quarters": "Vulgar fraction three quarters",
        White: "White",
        "Whole words only": "Whole words only",
        "Widget toolbar": "Widget toolbar",
        Width: "Width",
        "Won sign": "Won sign",
        "Words: %0": "Words: %0",
        "Wrap text": "Wrap text",
        Yellow: "Yellow",
        "Yellow marker": "Yellow marker",
        "Yen sign": "Yen sign"
    })
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function t(e, n) {
    if (typeof exports === "object" && typeof module === "object") module.exports = n(); else if (typeof define === "function" && define.amd) define([], n); else if (typeof exports === "object") exports["ClassicEditor"] = n(); else e["ClassicEditor"] = n()
})(self, (() => (() => {
    "use strict";
    var t = {
        8180: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css"],
                names: [],
                mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 636: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css"],
                names: [],
                mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 390: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],
                names: [],
                mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 9085: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css"],
                names: [],
                mappings: "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 3638: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 8894: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
                names: [],
                mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4401: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"],
                names: [],
                mappings: "AAMA,qDACC,YACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5436: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-find-result{background:var(--ck-color-highlight-background);color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplace.css"],
                names: [],
                mappings: "AAKA,gBACC,+CAAgD,CAChD,0BACD,CAEA,yBACC,kBACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-find-result {\n\tbackground: var(--ck-color-highlight-background);\n\tcolor: var(--ck-color-text);\n}\n\n.ck-find-result_selected {\n\tbackground: hsl(29, 100%, 60%);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9289: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form fieldset{display:flex}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{position:absolute}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form fieldset{align-content:stretch;align-items:center;border:0;flex-direction:row;flex-wrap:nowrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset>.ck-button{flex:0 0 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset>*+*{margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find{align-items:flex-start}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{color:var(--ck-color-base-border)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view{margin-bottom:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-options-dropdown{margin-left:0;margin-right:auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view,.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{width:300px}.ck.ck-find-and-replace-form fieldset{flex-wrap:wrap}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button{text-align:center}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>:not(.ck-labeled-field-view){flex:1 1 auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-dropdown:not(.ck-labeled-field-view){flex-grow:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-button:not(.ck-labeled-field-view)>.ck-button__label{text-align:center;width:100%}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-find-and-replace/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
                names: [],
                mappings: "AAKA,6BACC,cAUD,CARC,sCACC,YAMD,CAHC,yFACC,iBACD,CCNF,6BACC,WAyGD,CAnGC,mCACC,YACD,CAEA,sCAIC,qBAAsB,CADtB,kBAAmB,CAInB,QAAS,CANT,kBAAmB,CACnB,gBAAiB,CAMjB,QAAS,CAFT,+BAwFD,CApFC,iDACC,aACD,CAGC,oDACC,sCACD,CAIA,oDACC,uCACD,CAGD,6DACC,aAMD,CAJC,uEAEC,cAAe,CADf,UAED,CAID,qEAEC,sBAkCD,CAhCC,qFACC,eAOD,CAJC,uGACC,oCAAqC,CACrC,qCACD,CAGD,8FACC,uBACD,CAEA,8FACC,wBACD,CAEA,yFACC,OAAQ,CACR,0BAWD,CAbA,mGAKE,gCAQF,CAbA,mGASE,+BAIF,CAbA,yFAYC,iCACD,CAID,wEACC,cAAe,CACf,wBAAyB,CACzB,2CAeD,CAbC,+FACC,qCACD,CAEA,6FAEC,aAAc,CADd,iBAED,CAEA,wMAEC,UACD,CCzGF,oCD+GA,6BACC,WAiDD,CA/CC,sCACC,cA6CD,CAzCE,4FACC,aAAc,CAEd,wCAAyC,CADzC,UAED,CAEA,gFACC,iBAkBD,CAhBC,8FACC,aAcD,CAfA,wGAIE,aAWF,CAfA,wGAQE,cAOF,CAJC,gHAEC,iBAAkB,CADlB,UAED,CAMH,qGACC,aAUD,CARC,iHACC,WACD,CAEA,iIAEC,iBAAkB,CADlB,UAED,CC5JH",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-find-and-replace-form {\n\tmax-width: 100%;\n\n\t& fieldset {\n\t\tdisplay: flex;\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find .ck-results-counter {\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-find-and-replace-form {\n\twidth: 400px;\n\n\t/*\n\t * The <form> needs tabindex="-1" for proper Esc handling after being clicked\n\t * but the side effect is that this creates a nasty focus outline in some browsers.\n\t */\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t& fieldset {\n\t\tflex-direction: row;\n\t\tflex-wrap: nowrap;\n\t\talign-items: center;\n\t\talign-content: stretch;\n\n\t\tpadding: var(--ck-spacing-large);\n\t\tborder: 0;\n\t\tmargin: 0;\n\n\t\t& > .ck-button {\n\t\t\tflex: 0 0 auto;\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\t& > * + * {\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t& > * + * {\n\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex: 1 1 auto;\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t\tmin-width: 50px;\n\t\t\t}\n\t\t}\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find {\n\t\t\t/* To display all controls in line when there\'s an error under the input */\n\t\t\talign-items: flex-start;\n\n\t\t\t& > .ck-button-find {\n\t\t\t\tfont-weight: bold;\n\n\t\t\t\t/* Beef the find button up a little. It\'s the main action button in the form */\n\t\t\t\t& .ck-button__label {\n\t\t\t\t\tpadding-left: var(--ck-spacing-large);\n\t\t\t\t\tpadding-right: var(--ck-spacing-large);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& > .ck-button-prev > .ck-icon {\n\t\t\t\ttransform: rotate(90deg);\n\t\t\t}\n\n\t\t\t& > .ck-button-next > .ck-icon {\n\t\t\t\ttransform: rotate(-90deg);\n\t\t\t}\n\n\t\t\t& .ck-results-counter {\n\t\t\t\ttop: 50%;\n\t\t\t\ttransform: translateY(-50%);\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\tcolor: var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t/* The replace fieldset */\n\t\t&.ck-find-and-replace-form__replace {\n\t\t\tflex-wrap: wrap;\n\t\t\tjustify-content: flex-end;\n\t\t\tmargin-top: calc( -1 * var(--ck-spacing-large) );\n\n\t\t\t& > .ck-labeled-field-view {\n\t\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t& > .ck-options-dropdown {\n\t\t\t\tmargin-right: auto;\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t& > .ck-labeled-field-view,\n\t\t\t& > .ck-labeled-field-view .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n\n@mixin ck-media-phone {\n\t.ck.ck-find-and-replace-form {\n\t\twidth: 300px;\n\n\t\t& fieldset {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t/* The find fieldset */\n\t\t\t&.ck-find-and-replace-form__find {\n\t\t\t\t& .ck-labeled-field-view {\n\t\t\t\t\tflex: 1 0 auto;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmargin-bottom: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t& > .ck-button {\n\t\t\t\t\ttext-align: center;\n\n\t\t\t\t\t&:first-of-type {\n\t\t\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t\t\tmargin-left: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t\t\tmargin-right: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .ck-button__label {\n\t\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The replace fieldset */\n\t\t\t&.ck-find-and-replace-form__replace > :not(.ck-labeled-field-view) {\n\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t&.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\n\t\t\t\t&.ck-button > .ck-button__label {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 2585: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-button.ck-color-table__remove-color{align-items:center;display:flex;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css"],
                names: [],
                mappings: "AAKA,4CAEC,kBAAmB,CADnB,YAAa,CAEb,UACD,CAEA,8BACC,iBACD,CCNA,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 6203: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css"],
                names: [],
                mappings: "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 3230: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
                names: [],
                mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 713: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css"],
                names: [],
                mappings: "AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBAIC,4BAA6B,CAH7B,iCAID,CALA,uBAIC,4BAA6B,CAH7B,mCAID",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\n\t--ck-highlight-marker-green: hsl(120, 93%, 68%);\n\t--ck-highlight-marker-pink: hsl(345, 96%, 73%);\n\t--ck-highlight-marker-blue: hsl(201, 97%, 72%);\n\t--ck-highlight-pen-red: hsl(0, 85%, 49%);\n\t--ck-highlight-pen-green: hsl(112, 100%, 27%);\n}\n\n@define-mixin highlight-marker-color $color {\n\t.ck-content .marker-$color {\n\t\tbackground-color: var(--ck-highlight-marker-$color);\n\t}\n}\n\n@define-mixin highlight-pen-color $color {\n\t.ck-content .pen-$color {\n\t\tcolor: var(--ck-highlight-pen-$color);\n\n\t\t/* Override default yellow background of `<mark>` from user agent stylesheet */\n\t\tbackground-color: transparent;\n\t}\n}\n\n@mixin highlight-marker-color yellow;\n@mixin highlight-marker-color green;\n@mixin highlight-marker-color pink;\n@mixin highlight-marker-color blue;\n\n@mixin highlight-pen-color red;\n@mixin highlight-pen-color green;\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 2536: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css"],
                names: [],
                mappings: "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9048: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css"],
                names: [],
                mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 1043: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css"],
                names: [],
                mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 4622: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css"],
                names: [],
                mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9899: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
                names: [],
                mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 9825: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
                names: [],
                mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5870: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
                names: [],
                mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 6831: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
                names: [],
                mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 399: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
                names: [],
                mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 9465: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
                names: [],
                mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 4827: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
                names: [],
                mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 3195: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"],
                names: [],
                mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 8676: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/documentlist.css"],
                names: [],
                mappings: "AAKA,8CACC,aACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-editor__editable .ck-list-bogus-paragraph {\n\tdisplay: block;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 7133: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"],
                names: [],
                mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4553: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-list-styles-list{display:grid}.ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:circle}.ck-content ul ul{list-style-type:disc}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
                names: [],
                mappings: "AAKA,wBACC,YACD,CAEA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,sBAaD,CAXC,kBACC,oBASD,CAJE,6CACC,sBACD,CCnCH,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: circle;\n\n\t& ul {\n\t\tlist-style-type: disc;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 4046: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{max-height:200px;overflow-x:hidden;overflow-y:auto;width:350px}@media screen and (max-width:600px){.ck.ck-character-grid{width:190px}}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(10,1fr);margin:var(--ck-spacing-standard) var(--ck-spacing-large)}@media screen and (max-width:600px){.ck.ck-character-grid .ck-character-grid__tiles{grid-template-columns:repeat(5,1fr)}}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.2em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
                names: [],
                mappings: "AAKA,sBACC,cAKD,CAHC,gDACC,YACD,CCFD,MACC,kCACD,CAEA,sBAIC,gBAAiB,CAFjB,iBAAkB,CADlB,eAAgB,CAEhB,WAyCD,CClDC,oCDMD,sBAOE,WAqCF,CChDC,CDcA,gDAGC,mCAAoC,CAFpC,oCAAsC,CACtC,yDAMD,CCxBA,oCDgBA,gDAME,mCAEF,CCtBA,CDwBA,+CAQC,QAAS,CAHT,eAAgB,CAHhB,yCAA0C,CAE1C,6CAA8C,CAD9C,4CAA6C,CAG7C,SAAU,CACV,8BAA+B,CAN/B,wCAsBD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAE/C,iBAAkB,CADlB,UAED",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-grid {\n\tmax-width: 100%;\n\t\n\t& .ck-character-grid__tiles {\n\t\tdisplay: grid;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-character-grid-tile-size: 24px;\n}\n\n.ck.ck-character-grid {\n\toverflow-y: auto;\n\toverflow-x: hidden;\n\twidth: 350px;\n\tmax-height: 200px;\n\n\t@mixin ck-media-phone {\n\t\twidth: 190px;\n\t}\n\n\t& .ck-character-grid__tiles {\n\t\tgrid-template-columns: repeat(10, 1fr);\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\t\tgrid-gap: var(--ck-spacing-standard);\n\n\t\t@mixin ck-media-phone {\n\t\t\tgrid-template-columns: repeat(5, 1fr);\n\t\t}\n\t}\n\n\t& .ck-character-grid__tile {\n\t\twidth: var(--ck-character-grid-tile-size);\n\t\theight: var(--ck-character-grid-tile-size);\n\t\tmin-width: var(--ck-character-grid-tile-size);\n\t\tmin-height: var(--ck-character-grid-tile-size);\n\t\tfont-size: 1.2em;\n\t\tpadding: 0;\n\t\ttransition: .2s ease box-shadow;\n\t\tborder: 0;\n\n\t\t&:focus:not( .ck-disabled ),\n\t\t&:hover:not( .ck-disabled ) {\n\t\t\t/* Disable the default .ck-button\'s border ring. */\n\t\t\tborder: 0;\n\t\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t\t}\n\n\t\t/* Make sure the glyph is rendered in the center of the button */\n\t\t& .ck-button__label {\n\t\t\tline-height: var(--ck-character-grid-tile-size);\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4779: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}@media screen and (max-width:600px){.ck.ck-character-info{max-width:190px}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
                names: [],
                mappings: "AAKA,sBCIC,gDAAiD,CDHjD,YAAa,CACb,6BAA8B,CCC9B,uDDAD,CCGC,wBAEC,mCAAoC,CADpC,wBAED,CAEA,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,+CACC,UACD,CClBA,oCDCD,sBAoBE,eAEF,CCrBC",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-character-info {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t& > * {\n\t\ttext-transform: uppercase;\n\t\tfont-size: var(--ck-font-size-small);\n\t}\n\n\t& .ck-character-info__name {\n\t\tmax-width: 280px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& .ck-character-info__code {\n\t\topacity: .6;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 8170: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
                names: [],
                mappings: "AAUC,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,sEAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED,CCfA,oCDED,qCAgBE,eAOF,CALE,6DAEC,eAAgB,CADhB,sBAED,CCrBD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-special-characters-navigation {\n\n\t& > .ck-label {\n\t\tmax-width: 160px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& > .ck-dropdown .ck-dropdown__panel {\n\t\t/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\n\t\tmax-height: 250px;\n\t\toverflow-y: auto;\n\t\toverflow-x: hidden;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\n\t\t& > .ck-form__header__label {\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4082: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n\twidth: 100%;\n\tdisplay: flex;\n\tflex-direction: row-reverse;\n\n\t& > input.ck.ck-input-text {\n\t\tmin-width: auto;\n\t\tflex-grow: 1;\n\t}\n\n\t& > div.ck.ck-dropdown {\n\t\tmin-width: auto;\n\n\t\t/* This dropdown has no arrow but a color preview instead. */\n\t\t& > .ck-input-color__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__button {\n\t\t/* Resolving issue with misaligned buttons on Safari (see #10589) */\n\t\tdisplay: flex;\n\n\t\t& .ck.ck-input-color__button__preview {\n\t\t\tposition: relative;\n\t\t\toverflow: hidden;\n\n\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n\t& > .ck.ck-input-text {\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* Make sure the focused input is always on top of the dropdown button so its\n\t\t   outline and border are never cropped (also when the input is read-only). */\n\t\t&:focus {\n\t\t\tz-index: 0;\n\t\t}\n\t}\n\n\t& > .ck.ck-dropdown {\n\t\t& > .ck.ck-button.ck-input-color__button {\n\t\t\tpadding: 0;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-left: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t\t&:not(:focus) {\n\t\t\t\t\tborder-right: 1px solid transparent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.ck-disabled {\n\t\t\t\tbackground: var(--ck-color-input-disabled-background);\n\t\t\t}\n\n\t\t\t& > .ck.ck-input-color__button__preview {\n\t\t\t\t@mixin ck-rounded-corners;\n\n\t\t\t\twidth: 20px;\n\t\t\t\theight: 20px;\n\t\t\t\tborder: 1px solid var(--ck-color-input-border);\n\n\t\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\t\ttop: -30%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\theight: 150%;\n\t\t\t\t\twidth: 8%;\n\t\t\t\t\tbackground: hsl(0, 100%, 50%);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\ttransform: rotate(45deg);\n\t\t\t\t\ttransform-origin: 50%;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__remove-color {\n\t\twidth: 100%;\n\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n\t\tborder-bottom-left-radius: 0;\n\t\tborder-bottom-right-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-bottom: 1px solid var(--ck-color-input-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t}\n\n\t\t& .ck.ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: 0;\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4880: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css"],
                names: [],
                mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n\tpadding: 0 0 var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t& .ck.ck-input-text {\n\t\tmin-width: 100%;\n\t\twidth: 0;\n\t}\n\n\t& .ck.ck-dropdown {\n\t\tmin-width: 100%;\n\n\t\t& .ck-dropdown__button {\n\t\t\t&:not(:focus) {\n\t\t\t\tborder: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck-button__label {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9865: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/formrow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"],
                names: [],
                mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\t& + * {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-label {\n\t\twidth: 100%;\n\t\tmin-width: 100%;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 8085: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
                names: [],
                mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4104: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css"],
                names: [],
                mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 9888: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-color-table-caption-background:#f7f7f7;--ck-color-table-caption-text:#333;--ck-color-table-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-table-caption-background);caption-side:top;color:var(--ck-color-table-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-table-caption-highlighted-background)}to{background-color:var(--ck-color-table-caption-background)}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecaption.css"],
                names: [],
                mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAMC,yDAA0D,CAJ1D,gBAAiB,CAGjB,wCAAyC,CAJzC,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-table-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-table-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: top;\n\tword-break: break-word;\n\ttext-align: center;\n\tcolor: var(--ck-color-table-caption-text);\n\tbackground-color: var(--ck-color-table-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n\t&.table__caption_highlighted {\n\t\tanimation: ck-table-caption-highlight .6s ease-out;\n\t}\n\n\t&.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the table caption placeholder doesn't overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n}\n\n@keyframes ck-table-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-table-caption-highlighted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-table-caption-background);\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5737: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"],
                names: [],
                mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\t&:first-of-type {\n\t\t\t\t\t/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n\t\t\t\t\tflex-grow: 0.57;\n\t\t\t\t}\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\t/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n\t\t\t\t\tflex-grow: 0.43;\n\t\t\t\t}\n\n\t\t\t\t& .ck-button {\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__padding-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\t\t\twidth: 25%;\n\t\t}\n\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 728: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-color-table-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:-999999px;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:-999999px;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-table-column-resizer-hover);opacity:.25}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css"],
                names: [],
                mappings: "AAKA,MACC,iEAAkE,CAClE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAEC,iBACD,CAEA,wDAOC,gBAAiB,CAGjB,iBAAkB,CATlB,iBAAkB,CAOlB,oDAAqD,CAFrD,aAAc,CAKd,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,2DAA4D,CAC5D,WACD,CAEA,iEACC,mDAAoD,CACpD,WACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-column-resizer-hover: var(--ck-color-base-active);\n\t--ck-table-column-resizer-width: 7px;\n\n\t/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n\t   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n\t--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n\ttable-layout: fixed;\n}\n\n.ck-content .table table {\n\toverflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n\tposition: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n\tposition: absolute;\n\t/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n\t   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n\t   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n\t   unrealistic height for a single table. */\n\ttop: -999999px;\n\tbottom: -999999px;\n\tright: var(--ck-table-column-resizer-position-offset);\n\twidth: var(--ck-table-column-resizer-width);\n\tcursor: col-resize;\n\tuser-select: none;\n\tz-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n\tdisplay: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n\tbackground-color: var(--ck-color-table-column-resizer-hover);\n\topacity: 0.25;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n\tleft: var(--ck-table-column-resizer-position-offset);\n\tright: unset;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4777: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
                names: [],
                mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 198: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__background-row {\n\t\t\tflex-wrap: wrap;\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tflex-wrap: wrap;\n\t\t\talign-items: center;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\t\t\t\talign-items: center;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t/* Allow absolute positioning of the status (error) balloons. */\n\t\tposition: relative;\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\ttransform: translate(-50%,100%);\n\n\t\t\t/* Make sure the balloon status stays on top of other form elements. */\n\t\t\tz-index: 1;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translateX( -50% );\n\t\t\t}\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-table-properties-error-arrow-size: 6px;\n\t--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\t& > .ck-label {\n\t\t\t\t\tfont-size: var(--ck-font-size-tiny);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style,\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\twidth: 80px;\n\t\t\t\tmin-width: 80px;\n\t\t\t\tmax-width: 80px;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck-table-form__dimensions-row__width,\n\t\t\t& .ck-table-form__dimensions-row__height {\n\t\t\t\tmargin: 0\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\talign-self: flex-end;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\theight: var(--ck-ui-component-min-height);\n\t\t\t\tline-height: var(--ck-ui-component-min-height);\n\t\t\t\tmargin: 0 var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: var(--ck-spacing-standard);\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\t@mixin ck-rounded-corners;\n\n\t\t\tbackground: var(--ck-color-base-error);\n\t\t\tcolor: var(--ck-color-base-background);\n\t\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\t\tmin-width: var(--ck-table-properties-min-error-width);\n\t\t\ttext-align: center;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\n\t\t\t\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\n\t\t}\n\n\t\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n\t\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n\t0% {\n\t\topacity: 0;\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9221: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"],
                names: [],
                mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\t\t\tflex-basis: 0;\n\t\t\talign-content: baseline;\n\n\t\t\t& .ck.ck-toolbar .ck-toolbar__items {\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\talign-self: flex-end;\n\t\t\tpadding: 0;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\t\t& .ck-toolbar__items > * {\n\t\t\t\t\twidth: 40px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5593: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
                names: [],
                mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4499: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                names: [],
                mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9681: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                names: [],
                mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4923: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
                names: [],
                mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 3488: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 6875: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 66: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5075: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
                names: [],
                mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 4547: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5523: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
                names: [],
                mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 1174: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
                names: [],
                mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 6985: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 2751: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
                names: [],
                mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 8111: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 1162: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 8245: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 1757: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
                names: [],
                mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 3553: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 3609: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 1590: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
                names: [],
                mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 6706: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],
                names: [],
                mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5571: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                names: [],
                mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 9948: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],
                names: [],
                mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 6150: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
                names: [],
                mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 6507: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                names: [],
                mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 2263: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],
                names: [],
                mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"],
                sourceRoot: ""
            }]);
            const l = a
        }, 5137: (t, e, n) => {
            n.d(e, {Z: () => l});
            var i = n(4015);
            var o = n.n(i);
            var r = n(3645);
            var s = n.n(r);
            var a = s()(o());
            a.push([t.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
                version: 3,
                sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
                names: [],
                mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],
                sourceRoot: ""
            }]);
            const l = a
        }, 3645: t => {
            t.exports = function (t) {
                var e = [];
                e.toString = function e() {
                    return this.map((function (e) {
                        var n = t(e);
                        if (e[2]) {
                            return "@media ".concat(e[2], " {").concat(n, "}")
                        }
                        return n
                    })).join("")
                };
                e.i = function (t, n, i) {
                    if (typeof t === "string") {
                        t = [[null, t, ""]]
                    }
                    var o = {};
                    if (i) {
                        for (var r = 0; r < this.length; r++) {
                            var s = this[r][0];
                            if (s != null) {
                                o[s] = true
                            }
                        }
                    }
                    for (var a = 0; a < t.length; a++) {
                        var l = [].concat(t[a]);
                        if (i && o[l[0]]) {
                            continue
                        }
                        if (n) {
                            if (!l[2]) {
                                l[2] = n
                            } else {
                                l[2] = "".concat(n, " and ").concat(l[2])
                            }
                        }
                        e.push(l)
                    }
                };
                return e
            }
        }, 4015: t => {
            function e(t, e) {
                return s(t) || r(t, e) || i(t, e) || n()
            }

            function n() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }

            function i(t, e) {
                if (!t) return;
                if (typeof t === "string") return o(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                if (n === "Object" && t.constructor) n = t.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(t);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return o(t, e)
            }

            function o(t, e) {
                if (e == null || e > t.length) e = t.length;
                for (var n = 0, i = new Array(e); n < e; n++) {
                    i[n] = t[n]
                }
                return i
            }

            function r(t, e) {
                var n = t && (typeof Symbol !== "undefined" && t[Symbol.iterator] || t["@@iterator"]);
                if (n == null) return;
                var i = [];
                var o = true;
                var r = false;
                var s, a;
                try {
                    for (n = n.call(t); !(o = (s = n.next()).done); o = true) {
                        i.push(s.value);
                        if (e && i.length === e) break
                    }
                } catch (t) {
                    r = true;
                    a = t
                } finally {
                    try {
                        if (!o && n["return"] != null) n["return"]()
                    } finally {
                        if (r) throw a
                    }
                }
                return i
            }

            function s(t) {
                if (Array.isArray(t)) return t
            }

            t.exports = function t(n) {
                var i = e(n, 4), o = i[1], r = i[3];
                if (!r) {
                    return o
                }
                if (typeof btoa === "function") {
                    var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
                    var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s);
                    var l = "/*# ".concat(a, " */");
                    var c = r.sources.map((function (t) {
                        return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */")
                    }));
                    return [o].concat(c).concat([l]).join("\n")
                }
                return [o].join("\n")
            }
        }, 3379: (t, e, n) => {
            var i = function t() {
                var e;
                return function t() {
                    if (typeof e === "undefined") {
                        e = Boolean(window && document && document.all && !window.atob)
                    }
                    return e
                }
            }();
            var o = function t() {
                var e = {};
                return function t(n) {
                    if (typeof e[n] === "undefined") {
                        var i = document.querySelector(n);
                        if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) {
                            try {
                                i = i.contentDocument.head
                            } catch (t) {
                                i = null
                            }
                        }
                        e[n] = i
                    }
                    return e[n]
                }
            }();
            var r = [];

            function s(t) {
                var e = -1;
                for (var n = 0; n < r.length; n++) {
                    if (r[n].identifier === t) {
                        e = n;
                        break
                    }
                }
                return e
            }

            function a(t, e) {
                var n = {};
                var i = [];
                for (var o = 0; o < t.length; o++) {
                    var a = t[o];
                    var l = e.base ? a[0] + e.base : a[0];
                    var c = n[l] || 0;
                    var d = "".concat(l, " ").concat(c);
                    n[l] = c + 1;
                    var u = s(d);
                    var h = {css: a[1], media: a[2], sourceMap: a[3]};
                    if (u !== -1) {
                        r[u].references++;
                        r[u].updater(h)
                    } else {
                        r.push({identifier: d, updater: m(h, e), references: 1})
                    }
                    i.push(d)
                }
                return i
            }

            function l(t) {
                var e = document.createElement("style");
                var i = t.attributes || {};
                if (typeof i.nonce === "undefined") {
                    var r = true ? n.nc : 0;
                    if (r) {
                        i.nonce = r
                    }
                }
                Object.keys(i).forEach((function (t) {
                    e.setAttribute(t, i[t])
                }));
                if (typeof t.insert === "function") {
                    t.insert(e)
                } else {
                    var s = o(t.insert || "head");
                    if (!s) {
                        throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.")
                    }
                    s.appendChild(e)
                }
                return e
            }

            function c(t) {
                if (t.parentNode === null) {
                    return false
                }
                t.parentNode.removeChild(t)
            }

            var d = function t() {
                var e = [];
                return function t(n, i) {
                    e[n] = i;
                    return e.filter(Boolean).join("\n")
                }
            }();

            function u(t, e, n, i) {
                var o = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css;
                if (t.styleSheet) {
                    t.styleSheet.cssText = d(e, o)
                } else {
                    var r = document.createTextNode(o);
                    var s = t.childNodes;
                    if (s[e]) {
                        t.removeChild(s[e])
                    }
                    if (s.length) {
                        t.insertBefore(r, s[e])
                    } else {
                        t.appendChild(r)
                    }
                }
            }

            function h(t, e, n) {
                var i = n.css;
                var o = n.media;
                var r = n.sourceMap;
                if (o) {
                    t.setAttribute("media", o)
                } else {
                    t.removeAttribute("media")
                }
                if (r && typeof btoa !== "undefined") {
                    i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")
                }
                if (t.styleSheet) {
                    t.styleSheet.cssText = i
                } else {
                    while (t.firstChild) {
                        t.removeChild(t.firstChild)
                    }
                    t.appendChild(document.createTextNode(i))
                }
            }

            var f = null;
            var g = 0;

            function m(t, e) {
                var n;
                var i;
                var o;
                if (e.singleton) {
                    var r = g++;
                    n = f || (f = l(e));
                    i = u.bind(null, n, r, false);
                    o = u.bind(null, n, r, true)
                } else {
                    n = l(e);
                    i = h.bind(null, n, e);
                    o = function t() {
                        c(n)
                    }
                }
                i(t);
                return function e(n) {
                    if (n) {
                        if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                            return
                        }
                        i(t = n)
                    } else {
                        o()
                    }
                }
            }

            t.exports = function (t, e) {
                e = e || {};
                if (!e.singleton && typeof e.singleton !== "boolean") {
                    e.singleton = i()
                }
                t = t || [];
                var n = a(t, e);
                return function t(i) {
                    i = i || [];
                    if (Object.prototype.toString.call(i) !== "[object Array]") {
                        return
                    }
                    for (var o = 0; o < n.length; o++) {
                        var l = n[o];
                        var c = s(l);
                        r[c].references--
                    }
                    var d = a(i, e);
                    for (var u = 0; u < n.length; u++) {
                        var h = n[u];
                        var f = s(h);
                        if (r[f].references === 0) {
                            r[f].updater();
                            r.splice(f, 1)
                        }
                    }
                    n = d
                }
            }
        }
    };
    var e = {};

    function n(i) {
        var o = e[i];
        if (o !== undefined) {
            return o.exports
        }
        var r = e[i] = {id: i, exports: {}};
        t[i](r, r.exports, n);
        return r.exports
    }

    (() => {
        n.n = t => {
            var e = t && t.__esModule ? () => t["default"] : () => t;
            n.d(e, {a: e});
            return e
        }
    })();
    (() => {
        n.d = (t, e) => {
            for (var i in e) {
                if (n.o(e, i) && !n.o(t, i)) {
                    Object.defineProperty(t, i, {enumerable: true, get: e[i]})
                }
            }
        }
    })();
    (() => {
        n.g = function () {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")()
            } catch (t) {
                if (typeof window === "object") return window
            }
        }()
    })();
    (() => {
        n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)
    })();
    (() => {
        n.nc = undefined
    })();
    var i = {};
    (() => {
        n.d(i, {default: () => R$});

        function t() {
            try {
                return navigator.userAgent.toLowerCase()
            } catch (t) {
                return ""
            }
        }

        const e = t();
        const o = {
            isMac: s(e),
            isWindows: a(e),
            isGecko: l(e),
            isSafari: c(e),
            isiOS: d(e),
            isAndroid: u(e),
            isBlink: h(e),
            features: {isRegExpUnicodePropertySupported: f()}
        };
        const r = o;

        function s(t) {
            return t.indexOf("macintosh") > -1
        }

        function a(t) {
            return t.indexOf("windows") > -1
        }

        function l(t) {
            return !!t.match(/gecko\/\d+/)
        }

        function c(t) {
            return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1
        }

        function d(t) {
            return !!t.match(/iphone|ipad/i) || s(t) && navigator.maxTouchPoints > 0
        }

        function u(t) {
            return t.indexOf("android") > -1
        }

        function h(t) {
            return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
        }

        function f() {
            let t = false;
            try {
                t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
            } catch (t) {
            }
            return t
        }

        function g(t, e, n, i) {
            n = n || function (t, e) {
                return t === e
            };
            const o = Array.isArray(t) ? t : Array.prototype.slice.call(t);
            const r = Array.isArray(e) ? e : Array.prototype.slice.call(e);
            const s = m(o, r, n);
            const a = i ? w(s, r.length) : k(r, s);
            return a
        }

        function m(t, e, n) {
            const i = p(t, e, n);
            if (i === -1) {
                return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1}
            }
            const o = b(t, i);
            const r = b(e, i);
            const s = p(o, r, n);
            const a = t.length - s;
            const l = e.length - s;
            return {firstIndex: i, lastIndexOld: a, lastIndexNew: l}
        }

        function p(t, e, n) {
            for (let i = 0; i < Math.max(t.length, e.length); i++) {
                if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) {
                    return i
                }
            }
            return -1
        }

        function b(t, e) {
            return t.slice(e).reverse()
        }

        function k(t, e) {
            const n = [];
            const {firstIndex: i, lastIndexOld: o, lastIndexNew: r} = e;
            if (r - i > 0) {
                n.push({index: i, type: "insert", values: t.slice(i, r)})
            }
            if (o - i > 0) {
                n.push({index: i + (r - i), type: "delete", howMany: o - i})
            }
            return n
        }

        function w(t, e) {
            const {firstIndex: n, lastIndexOld: i, lastIndexNew: o} = t;
            if (n === -1) {
                return Array(e).fill("equal")
            }
            let r = [];
            if (n > 0) {
                r = r.concat(Array(n).fill("equal"))
            }
            if (o - n > 0) {
                r = r.concat(Array(o - n).fill("insert"))
            }
            if (i - n > 0) {
                r = r.concat(Array(i - n).fill("delete"))
            }
            if (o < e) {
                r = r.concat(Array(e - o).fill("equal"))
            }
            return r
        }

        function _(t, e, n) {
            n = n || function (t, e) {
                return t === e
            };
            const i = t.length;
            const o = e.length;
            if (i > 200 || o > 200 || i + o > 300) {
                return _.fastDiff(t, e, n, true)
            }
            let r, s;
            if (o < i) {
                const n = t;
                t = e;
                e = n;
                r = "delete";
                s = "insert"
            } else {
                r = "insert";
                s = "delete"
            }
            const a = t.length;
            const l = e.length;
            const c = l - a;
            const d = {};
            const u = {};

            function h(i) {
                const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1;
                const c = u[i + 1] !== undefined ? u[i + 1] : -1;
                const h = o > c ? -1 : 1;
                if (d[i + h]) {
                    d[i] = d[i + h].slice(0)
                }
                if (!d[i]) {
                    d[i] = []
                }
                d[i].push(o > c ? r : s);
                let f = Math.max(o, c);
                let g = f - i;
                while (g < a && f < l && n(t[g], e[f])) {
                    g++;
                    f++;
                    d[i].push("equal")
                }
                return f
            }

            let f = 0;
            let g;
            do {
                for (g = -f; g < c; g++) {
                    u[g] = h(g)
                }
                for (g = c + f; g > c; g--) {
                    u[g] = h(g)
                }
                u[c] = h(c);
                f++
            } while (u[c] !== l);
            return d[c].slice(1)
        }

        _.fastDiff = g;

        function A(t, ...e) {
            e.forEach((e => {
                const n = Object.getOwnPropertyNames(e);
                const i = Object.getOwnPropertySymbols(e);
                n.concat(i).forEach((n => {
                    if (n in t.prototype) {
                        return
                    }
                    if (typeof e == "function" && (n == "length" || n == "name" || n == "prototype")) {
                        return
                    }
                    const i = Object.getOwnPropertyDescriptor(e, n);
                    i.enumerable = false;
                    Object.defineProperty(t.prototype, n, i)
                }))
            }))
        }

        function C() {
            return function t() {
                t.called = true
            }
        }

        const v = C;

        class y {
            constructor(t, e) {
                this.source = t;
                this.name = e;
                this.path = [];
                this.stop = v();
                this.off = v()
            }
        }

        const x = new Array(256).fill("").map(((t, e) => ("0" + e.toString(16)).slice(-2)));

        function E() {
            const t = Math.random() * 4294967296 >>> 0;
            const e = Math.random() * 4294967296 >>> 0;
            const n = Math.random() * 4294967296 >>> 0;
            const i = Math.random() * 4294967296 >>> 0;
            return "e" + x[t >> 0 & 255] + x[t >> 8 & 255] + x[t >> 16 & 255] + x[t >> 24 & 255] + x[e >> 0 & 255] + x[e >> 8 & 255] + x[e >> 16 & 255] + x[e >> 24 & 255] + x[n >> 0 & 255] + x[n >> 8 & 255] + x[n >> 16 & 255] + x[n >> 24 & 255] + x[i >> 0 & 255] + x[i >> 8 & 255] + x[i >> 16 & 255] + x[i >> 24 & 255]
        }

        const S = {
            get(t = "normal") {
                if (typeof t != "number") {
                    return this[t] || this.normal
                } else {
                    return t
                }
            }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5
        };
        const D = S;

        function T(t, e) {
            const n = D.get(e.priority);
            for (let i = 0; i < t.length; i++) {
                if (D.get(t[i].priority) < n) {
                    t.splice(i, 0, e);
                    return
                }
            }
            t.push(e)
        }

        const B = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";

        class P extends Error {
            constructor(t, e, n) {
                super(V(t, n));
                this.name = "CKEditorError";
                this.context = e;
                this.data = n
            }

            is(t) {
                return t === "CKEditorError"
            }

            static rethrowUnexpectedError(t, e) {
                if (t.is && t.is("CKEditorError")) {
                    throw t
                }
                const n = new P(t.message, e);
                n.stack = t.stack;
                throw n
            }
        }

        function I(t, e) {
            console.warn(...F(t, e))
        }

        function R(t, e) {
            console.error(...F(t, e))
        }

        function z(t) {
            return `\nRead more: ${B}#error-${t}`
        }

        function V(t, e) {
            const n = new WeakSet;
            const i = (t, e) => {
                if (typeof e === "object" && e !== null) {
                    if (n.has(e)) {
                        return `[object ${e.constructor.name}]`
                    }
                    n.add(e)
                }
                return e
            };
            const o = e ? ` ${JSON.stringify(e, i)}` : "";
            const r = z(t);
            return t + o + r
        }

        function F(t, e) {
            const n = z(t);
            return e ? [t, e, n] : [t, n]
        }

        const L = "35.4.0";
        const O = null && L;
        const N = typeof window === "object" ? window : n.g;
        if (N.CKEDITOR_VERSION) {
            throw new P("ckeditor-duplicated-modules", null)
        } else {
            N.CKEDITOR_VERSION = L
        }
        const M = Symbol("listeningTo");
        const H = Symbol("emitterId");
        const W = Symbol("delegations");
        const q = j(Object);

        function j(t) {
            if (!t) {
                return q
            }

            class e extends t {
                on(t, e, n) {
                    this.listenTo(this, t, e, n)
                }

                once(t, e, n) {
                    let i = false;
                    const o = (t, ...n) => {
                        if (!i) {
                            i = true;
                            t.off();
                            e.call(this, t, ...n)
                        }
                    };
                    this.listenTo(this, t, o, n)
                }

                off(t, e) {
                    this.stopListening(this, t, e)
                }

                listenTo(t, e, n, i = {}) {
                    let o, r;
                    if (!this[M]) {
                        this[M] = {}
                    }
                    const s = this[M];
                    if (!G(t)) {
                        U(t)
                    }
                    const a = G(t);
                    if (!(o = s[a])) {
                        o = s[a] = {emitter: t, callbacks: {}}
                    }
                    if (!(r = o.callbacks[e])) {
                        r = o.callbacks[e] = []
                    }
                    r.push(n);
                    tt(this, t, e, n, i)
                }

                stopListening(t, e, n) {
                    const i = this[M];
                    let o = t && G(t);
                    const r = i && o ? i[o] : undefined;
                    const s = r && e ? r.callbacks[e] : undefined;
                    if (!i || t && !r || e && !s) {
                        return
                    }
                    if (n) {
                        et(this, t, e, n);
                        const i = s.indexOf(n);
                        if (i !== -1) {
                            if (s.length === 1) {
                                delete r.callbacks[e]
                            } else {
                                et(this, t, e, n)
                            }
                        }
                    } else if (s) {
                        while (n = s.pop()) {
                            et(this, t, e, n)
                        }
                        delete r.callbacks[e]
                    } else if (r) {
                        for (e in r.callbacks) {
                            this.stopListening(t, e)
                        }
                        delete i[o]
                    } else {
                        for (o in i) {
                            this.stopListening(i[o].emitter)
                        }
                        delete this[M]
                    }
                }

                fire(t, ...e) {
                    try {
                        const n = t instanceof y ? t : new y(this, t);
                        const i = n.name;
                        let o = Q(this, i);
                        n.path.push(this);
                        if (o) {
                            const t = [n, ...e];
                            o = Array.from(o);
                            for (let e = 0; e < o.length; e++) {
                                o[e].callback.apply(this, t);
                                if (n.off.called) {
                                    delete n.off.called;
                                    this._removeEventListener(i, o[e].callback)
                                }
                                if (n.stop.called) {
                                    break
                                }
                            }
                        }
                        const r = this[W];
                        if (r) {
                            const t = r.get(i);
                            const o = r.get("*");
                            if (t) {
                                X(t, n, e)
                            }
                            if (o) {
                                X(o, n, e)
                            }
                        }
                        return n.return
                    } catch (t) {
                        P.rethrowUnexpectedError(t, this)
                    }
                }

                delegate(...t) {
                    return {
                        to: (e, n) => {
                            if (!this[W]) {
                                this[W] = new Map
                            }
                            t.forEach((t => {
                                const i = this[W].get(t);
                                if (!i) {
                                    this[W].set(t, new Map([[e, n]]))
                                } else {
                                    i.set(e, n)
                                }
                            }))
                        }
                    }
                }

                stopDelegating(t, e) {
                    if (!this[W]) {
                        return
                    }
                    if (!t) {
                        this[W].clear()
                    } else if (!e) {
                        this[W].delete(t)
                    } else {
                        const n = this[W].get(t);
                        if (n) {
                            n.delete(e)
                        }
                    }
                }

                _addEventListener(t, e, n) {
                    J(this, t);
                    const i = Y(this, t);
                    const o = D.get(n.priority);
                    const r = {callback: e, priority: o};
                    for (const t of i) {
                        T(t, r)
                    }
                }

                _removeEventListener(t, e) {
                    const n = Y(this, t);
                    for (const t of n) {
                        for (let n = 0; n < t.length; n++) {
                            if (t[n].callback == e) {
                                t.splice(n, 1);
                                n--
                            }
                        }
                    }
                }
            }

            return e
        }

        ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            j[t] = q.prototype[t]
        }));

        function $(t, e) {
            const n = t[M];
            if (n && n[e]) {
                return n[e].emitter
            }
            return null
        }

        function U(t, e) {
            if (!t[H]) {
                t[H] = e || E()
            }
        }

        function G(t) {
            return t[H]
        }

        function K(t) {
            if (!t._events) {
                Object.defineProperty(t, "_events", {value: {}})
            }
            return t._events
        }

        function Z() {
            return {callbacks: [], childEvents: []}
        }

        function J(t, e) {
            const n = K(t);
            if (n[e]) {
                return
            }
            let i = e;
            let o = null;
            const r = [];
            while (i !== "") {
                if (n[i]) {
                    break
                }
                n[i] = Z();
                r.push(n[i]);
                if (o) {
                    n[i].childEvents.push(o)
                }
                o = i;
                i = i.substr(0, i.lastIndexOf(":"))
            }
            if (i !== "") {
                for (const t of r) {
                    t.callbacks = n[i].callbacks.slice()
                }
                n[i].childEvents.push(o)
            }
        }

        function Y(t, e) {
            const n = K(t)[e];
            if (!n) {
                return []
            }
            let i = [n.callbacks];
            for (let e = 0; e < n.childEvents.length; e++) {
                const o = Y(t, n.childEvents[e]);
                i = i.concat(o)
            }
            return i
        }

        function Q(t, e) {
            let n;
            if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
                if (e.indexOf(":") > -1) {
                    return Q(t, e.substr(0, e.lastIndexOf(":")))
                } else {
                    return null
                }
            }
            return n.callbacks
        }

        function X(t, e, n) {
            for (let [i, o] of t) {
                if (!o) {
                    o = e.name
                } else if (typeof o == "function") {
                    o = o(e.name)
                }
                const t = new y(e.source, o);
                t.path = [...e.path];
                i.fire(t, ...n)
            }
        }

        function tt(t, e, n, i, o) {
            if (e._addEventListener) {
                e._addEventListener(n, i, o)
            } else {
                t._addEventListener.call(e, n, i, o)
            }
        }

        function et(t, e, n, i) {
            if (e._removeEventListener) {
                e._removeEventListener(n, i)
            } else {
                t._removeEventListener.call(e, n, i)
            }
        }

        function nt(t) {
            var e = typeof t;
            return t != null && (e == "object" || e == "function")
        }

        const it = nt;
        const ot = Symbol("observableProperties");
        const rt = Symbol("boundObservables");
        const st = Symbol("boundProperties");
        const at = Symbol("decoratedMethods");
        const lt = Symbol("decoratedOriginal");
        const ct = dt(j());

        function dt(t) {
            if (!t) {
                return ct
            }

            class e extends t {
                set(t, e) {
                    if (it(t)) {
                        Object.keys(t).forEach((e => {
                            this.set(e, t[e])
                        }), this);
                        return
                    }
                    ut(this);
                    const n = this[ot];
                    if (t in this && !n.has(t)) {
                        throw new P("observable-set-cannot-override", this)
                    }
                    Object.defineProperty(this, t, {
                        enumerable: true, configurable: true, get() {
                            return n.get(t)
                        }, set(e) {
                            const i = n.get(t);
                            let o = this.fire(`set:${t}`, t, e, i);
                            if (o === undefined) {
                                o = e
                            }
                            if (i !== o || !n.has(t)) {
                                n.set(t, o);
                                this.fire(`change:${t}`, t, o, i)
                            }
                        }
                    });
                    this[t] = e
                }

                bind(...t) {
                    if (!t.length || !mt(t)) {
                        throw new P("observable-bind-wrong-properties", this)
                    }
                    if (new Set(t).size !== t.length) {
                        throw new P("observable-bind-duplicate-properties", this)
                    }
                    ut(this);
                    const e = this[st];
                    t.forEach((t => {
                        if (e.has(t)) {
                            throw new P("observable-bind-rebind", this)
                        }
                    }));
                    const n = new Map;
                    t.forEach((t => {
                        const i = {property: t, to: []};
                        e.set(t, i);
                        n.set(t, i)
                    }));
                    return {to: ht, toMany: ft, _observable: this, _bindProperties: t, _to: [], _bindings: n}
                }

                unbind(...t) {
                    if (!this[ot]) {
                        return
                    }
                    const e = this[st];
                    const n = this[rt];
                    if (t.length) {
                        if (!mt(t)) {
                            throw new P("observable-unbind-wrong-properties", this)
                        }
                        t.forEach((t => {
                            const i = e.get(t);
                            if (!i) {
                                return
                            }
                            i.to.forEach((([t, e]) => {
                                const o = n.get(t);
                                const r = o[e];
                                r.delete(i);
                                if (!r.size) {
                                    delete o[e]
                                }
                                if (!Object.keys(o).length) {
                                    n.delete(t);
                                    this.stopListening(t, "change")
                                }
                            }));
                            e.delete(t)
                        }))
                    } else {
                        n.forEach(((t, e) => {
                            this.stopListening(e, "change")
                        }));
                        n.clear();
                        e.clear()
                    }
                }

                decorate(t) {
                    ut(this);
                    const e = this[t];
                    if (!e) {
                        throw new P("observablemixin-cannot-decorate-undefined", this, {object: this, methodName: t})
                    }
                    this.on(t, ((t, n) => {
                        t.return = e.apply(this, n)
                    }));
                    this[t] = function (...e) {
                        return this.fire(t, e)
                    };
                    this[t][lt] = e;
                    if (!this[at]) {
                        this[at] = []
                    }
                    this[at].push(t)
                }

                stopListening(t, e, n) {
                    if (!t && this[at]) {
                        for (const t of this[at]) {
                            this[t] = this[t][lt]
                        }
                        delete this[at]
                    }
                    super.stopListening(t, e, n)
                }
            }

            return e
        }

        ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            dt[t] = ct.prototype[t]
        }));

        function ut(t) {
            if (t[ot]) {
                return
            }
            Object.defineProperty(t, ot, {value: new Map});
            Object.defineProperty(t, rt, {value: new Map});
            Object.defineProperty(t, st, {value: new Map})
        }

        function ht(...t) {
            const e = pt(...t);
            const n = Array.from(this._bindings.keys());
            const i = n.length;
            if (!e.callback && e.to.length > 1) {
                throw new P("observable-bind-to-no-callback", this)
            }
            if (i > 1 && e.callback) {
                throw new P("observable-bind-to-extra-callback", this)
            }
            e.to.forEach((t => {
                if (t.properties.length && t.properties.length !== i) {
                    throw new P("observable-bind-to-properties-length", this)
                }
                if (!t.properties.length) {
                    t.properties = this._bindProperties
                }
            }));
            this._to = e.to;
            if (e.callback) {
                this._bindings.get(n[0]).callback = e.callback
            }
            _t(this._observable, this._to);
            kt(this);
            this._bindProperties.forEach((t => {
                wt(this._observable, t)
            }))
        }

        function ft(t, e, n) {
            if (this._bindings.size > 1) {
                throw new P("observable-bind-to-many-not-one-binding", this)
            }
            this.to(...gt(t, e), n)
        }

        function gt(t, e) {
            const n = t.map((t => [t, e]));
            return Array.prototype.concat.apply([], n)
        }

        function mt(t) {
            return t.every((t => typeof t == "string"))
        }

        function pt(...t) {
            if (!t.length) {
                throw new P("observable-bind-to-parse-error", null)
            }
            const e = {to: []};
            let n;
            if (typeof t[t.length - 1] == "function") {
                e.callback = t.pop()
            }
            t.forEach((t => {
                if (typeof t == "string") {
                    n.properties.push(t)
                } else if (typeof t == "object") {
                    n = {observable: t, properties: []};
                    e.to.push(n)
                } else {
                    throw new P("observable-bind-to-parse-error", null)
                }
            }));
            return e
        }

        function bt(t, e, n, i) {
            const o = t[rt];
            const r = o.get(n);
            const s = r || {};
            if (!s[i]) {
                s[i] = new Set
            }
            s[i].add(e);
            if (!r) {
                o.set(n, s)
            }
        }

        function kt(t) {
            let e;
            t._bindings.forEach(((n, i) => {
                t._to.forEach((o => {
                    e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)];
                    n.to.push([o.observable, e]);
                    bt(t._observable, n, o.observable, e)
                }))
            }))
        }

        function wt(t, e) {
            const n = t[st];
            const i = n.get(e);
            let o;
            if (i.callback) {
                o = i.callback.apply(t, i.to.map((t => t[0][t[1]])))
            } else {
                o = i.to[0];
                o = o[0][o[1]]
            }
            if (Object.prototype.hasOwnProperty.call(t, e)) {
                t[e] = o
            } else {
                t.set(e, o)
            }
        }

        function _t(t, e) {
            e.forEach((e => {
                const n = t[rt];
                let i;
                if (!n.get(e.observable)) {
                    t.listenTo(e.observable, "change", ((o, r) => {
                        i = n.get(e.observable)[r];
                        if (i) {
                            i.forEach((e => {
                                wt(t, e.property)
                            }))
                        }
                    }))
                }
            }))
        }

        class At {
            constructor() {
                this._replacedElements = []
            }

            replace(t, e) {
                this._replacedElements.push({element: t, newElement: e});
                t.style.display = "none";
                if (e) {
                    t.parentNode.insertBefore(e, t.nextSibling)
                }
            }

            restore() {
                this._replacedElements.forEach((({element: t, newElement: e}) => {
                    t.style.display = "";
                    if (e) {
                        e.remove()
                    }
                }));
                this._replacedElements = []
            }
        }

        function Ct(t) {
            let e = 0;
            for (const n of t) {
                e++
            }
            return e
        }

        function vt(t, e) {
            const n = Math.min(t.length, e.length);
            for (let i = 0; i < n; i++) {
                if (t[i] != e[i]) {
                    return i
                }
            }
            if (t.length == e.length) {
                return "same"
            } else if (t.length < e.length) {
                return "prefix"
            } else {
                return "extension"
            }
        }

        function yt(t) {
            return !!(t && t[Symbol.iterator])
        }

        var xt = typeof global == "object" && global && global.Object === Object && global;
        const Et = xt;
        var St = typeof self == "object" && self && self.Object === Object && self;
        var Dt = Et || St || Function("return this")();
        const Tt = Dt;
        var Bt = Tt.Symbol;
        const Pt = Bt;
        var It = Object.prototype;
        var Rt = It.hasOwnProperty;
        var zt = It.toString;
        var Vt = Pt ? Pt.toStringTag : undefined;

        function Ft(t) {
            var e = Rt.call(t, Vt), n = t[Vt];
            try {
                t[Vt] = undefined;
                var i = true
            } catch (t) {
            }
            var o = zt.call(t);
            if (i) {
                if (e) {
                    t[Vt] = n
                } else {
                    delete t[Vt]
                }
            }
            return o
        }

        const Lt = Ft;
        var Ot = Object.prototype;
        var Nt = Ot.toString;

        function Mt(t) {
            return Nt.call(t)
        }

        const Ht = Mt;
        var Wt = "[object Null]", qt = "[object Undefined]";
        var jt = Pt ? Pt.toStringTag : undefined;

        function $t(t) {
            if (t == null) {
                return t === undefined ? qt : Wt
            }
            return jt && jt in Object(t) ? Lt(t) : Ht(t)
        }

        const Ut = $t;
        var Gt = Array.isArray;
        const Kt = Gt;

        function Zt(t) {
            return t != null && typeof t == "object"
        }

        const Jt = Zt;
        var Yt = "[object String]";

        function Qt(t) {
            return typeof t == "string" || !Kt(t) && Jt(t) && Ut(t) == Yt
        }

        const Xt = Qt;

        function te(t, e, n = {}, i = []) {
            const o = n && n.xmlns;
            const r = o ? t.createElementNS(o, e) : t.createElement(e);
            for (const t in n) {
                r.setAttribute(t, n[t])
            }
            if (Xt(i) || !yt(i)) {
                i = [i]
            }
            for (let e of i) {
                if (Xt(e)) {
                    e = t.createTextNode(e)
                }
                r.appendChild(e)
            }
            return r
        }

        function ee(t, e) {
            return function (n) {
                return t(e(n))
            }
        }

        const ne = ee;
        var ie = ne(Object.getPrototypeOf, Object);
        const oe = ie;
        var re = "[object Object]";
        var se = Function.prototype, ae = Object.prototype;
        var le = se.toString;
        var ce = ae.hasOwnProperty;
        var de = le.call(Object);

        function ue(t) {
            if (!Jt(t) || Ut(t) != re) {
                return false
            }
            var e = oe(t);
            if (e === null) {
                return true
            }
            var n = ce.call(e, "constructor") && e.constructor;
            return typeof n == "function" && n instanceof n && le.call(n) == de
        }

        const he = ue;

        function fe() {
            this.__data__ = [];
            this.size = 0
        }

        const ge = fe;

        function me(t, e) {
            return t === e || t !== t && e !== e
        }

        const pe = me;

        function be(t, e) {
            var n = t.length;
            while (n--) {
                if (pe(t[n][0], e)) {
                    return n
                }
            }
            return -1
        }

        const ke = be;
        var we = Array.prototype;
        var _e = we.splice;

        function Ae(t) {
            var e = this.__data__, n = ke(e, t);
            if (n < 0) {
                return false
            }
            var i = e.length - 1;
            if (n == i) {
                e.pop()
            } else {
                _e.call(e, n, 1)
            }
            --this.size;
            return true
        }

        const Ce = Ae;

        function ve(t) {
            var e = this.__data__, n = ke(e, t);
            return n < 0 ? undefined : e[n][1]
        }

        const ye = ve;

        function xe(t) {
            return ke(this.__data__, t) > -1
        }

        const Ee = xe;

        function Se(t, e) {
            var n = this.__data__, i = ke(n, t);
            if (i < 0) {
                ++this.size;
                n.push([t, e])
            } else {
                n[i][1] = e
            }
            return this
        }

        const De = Se;

        function Te(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        Te.prototype.clear = ge;
        Te.prototype["delete"] = Ce;
        Te.prototype.get = ye;
        Te.prototype.has = Ee;
        Te.prototype.set = De;
        const Be = Te;

        function Pe() {
            this.__data__ = new Be;
            this.size = 0
        }

        const Ie = Pe;

        function Re(t) {
            var e = this.__data__, n = e["delete"](t);
            this.size = e.size;
            return n
        }

        const ze = Re;

        function Ve(t) {
            return this.__data__.get(t)
        }

        const Fe = Ve;

        function Le(t) {
            return this.__data__.has(t)
        }

        const Oe = Le;
        var Ne = "[object AsyncFunction]", Me = "[object Function]", He = "[object GeneratorFunction]",
            We = "[object Proxy]";

        function qe(t) {
            if (!it(t)) {
                return false
            }
            var e = Ut(t);
            return e == Me || e == He || e == Ne || e == We
        }

        const je = qe;
        var $e = Tt["__core-js_shared__"];
        const Ue = $e;
        var Ge = function () {
            var t = /[^.]+$/.exec(Ue && Ue.keys && Ue.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();

        function Ke(t) {
            return !!Ge && Ge in t
        }

        const Ze = Ke;
        var Je = Function.prototype;
        var Ye = Je.toString;

        function Qe(t) {
            if (t != null) {
                try {
                    return Ye.call(t)
                } catch (t) {
                }
                try {
                    return t + ""
                } catch (t) {
                }
            }
            return ""
        }

        const Xe = Qe;
        var tn = /[\\^$.*+?()[\]{}|]/g;
        var en = /^\[object .+?Constructor\]$/;
        var nn = Function.prototype, on = Object.prototype;
        var rn = nn.toString;
        var sn = on.hasOwnProperty;
        var an = RegExp("^" + rn.call(sn).replace(tn, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

        function ln(t) {
            if (!it(t) || Ze(t)) {
                return false
            }
            var e = je(t) ? an : en;
            return e.test(Xe(t))
        }

        const cn = ln;

        function dn(t, e) {
            return t == null ? undefined : t[e]
        }

        const un = dn;

        function hn(t, e) {
            var n = un(t, e);
            return cn(n) ? n : undefined
        }

        const fn = hn;
        var gn = fn(Tt, "Map");
        const mn = gn;
        var pn = fn(Object, "create");
        const bn = pn;

        function kn() {
            this.__data__ = bn ? bn(null) : {};
            this.size = 0
        }

        const wn = kn;

        function _n(t) {
            var e = this.has(t) && delete this.__data__[t];
            this.size -= e ? 1 : 0;
            return e
        }

        const An = _n;
        var Cn = "__lodash_hash_undefined__";
        var vn = Object.prototype;
        var yn = vn.hasOwnProperty;

        function xn(t) {
            var e = this.__data__;
            if (bn) {
                var n = e[t];
                return n === Cn ? undefined : n
            }
            return yn.call(e, t) ? e[t] : undefined
        }

        const En = xn;
        var Sn = Object.prototype;
        var Dn = Sn.hasOwnProperty;

        function Tn(t) {
            var e = this.__data__;
            return bn ? e[t] !== undefined : Dn.call(e, t)
        }

        const Bn = Tn;
        var Pn = "__lodash_hash_undefined__";

        function In(t, e) {
            var n = this.__data__;
            this.size += this.has(t) ? 0 : 1;
            n[t] = bn && e === undefined ? Pn : e;
            return this
        }

        const Rn = In;

        function zn(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        zn.prototype.clear = wn;
        zn.prototype["delete"] = An;
        zn.prototype.get = En;
        zn.prototype.has = Bn;
        zn.prototype.set = Rn;
        const Vn = zn;

        function Fn() {
            this.size = 0;
            this.__data__ = {hash: new Vn, map: new (mn || Be), string: new Vn}
        }

        const Ln = Fn;

        function On(t) {
            var e = typeof t;
            return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
        }

        const Nn = On;

        function Mn(t, e) {
            var n = t.__data__;
            return Nn(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
        }

        const Hn = Mn;

        function Wn(t) {
            var e = Hn(this, t)["delete"](t);
            this.size -= e ? 1 : 0;
            return e
        }

        const qn = Wn;

        function jn(t) {
            return Hn(this, t).get(t)
        }

        const $n = jn;

        function Un(t) {
            return Hn(this, t).has(t)
        }

        const Gn = Un;

        function Kn(t, e) {
            var n = Hn(this, t), i = n.size;
            n.set(t, e);
            this.size += n.size == i ? 0 : 1;
            return this
        }

        const Zn = Kn;

        function Jn(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        Jn.prototype.clear = Ln;
        Jn.prototype["delete"] = qn;
        Jn.prototype.get = $n;
        Jn.prototype.has = Gn;
        Jn.prototype.set = Zn;
        const Yn = Jn;
        var Qn = 200;

        function Xn(t, e) {
            var n = this.__data__;
            if (n instanceof Be) {
                var i = n.__data__;
                if (!mn || i.length < Qn - 1) {
                    i.push([t, e]);
                    this.size = ++n.size;
                    return this
                }
                n = this.__data__ = new Yn(i)
            }
            n.set(t, e);
            this.size = n.size;
            return this
        }

        const ti = Xn;

        function ei(t) {
            var e = this.__data__ = new Be(t);
            this.size = e.size
        }

        ei.prototype.clear = Ie;
        ei.prototype["delete"] = ze;
        ei.prototype.get = Fe;
        ei.prototype.has = Oe;
        ei.prototype.set = ti;
        const ni = ei;

        function ii(t, e) {
            var n = -1, i = t == null ? 0 : t.length;
            while (++n < i) {
                if (e(t[n], n, t) === false) {
                    break
                }
            }
            return t
        }

        const oi = ii;
        var ri = function () {
            try {
                var t = fn(Object, "defineProperty");
                t({}, "", {});
                return t
            } catch (t) {
            }
        }();
        const si = ri;

        function ai(t, e, n) {
            if (e == "__proto__" && si) {
                si(t, e, {configurable: true, enumerable: true, value: n, writable: true})
            } else {
                t[e] = n
            }
        }

        const li = ai;
        var ci = Object.prototype;
        var di = ci.hasOwnProperty;

        function ui(t, e, n) {
            var i = t[e];
            if (!(di.call(t, e) && pe(i, n)) || n === undefined && !(e in t)) {
                li(t, e, n)
            }
        }

        const hi = ui;

        function fi(t, e, n, i) {
            var o = !n;
            n || (n = {});
            var r = -1, s = e.length;
            while (++r < s) {
                var a = e[r];
                var l = i ? i(n[a], t[a], a, n, t) : undefined;
                if (l === undefined) {
                    l = t[a]
                }
                if (o) {
                    li(n, a, l)
                } else {
                    hi(n, a, l)
                }
            }
            return n
        }

        const gi = fi;

        function mi(t, e) {
            var n = -1, i = Array(t);
            while (++n < t) {
                i[n] = e(n)
            }
            return i
        }

        const pi = mi;
        var bi = "[object Arguments]";

        function ki(t) {
            return Jt(t) && Ut(t) == bi
        }

        const wi = ki;
        var _i = Object.prototype;
        var Ai = _i.hasOwnProperty;
        var Ci = _i.propertyIsEnumerable;
        var vi = wi(function () {
            return arguments
        }()) ? wi : function (t) {
            return Jt(t) && Ai.call(t, "callee") && !Ci.call(t, "callee")
        };
        const yi = vi;

        function xi() {
            return false
        }

        const Ei = xi;
        var Si = typeof exports == "object" && exports && !exports.nodeType && exports;
        var Di = Si && typeof module == "object" && module && !module.nodeType && module;
        var Ti = Di && Di.exports === Si;
        var Bi = Ti ? Tt.Buffer : undefined;
        var Pi = Bi ? Bi.isBuffer : undefined;
        var Ii = Pi || Ei;
        const Ri = Ii;
        var zi = 9007199254740991;
        var Vi = /^(?:0|[1-9]\d*)$/;

        function Fi(t, e) {
            var n = typeof t;
            e = e == null ? zi : e;
            return !!e && (n == "number" || n != "symbol" && Vi.test(t)) && (t > -1 && t % 1 == 0 && t < e)
        }

        const Li = Fi;
        var Oi = 9007199254740991;

        function Ni(t) {
            return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Oi
        }

        const Mi = Ni;
        var Hi = "[object Arguments]", Wi = "[object Array]", qi = "[object Boolean]", ji = "[object Date]",
            $i = "[object Error]", Ui = "[object Function]", Gi = "[object Map]", Ki = "[object Number]",
            Zi = "[object Object]", Ji = "[object RegExp]", Yi = "[object Set]", Qi = "[object String]",
            Xi = "[object WeakMap]";
        var to = "[object ArrayBuffer]", eo = "[object DataView]", no = "[object Float32Array]",
            io = "[object Float64Array]", oo = "[object Int8Array]", ro = "[object Int16Array]",
            so = "[object Int32Array]", ao = "[object Uint8Array]", lo = "[object Uint8ClampedArray]",
            co = "[object Uint16Array]", uo = "[object Uint32Array]";
        var ho = {};
        ho[no] = ho[io] = ho[oo] = ho[ro] = ho[so] = ho[ao] = ho[lo] = ho[co] = ho[uo] = true;
        ho[Hi] = ho[Wi] = ho[to] = ho[qi] = ho[eo] = ho[ji] = ho[$i] = ho[Ui] = ho[Gi] = ho[Ki] = ho[Zi] = ho[Ji] = ho[Yi] = ho[Qi] = ho[Xi] = false;

        function fo(t) {
            return Jt(t) && Mi(t.length) && !!ho[Ut(t)]
        }

        const go = fo;

        function mo(t) {
            return function (e) {
                return t(e)
            }
        }

        const po = mo;
        var bo = typeof exports == "object" && exports && !exports.nodeType && exports;
        var ko = bo && typeof module == "object" && module && !module.nodeType && module;
        var wo = ko && ko.exports === bo;
        var _o = wo && Et.process;
        var Ao = function () {
            try {
                var t = ko && ko.require && ko.require("util").types;
                if (t) {
                    return t
                }
                return _o && _o.binding && _o.binding("util")
            } catch (t) {
            }
        }();
        const Co = Ao;
        var vo = Co && Co.isTypedArray;
        var yo = vo ? po(vo) : go;
        const xo = yo;
        var Eo = Object.prototype;
        var So = Eo.hasOwnProperty;

        function Do(t, e) {
            var n = Kt(t), i = !n && yi(t), o = !n && !i && Ri(t), r = !n && !i && !o && xo(t), s = n || i || o || r,
                a = s ? pi(t.length, String) : [], l = a.length;
            for (var c in t) {
                if ((e || So.call(t, c)) && !(s && (c == "length" || o && (c == "offset" || c == "parent") || r && (c == "buffer" || c == "byteLength" || c == "byteOffset") || Li(c, l)))) {
                    a.push(c)
                }
            }
            return a
        }

        const To = Do;
        var Bo = Object.prototype;

        function Po(t) {
            var e = t && t.constructor, n = typeof e == "function" && e.prototype || Bo;
            return t === n
        }

        const Io = Po;
        var Ro = ne(Object.keys, Object);
        const zo = Ro;
        var Vo = Object.prototype;
        var Fo = Vo.hasOwnProperty;

        function Lo(t) {
            if (!Io(t)) {
                return zo(t)
            }
            var e = [];
            for (var n in Object(t)) {
                if (Fo.call(t, n) && n != "constructor") {
                    e.push(n)
                }
            }
            return e
        }

        const Oo = Lo;

        function No(t) {
            return t != null && Mi(t.length) && !je(t)
        }

        const Mo = No;

        function Ho(t) {
            return Mo(t) ? To(t) : Oo(t)
        }

        const Wo = Ho;

        function qo(t, e) {
            return t && gi(e, Wo(e), t)
        }

        const jo = qo;

        function $o(t) {
            var e = [];
            if (t != null) {
                for (var n in Object(t)) {
                    e.push(n)
                }
            }
            return e
        }

        const Uo = $o;
        var Go = Object.prototype;
        var Ko = Go.hasOwnProperty;

        function Zo(t) {
            if (!it(t)) {
                return Uo(t)
            }
            var e = Io(t), n = [];
            for (var i in t) {
                if (!(i == "constructor" && (e || !Ko.call(t, i)))) {
                    n.push(i)
                }
            }
            return n
        }

        const Jo = Zo;

        function Yo(t) {
            return Mo(t) ? To(t, true) : Jo(t)
        }

        const Qo = Yo;

        function Xo(t, e) {
            return t && gi(e, Qo(e), t)
        }

        const tr = Xo;
        var er = typeof exports == "object" && exports && !exports.nodeType && exports;
        var nr = er && typeof module == "object" && module && !module.nodeType && module;
        var ir = nr && nr.exports === er;
        var or = ir ? Tt.Buffer : undefined, rr = or ? or.allocUnsafe : undefined;

        function sr(t, e) {
            if (e) {
                return t.slice()
            }
            var n = t.length, i = rr ? rr(n) : new t.constructor(n);
            t.copy(i);
            return i
        }

        const ar = sr;

        function lr(t, e) {
            var n = -1, i = t.length;
            e || (e = Array(i));
            while (++n < i) {
                e[n] = t[n]
            }
            return e
        }

        const cr = lr;

        function dr(t, e) {
            var n = -1, i = t == null ? 0 : t.length, o = 0, r = [];
            while (++n < i) {
                var s = t[n];
                if (e(s, n, t)) {
                    r[o++] = s
                }
            }
            return r
        }

        const ur = dr;

        function hr() {
            return []
        }

        const fr = hr;
        var gr = Object.prototype;
        var mr = gr.propertyIsEnumerable;
        var pr = Object.getOwnPropertySymbols;
        var br = !pr ? fr : function (t) {
            if (t == null) {
                return []
            }
            t = Object(t);
            return ur(pr(t), (function (e) {
                return mr.call(t, e)
            }))
        };
        const kr = br;

        function wr(t, e) {
            return gi(t, kr(t), e)
        }

        const _r = wr;

        function Ar(t, e) {
            var n = -1, i = e.length, o = t.length;
            while (++n < i) {
                t[o + n] = e[n]
            }
            return t
        }

        const Cr = Ar;
        var vr = Object.getOwnPropertySymbols;
        var yr = !vr ? fr : function (t) {
            var e = [];
            while (t) {
                Cr(e, kr(t));
                t = oe(t)
            }
            return e
        };
        const xr = yr;

        function Er(t, e) {
            return gi(t, xr(t), e)
        }

        const Sr = Er;

        function Dr(t, e, n) {
            var i = e(t);
            return Kt(t) ? i : Cr(i, n(t))
        }

        const Tr = Dr;

        function Br(t) {
            return Tr(t, Wo, kr)
        }

        const Pr = Br;

        function Ir(t) {
            return Tr(t, Qo, xr)
        }

        const Rr = Ir;
        var zr = fn(Tt, "DataView");
        const Vr = zr;
        var Fr = fn(Tt, "Promise");
        const Lr = Fr;
        var Or = fn(Tt, "Set");
        const Nr = Or;
        var Mr = fn(Tt, "WeakMap");
        const Hr = Mr;
        var Wr = "[object Map]", qr = "[object Object]", jr = "[object Promise]", $r = "[object Set]",
            Ur = "[object WeakMap]";
        var Gr = "[object DataView]";
        var Kr = Xe(Vr), Zr = Xe(mn), Jr = Xe(Lr), Yr = Xe(Nr), Qr = Xe(Hr);
        var Xr = Ut;
        if (Vr && Xr(new Vr(new ArrayBuffer(1))) != Gr || mn && Xr(new mn) != Wr || Lr && Xr(Lr.resolve()) != jr || Nr && Xr(new Nr) != $r || Hr && Xr(new Hr) != Ur) {
            Xr = function (t) {
                var e = Ut(t), n = e == qr ? t.constructor : undefined, i = n ? Xe(n) : "";
                if (i) {
                    switch (i) {
                        case Kr:
                            return Gr;
                        case Zr:
                            return Wr;
                        case Jr:
                            return jr;
                        case Yr:
                            return $r;
                        case Qr:
                            return Ur
                    }
                }
                return e
            }
        }
        const ts = Xr;
        var es = Object.prototype;
        var ns = es.hasOwnProperty;

        function is(t) {
            var e = t.length, n = new t.constructor(e);
            if (e && typeof t[0] == "string" && ns.call(t, "index")) {
                n.index = t.index;
                n.input = t.input
            }
            return n
        }

        const os = is;
        var rs = Tt.Uint8Array;
        const ss = rs;

        function as(t) {
            var e = new t.constructor(t.byteLength);
            new ss(e).set(new ss(t));
            return e
        }

        const ls = as;

        function cs(t, e) {
            var n = e ? ls(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength)
        }

        const ds = cs;
        var us = /\w*$/;

        function hs(t) {
            var e = new t.constructor(t.source, us.exec(t));
            e.lastIndex = t.lastIndex;
            return e
        }

        const fs = hs;
        var gs = Pt ? Pt.prototype : undefined, ms = gs ? gs.valueOf : undefined;

        function ps(t) {
            return ms ? Object(ms.call(t)) : {}
        }

        const bs = ps;

        function ks(t, e) {
            var n = e ? ls(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length)
        }

        const ws = ks;
        var _s = "[object Boolean]", As = "[object Date]", Cs = "[object Map]", vs = "[object Number]",
            ys = "[object RegExp]", xs = "[object Set]", Es = "[object String]", Ss = "[object Symbol]";
        var Ds = "[object ArrayBuffer]", Ts = "[object DataView]", Bs = "[object Float32Array]",
            Ps = "[object Float64Array]", Is = "[object Int8Array]", Rs = "[object Int16Array]",
            zs = "[object Int32Array]", Vs = "[object Uint8Array]", Fs = "[object Uint8ClampedArray]",
            Ls = "[object Uint16Array]", Os = "[object Uint32Array]";

        function Ns(t, e, n) {
            var i = t.constructor;
            switch (e) {
                case Ds:
                    return ls(t);
                case _s:
                case As:
                    return new i(+t);
                case Ts:
                    return ds(t, n);
                case Bs:
                case Ps:
                case Is:
                case Rs:
                case zs:
                case Vs:
                case Fs:
                case Ls:
                case Os:
                    return ws(t, n);
                case Cs:
                    return new i;
                case vs:
                case Es:
                    return new i(t);
                case ys:
                    return fs(t);
                case xs:
                    return new i;
                case Ss:
                    return bs(t)
            }
        }

        const Ms = Ns;
        var Hs = Object.create;
        var Ws = function () {
            function t() {
            }

            return function (e) {
                if (!it(e)) {
                    return {}
                }
                if (Hs) {
                    return Hs(e)
                }
                t.prototype = e;
                var n = new t;
                t.prototype = undefined;
                return n
            }
        }();
        const qs = Ws;

        function js(t) {
            return typeof t.constructor == "function" && !Io(t) ? qs(oe(t)) : {}
        }

        const $s = js;
        var Us = "[object Map]";

        function Gs(t) {
            return Jt(t) && ts(t) == Us
        }

        const Ks = Gs;
        var Zs = Co && Co.isMap;
        var Js = Zs ? po(Zs) : Ks;
        const Ys = Js;
        var Qs = "[object Set]";

        function Xs(t) {
            return Jt(t) && ts(t) == Qs
        }

        const ta = Xs;
        var ea = Co && Co.isSet;
        var na = ea ? po(ea) : ta;
        const ia = na;
        var oa = 1, ra = 2, sa = 4;
        var aa = "[object Arguments]", la = "[object Array]", ca = "[object Boolean]", da = "[object Date]",
            ua = "[object Error]", ha = "[object Function]", fa = "[object GeneratorFunction]", ga = "[object Map]",
            ma = "[object Number]", pa = "[object Object]", ba = "[object RegExp]", ka = "[object Set]",
            wa = "[object String]", _a = "[object Symbol]", Aa = "[object WeakMap]";
        var Ca = "[object ArrayBuffer]", va = "[object DataView]", ya = "[object Float32Array]",
            xa = "[object Float64Array]", Ea = "[object Int8Array]", Sa = "[object Int16Array]",
            Da = "[object Int32Array]", Ta = "[object Uint8Array]", Ba = "[object Uint8ClampedArray]",
            Pa = "[object Uint16Array]", Ia = "[object Uint32Array]";
        var Ra = {};
        Ra[aa] = Ra[la] = Ra[Ca] = Ra[va] = Ra[ca] = Ra[da] = Ra[ya] = Ra[xa] = Ra[Ea] = Ra[Sa] = Ra[Da] = Ra[ga] = Ra[ma] = Ra[pa] = Ra[ba] = Ra[ka] = Ra[wa] = Ra[_a] = Ra[Ta] = Ra[Ba] = Ra[Pa] = Ra[Ia] = true;
        Ra[ua] = Ra[ha] = Ra[Aa] = false;

        function za(t, e, n, i, o, r) {
            var s, a = e & oa, l = e & ra, c = e & sa;
            if (n) {
                s = o ? n(t, i, o, r) : n(t)
            }
            if (s !== undefined) {
                return s
            }
            if (!it(t)) {
                return t
            }
            var d = Kt(t);
            if (d) {
                s = os(t);
                if (!a) {
                    return cr(t, s)
                }
            } else {
                var u = ts(t), h = u == ha || u == fa;
                if (Ri(t)) {
                    return ar(t, a)
                }
                if (u == pa || u == aa || h && !o) {
                    s = l || h ? {} : $s(t);
                    if (!a) {
                        return l ? Sr(t, tr(s, t)) : _r(t, jo(s, t))
                    }
                } else {
                    if (!Ra[u]) {
                        return o ? t : {}
                    }
                    s = Ms(t, u, a)
                }
            }
            r || (r = new ni);
            var f = r.get(t);
            if (f) {
                return f
            }
            r.set(t, s);
            if (ia(t)) {
                t.forEach((function (i) {
                    s.add(za(i, e, n, i, t, r))
                }))
            } else if (Ys(t)) {
                t.forEach((function (i, o) {
                    s.set(o, za(i, e, n, o, t, r))
                }))
            }
            var g = c ? l ? Rr : Pr : l ? Qo : Wo;
            var m = d ? undefined : g(t);
            oi(m || t, (function (i, o) {
                if (m) {
                    o = i;
                    i = t[o]
                }
                hi(s, o, za(i, e, n, o, t, r))
            }));
            return s
        }

        const Va = za;
        var Fa = 1, La = 4;

        function Oa(t, e) {
            e = typeof e == "function" ? e : undefined;
            return Va(t, Fa | La, e)
        }

        const Na = Oa;

        function Ma(t) {
            return Jt(t) && t.nodeType === 1 && !he(t)
        }

        const Ha = Ma;

        class Wa {
            constructor(t, e) {
                this._config = {};
                if (e) {
                    this.define(qa(e))
                }
                if (t) {
                    this._setObjectToTarget(this._config, t)
                }
            }

            set(t, e) {
                this._setToTarget(this._config, t, e)
            }

            define(t, e) {
                const n = true;
                this._setToTarget(this._config, t, e, n)
            }

            get(t) {
                return this._getFromSource(this._config, t)
            }

            * names() {
                for (const t of Object.keys(this._config)) {
                    yield t
                }
            }

            _setToTarget(t, e, n, i = false) {
                if (he(e)) {
                    this._setObjectToTarget(t, e, i);
                    return
                }
                const o = e.split(".");
                e = o.pop();
                for (const e of o) {
                    if (!he(t[e])) {
                        t[e] = {}
                    }
                    t = t[e]
                }
                if (he(n)) {
                    if (!he(t[e])) {
                        t[e] = {}
                    }
                    t = t[e];
                    this._setObjectToTarget(t, n, i);
                    return
                }
                if (i && typeof t[e] != "undefined") {
                    return
                }
                t[e] = n
            }

            _getFromSource(t, e) {
                const n = e.split(".");
                e = n.pop();
                for (const e of n) {
                    if (!he(t[e])) {
                        t = null;
                        break
                    }
                    t = t[e]
                }
                return t ? qa(t[e]) : undefined
            }

            _setObjectToTarget(t, e, n) {
                Object.keys(e).forEach((i => {
                    this._setToTarget(t, i, e[i], n)
                }))
            }
        }

        function qa(t) {
            return Na(t, ja)
        }

        function ja(t) {
            return Ha(t) ? t : undefined
        }

        function $a(t) {
            if (t) {
                if (t.defaultView) {
                    return t instanceof t.defaultView.Document
                } else if (t.ownerDocument && t.ownerDocument.defaultView) {
                    return t instanceof t.ownerDocument.defaultView.Node
                }
            }
            return false
        }

        function Ua(t) {
            const e = Object.prototype.toString.apply(t);
            if (e == "[object Window]") {
                return true
            }
            if (e == "[object global]") {
                return true
            }
            return false
        }

        const Ga = Ka(j());

        function Ka(t) {
            if (!t) {
                return Ga
            }

            class e extends t {
                listenTo(t, e, n, i = {}) {
                    if ($a(t) || Ua(t)) {
                        const o = {capture: !!i.useCapture, passive: !!i.usePassive};
                        const r = this._getProxyEmitter(t, o) || new Za(t, o);
                        this.listenTo(r, e, n, i)
                    } else {
                        super.listenTo(t, e, n, i)
                    }
                }

                stopListening(t, e, n) {
                    if ($a(t) || Ua(t)) {
                        const i = this._getAllProxyEmitters(t);
                        for (const t of i) {
                            this.stopListening(t, e, n)
                        }
                    } else {
                        super.stopListening(t, e, n)
                    }
                }

                _getProxyEmitter(t, e) {
                    return $(this, Ya(t, e))
                }

                _getAllProxyEmitters(t) {
                    return [{capture: false, passive: false}, {capture: false, passive: true}, {
                        capture: true,
                        passive: false
                    }, {capture: true, passive: true}].map((e => this._getProxyEmitter(t, e))).filter((t => !!t))
                }
            }

            return e
        }

        ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
            Ka[t] = Ga.prototype[t]
        }));

        class Za extends (j()) {
            constructor(t, e) {
                super();
                U(this, Ya(t, e));
                this._domNode = t;
                this._options = e
            }

            attach(t) {
                if (this._domListeners && this._domListeners[t]) {
                    return
                }
                const e = this._createDomListener(t);
                this._domNode.addEventListener(t, e, this._options);
                if (!this._domListeners) {
                    this._domListeners = {}
                }
                this._domListeners[t] = e
            }

            detach(t) {
                let e;
                if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
                    this._domListeners[t].removeListener()
                }
            }

            _addEventListener(t, e, n) {
                this.attach(t);
                j().prototype._addEventListener.call(this, t, e, n)
            }

            _removeEventListener(t, e) {
                j().prototype._removeEventListener.call(this, t, e);
                this.detach(t)
            }

            _createDomListener(t) {
                const e = e => {
                    this.fire(t, e)
                };
                e.removeListener = () => {
                    this._domNode.removeEventListener(t, e, this._options);
                    delete this._domListeners[t]
                };
                return e
            }
        }

        function Ja(t) {
            return t["data-ck-expando"] || (t["data-ck-expando"] = E())
        }

        function Ya(t, e) {
            let n = Ja(t);
            for (const t of Object.keys(e).sort()) {
                if (e[t]) {
                    n += "-" + t
                }
            }
            return n
        }

        let Qa;
        try {
            Qa = {window, document}
        } catch (t) {
            Qa = {window: {}, document: {}}
        }
        const Xa = Qa;

        function tl(t) {
            const e = [];
            let n = t;
            while (n && n.nodeType != Node.DOCUMENT_NODE) {
                e.unshift(n);
                n = n.parentNode
            }
            return e
        }

        function el(t) {
            if (t instanceof HTMLTextAreaElement) {
                return t.value
            }
            return t.innerHTML
        }

        function nl(t) {
            return Object.prototype.toString.call(t) == "[object Text]"
        }

        function il(t) {
            return Object.prototype.toString.apply(t) == "[object Range]"
        }

        function ol(t) {
            const e = t.ownerDocument.defaultView.getComputedStyle(t);
            return {
                top: parseInt(e.borderTopWidth, 10),
                right: parseInt(e.borderRightWidth, 10),
                bottom: parseInt(e.borderBottomWidth, 10),
                left: parseInt(e.borderLeftWidth, 10)
            }
        }

        const rl = ["top", "right", "bottom", "left", "width", "height"];

        class sl {
            constructor(t) {
                const e = il(t);
                Object.defineProperty(this, "_source", {value: t._source || t, writable: true, enumerable: false});
                if (cl(t) || e) {
                    if (e) {
                        const e = sl.getDomRangeRects(t);
                        al(this, sl.getBoundingRect(e))
                    } else {
                        al(this, t.getBoundingClientRect())
                    }
                } else if (Ua(t)) {
                    const {innerWidth: e, innerHeight: n} = t;
                    al(this, {top: 0, right: e, bottom: n, left: 0, width: e, height: n})
                } else {
                    al(this, t)
                }
            }

            clone() {
                return new sl(this)
            }

            moveTo(t, e) {
                this.top = e;
                this.right = t + this.width;
                this.bottom = e + this.height;
                this.left = t;
                return this
            }

            moveBy(t, e) {
                this.top += e;
                this.right += t;
                this.left += t;
                this.bottom += e;
                return this
            }

            getIntersection(t) {
                const e = {
                    top: Math.max(this.top, t.top),
                    right: Math.min(this.right, t.right),
                    bottom: Math.min(this.bottom, t.bottom),
                    left: Math.max(this.left, t.left),
                    width: 0,
                    height: 0
                };
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                if (e.width < 0 || e.height < 0) {
                    return null
                } else {
                    return new sl(e)
                }
            }

            getIntersectionArea(t) {
                const e = this.getIntersection(t);
                if (e) {
                    return e.getArea()
                } else {
                    return 0
                }
            }

            getArea() {
                return this.width * this.height
            }

            getVisible() {
                const t = this._source;
                let e = this.clone();
                if (!ll(t)) {
                    let n = t.parentNode || t.commonAncestorContainer;
                    while (n && !ll(n)) {
                        const t = new sl(n);
                        const i = e.getIntersection(t);
                        if (i) {
                            if (i.getArea() < e.getArea()) {
                                e = i
                            }
                        } else {
                            return null
                        }
                        n = n.parentNode
                    }
                }
                return e
            }

            isEqual(t) {
                for (const e of rl) {
                    if (this[e] !== t[e]) {
                        return false
                    }
                }
                return true
            }

            contains(t) {
                const e = this.getIntersection(t);
                return !!(e && e.isEqual(t))
            }

            excludeScrollbarsAndBorders() {
                const t = this._source;
                let e, n, i;
                if (Ua(t)) {
                    e = t.innerWidth - t.document.documentElement.clientWidth;
                    n = t.innerHeight - t.document.documentElement.clientHeight;
                    i = t.getComputedStyle(t.document.documentElement).direction
                } else {
                    const o = ol(t);
                    e = t.offsetWidth - t.clientWidth - o.left - o.right;
                    n = t.offsetHeight - t.clientHeight - o.top - o.bottom;
                    i = t.ownerDocument.defaultView.getComputedStyle(t).direction;
                    this.left += o.left;
                    this.top += o.top;
                    this.right -= o.right;
                    this.bottom -= o.bottom;
                    this.width = this.right - this.left;
                    this.height = this.bottom - this.top
                }
                this.width -= e;
                if (i === "ltr") {
                    this.right -= e
                } else {
                    this.left += e
                }
                this.height -= n;
                this.bottom -= n;
                return this
            }

            static getDomRangeRects(t) {
                const e = [];
                const n = Array.from(t.getClientRects());
                if (n.length) {
                    for (const t of n) {
                        e.push(new sl(t))
                    }
                } else {
                    let n = t.startContainer;
                    if (nl(n)) {
                        n = n.parentNode
                    }
                    const i = new sl(n.getBoundingClientRect());
                    i.right = i.left;
                    i.width = 0;
                    e.push(i)
                }
                return e
            }

            static getBoundingRect(t) {
                const e = {
                    left: Number.POSITIVE_INFINITY,
                    top: Number.POSITIVE_INFINITY,
                    right: Number.NEGATIVE_INFINITY,
                    bottom: Number.NEGATIVE_INFINITY,
                    width: 0,
                    height: 0
                };
                let n = 0;
                for (const i of t) {
                    n++;
                    e.left = Math.min(e.left, i.left);
                    e.top = Math.min(e.top, i.top);
                    e.right = Math.max(e.right, i.right);
                    e.bottom = Math.max(e.bottom, i.bottom)
                }
                if (n == 0) {
                    return null
                }
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                return new sl(e)
            }
        }

        function al(t, e) {
            for (const n of rl) {
                t[n] = e[n]
            }
        }

        function ll(t) {
            if (!cl(t)) {
                return false
            }
            return t === t.ownerDocument.body
        }

        function cl(t) {
            return t !== null && typeof t === "object" && t.nodeType === 1 && typeof t.getBoundingClientRect === "function"
        }

        class dl {
            constructor(t, e) {
                if (!dl._observerInstance) {
                    dl._createObserver()
                }
                this._element = t;
                this._callback = e;
                dl._addElementCallback(t, e);
                dl._observerInstance.observe(t)
            }

            destroy() {
                dl._deleteElementCallback(this._element, this._callback)
            }

            static _addElementCallback(t, e) {
                if (!dl._elementCallbacks) {
                    dl._elementCallbacks = new Map
                }
                let n = dl._elementCallbacks.get(t);
                if (!n) {
                    n = new Set;
                    dl._elementCallbacks.set(t, n)
                }
                n.add(e)
            }

            static _deleteElementCallback(t, e) {
                const n = dl._getElementCallbacks(t);
                if (n) {
                    n.delete(e);
                    if (!n.size) {
                        dl._elementCallbacks.delete(t);
                        dl._observerInstance.unobserve(t)
                    }
                }
                if (dl._elementCallbacks && !dl._elementCallbacks.size) {
                    dl._observerInstance = null;
                    dl._elementCallbacks = null
                }
            }

            static _getElementCallbacks(t) {
                if (!dl._elementCallbacks) {
                    return null
                }
                return dl._elementCallbacks.get(t)
            }

            static _createObserver() {
                dl._observerInstance = new Xa.window.ResizeObserver((t => {
                    for (const e of t) {
                        const t = dl._getElementCallbacks(e.target);
                        if (t) {
                            for (const n of t) {
                                n(e)
                            }
                        }
                    }
                }))
            }
        }

        dl._observerInstance = null;
        dl._elementCallbacks = null;

        function ul(t, e) {
            if (t instanceof HTMLTextAreaElement) {
                t.value = e
            }
            t.innerHTML = e
        }

        function hl(t) {
            return e => e + t
        }

        function fl(t) {
            let e = 0;
            while (t.previousSibling) {
                t = t.previousSibling;
                e++
            }
            return e
        }

        function gl(t, e, n) {
            t.insertBefore(n, t.childNodes[e] || null)
        }

        function ml(t) {
            return t && t.nodeType === Node.COMMENT_NODE
        }

        function pl(t) {
            return !!(t && t.getClientRects && t.getClientRects().length)
        }

        function bl(t) {
            if (!t || !t.parentNode) {
                return null
            }
            if (t.offsetParent === Xa.document.body) {
                return null
            }
            return t.offsetParent
        }

        function kl({element: t, target: e, positions: n, limiter: i, fitInViewport: o, viewportOffsetConfig: r}) {
            if (je(e)) {
                e = e()
            }
            if (je(i)) {
                i = i()
            }
            const s = bl(t);
            const a = new sl(t);
            const l = new sl(e);
            let c;
            const d = o && wl(r) || null;
            const u = {targetRect: l, elementRect: a, positionedElementAncestor: s, viewportRect: d};
            if (!i && !o) {
                c = new vl(n[0], u)
            } else {
                const t = i && new sl(i).getVisible();
                Object.assign(u, {limiterRect: t, viewportRect: d});
                c = _l(n, u) || new vl(n[0], u)
            }
            return c
        }

        function wl(t) {
            t = Object.assign({top: 0, bottom: 0, left: 0, right: 0}, t);
            const e = new sl(Xa.window);
            e.top += t.top;
            e.height -= t.top;
            e.bottom -= t.bottom;
            e.height -= t.bottom;
            return e
        }

        function _l(t, e) {
            const {elementRect: n} = e;
            const i = n.getArea();
            const o = t.map((t => new vl(t, e))).filter((t => !!t.name));
            let r = 0;
            let s = null;
            for (const t of o) {
                const {limiterIntersectionArea: e, viewportIntersectionArea: n} = t;
                if (e === i) {
                    return t
                }
                const o = n ** 2 + e ** 2;
                if (o > r) {
                    r = o;
                    s = t
                }
            }
            return s
        }

        function Al(t, e) {
            const n = Cl(new sl(e));
            const i = ol(e);
            let o = 0;
            let r = 0;
            o -= n.left;
            r -= n.top;
            o += e.scrollLeft;
            r += e.scrollTop;
            o -= i.left;
            r -= i.top;
            t.moveBy(o, r)
        }

        function Cl(t) {
            const {scrollX: e, scrollY: n} = Xa.window;
            return t.clone().moveBy(e, n)
        }

        class vl {
            constructor(t, e) {
                const n = t(e.targetRect, e.elementRect, e.viewportRect);
                if (!n) {
                    return
                }
                const {left: i, top: o, name: r, config: s} = n;
                this.name = r;
                this.config = s;
                this._positioningFunctionCorrdinates = {left: i, top: o};
                this._options = e
            }

            get left() {
                return this._absoluteRect.left
            }

            get top() {
                return this._absoluteRect.top
            }

            get limiterIntersectionArea() {
                const t = this._options.limiterRect;
                if (t) {
                    const e = this._options.viewportRect;
                    if (e) {
                        const n = t.getIntersection(e);
                        if (n) {
                            return n.getIntersectionArea(this._rect)
                        }
                    } else {
                        return t.getIntersectionArea(this._rect)
                    }
                }
                return 0
            }

            get viewportIntersectionArea() {
                const t = this._options.viewportRect;
                if (t) {
                    return t.getIntersectionArea(this._rect)
                }
                return 0
            }

            get _rect() {
                if (this._cachedRect) {
                    return this._cachedRect
                }
                this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top);
                return this._cachedRect
            }

            get _absoluteRect() {
                if (this._cachedAbsoluteRect) {
                    return this._cachedAbsoluteRect
                }
                this._cachedAbsoluteRect = Cl(this._rect);
                if (this._options.positionedElementAncestor) {
                    Al(this._cachedAbsoluteRect, this._options.positionedElementAncestor)
                }
                return this._cachedAbsoluteRect
            }
        }

        function yl(t) {
            const e = t.parentNode;
            if (e) {
                e.removeChild(t)
            }
        }

        function xl({target: t, viewportOffset: e = 0}) {
            const n = Rl(t);
            let i = n;
            let o = null;
            while (i) {
                let r;
                if (i == n) {
                    r = zl(t)
                } else {
                    r = zl(o)
                }
                Dl(r, (() => Vl(t, i)));
                const s = Vl(t, i);
                Sl(i, s, e);
                if (i.parent != i) {
                    o = i.frameElement;
                    i = i.parent;
                    if (!o) {
                        return
                    }
                } else {
                    i = null
                }
            }
        }

        function El(t) {
            const e = zl(t);
            Dl(e, (() => new Rect(t)))
        }

        function Sl(t, e, n) {
            const i = e.clone().moveBy(0, n);
            const o = e.clone().moveBy(0, -n);
            const r = new sl(t).excludeScrollbarsAndBorders();
            const s = [o, i];
            if (!s.every((t => r.contains(t)))) {
                let {scrollX: s, scrollY: a} = t;
                if (Bl(o, r)) {
                    a -= r.top - e.top + n
                } else if (Tl(i, r)) {
                    a += e.bottom - r.bottom + n
                }
                if (Pl(e, r)) {
                    s -= r.left - e.left + n
                } else if (Il(e, r)) {
                    s += e.right - r.right + n
                }
                t.scrollTo(s, a)
            }
        }

        function Dl(t, e) {
            const n = Rl(t);
            let i, o;
            while (t != n.document.body) {
                o = e();
                i = new sl(t).excludeScrollbarsAndBorders();
                if (!i.contains(o)) {
                    if (Bl(o, i)) {
                        t.scrollTop -= i.top - o.top
                    } else if (Tl(o, i)) {
                        t.scrollTop += o.bottom - i.bottom
                    }
                    if (Pl(o, i)) {
                        t.scrollLeft -= i.left - o.left
                    } else if (Il(o, i)) {
                        t.scrollLeft += o.right - i.right
                    }
                }
                t = t.parentNode
            }
        }

        function Tl(t, e) {
            return t.bottom > e.bottom
        }

        function Bl(t, e) {
            return t.top < e.top
        }

        function Pl(t, e) {
            return t.left < e.left
        }

        function Il(t, e) {
            return t.right > e.right
        }

        function Rl(t) {
            if (il(t)) {
                return t.startContainer.ownerDocument.defaultView
            } else {
                return t.ownerDocument.defaultView
            }
        }

        function zl(t) {
            if (il(t)) {
                let e = t.commonAncestorContainer;
                if (nl(e)) {
                    e = e.parentNode
                }
                return e
            } else {
                return t.parentNode
            }
        }

        function Vl(t, e) {
            const n = Rl(t);
            const i = new sl(t);
            if (n === e) {
                return i
            } else {
                let t = n;
                while (t != e) {
                    const e = t.frameElement;
                    const n = new sl(e).excludeScrollbarsAndBorders();
                    i.moveBy(n.left, n.top);
                    t = t.parent
                }
            }
            return i
        }

        const Fl = {ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧"};
        const Ll = {ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+"};
        const Ol = Gl();
        const Nl = Object.fromEntries(Object.entries(Ol).map((([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)])));

        function Ml(t) {
            let e;
            if (typeof t == "string") {
                e = Ol[t.toLowerCase()];
                if (!e) {
                    throw new P("keyboard-unknown-key", null, {key: t})
                }
            } else {
                e = t.keyCode + (t.altKey ? Ol.alt : 0) + (t.ctrlKey ? Ol.ctrl : 0) + (t.shiftKey ? Ol.shift : 0) + (t.metaKey ? Ol.cmd : 0)
            }
            return e
        }

        function Hl(t) {
            if (typeof t == "string") {
                t = Kl(t)
            }
            return t.map((t => typeof t == "string" ? $l(t) : t)).reduce(((t, e) => e + t), 0)
        }

        function Wl(t) {
            let e = Hl(t);
            const n = Object.entries(r.isMac ? Fl : Ll);
            const i = n.reduce(((t, [n, i]) => {
                if ((e & Ol[n]) != 0) {
                    e &= ~Ol[n];
                    t += i
                }
                return t
            }), "");
            return i + (e ? Nl[e] : "")
        }

        function ql(t) {
            return t == Ol.arrowright || t == Ol.arrowleft || t == Ol.arrowup || t == Ol.arrowdown
        }

        function jl(t, e) {
            const n = e === "ltr";
            switch (t) {
                case Ol.arrowleft:
                    return n ? "left" : "right";
                case Ol.arrowright:
                    return n ? "right" : "left";
                case Ol.arrowup:
                    return "up";
                case Ol.arrowdown:
                    return "down"
            }
        }

        function $l(t) {
            if (t.endsWith("!")) {
                return Ml(t.slice(0, -1))
            }
            const e = Ml(t);
            return r.isMac && e == Ol.ctrl ? Ol.cmd : e
        }

        function Ul(t, e) {
            const n = jl(t, e);
            return n === "down" || n === "right"
        }

        function Gl() {
            const t = {
                arrowleft: 37,
                arrowup: 38,
                arrowright: 39,
                arrowdown: 40,
                backspace: 8,
                delete: 46,
                enter: 13,
                space: 32,
                esc: 27,
                tab: 9,
                ctrl: 1114112,
                shift: 2228224,
                alt: 4456448,
                cmd: 8912896
            };
            for (let e = 65; e <= 90; e++) {
                const n = String.fromCharCode(e);
                t[n.toLowerCase()] = e
            }
            for (let e = 48; e <= 57; e++) {
                t[e - 48] = e
            }
            for (let e = 112; e <= 123; e++) {
                t["f" + (e - 111)] = e
            }
            for (const e of "`-=[];',./\\") {
                t[e] = e.charCodeAt(0)
            }
            return t
        }

        function Kl(t) {
            return t.split("+").map((t => t.trim()))
        }

        function Zl(t) {
            return Array.isArray(t) ? t : [t]
        }

        if (!Xa.window.CKEDITOR_TRANSLATIONS) {
            Xa.window.CKEDITOR_TRANSLATIONS = {}
        }

        function Jl(t, e, n) {
            if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
                global.window.CKEDITOR_TRANSLATIONS[t] = {}
            }
            const i = global.window.CKEDITOR_TRANSLATIONS[t];
            i.dictionary = i.dictionary || {};
            i.getPluralForm = n || i.getPluralForm;
            Object.assign(i.dictionary, e)
        }

        function Yl(t, e, n = 1) {
            if (typeof n !== "number") {
                throw new P("translation-service-quantity-not-a-number", null, {quantity: n})
            }
            const i = tc();
            if (i === 1) {
                t = Object.keys(Xa.window.CKEDITOR_TRANSLATIONS)[0]
            }
            const o = e.id || e.string;
            if (i === 0 || !Xl(t, o)) {
                if (n !== 1) {
                    return e.plural
                }
                return e.string
            }
            const r = Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary;
            const s = Xa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => t === 1 ? 0 : 1);
            const a = r[o];
            if (typeof a === "string") {
                return a
            }
            const l = Number(s(n));
            return a[l]
        }

        function Ql() {
            global.window.CKEDITOR_TRANSLATIONS = {}
        }

        function Xl(t, e) {
            return !!Xa.window.CKEDITOR_TRANSLATIONS[t] && !!Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        }

        function tc() {
            return Object.keys(Xa.window.CKEDITOR_TRANSLATIONS).length
        }

        const ec = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];

        function nc(t) {
            return ec.includes(t) ? "rtl" : "ltr"
        }

        class ic {
            constructor({uiLanguage: t = "en", contentLanguage: e} = {}) {
                this.uiLanguage = t;
                this.contentLanguage = e || this.uiLanguage;
                this.uiLanguageDirection = nc(this.uiLanguage);
                this.contentLanguageDirection = nc(this.contentLanguage);
                this.t = (t, e) => this._t(t, e)
            }

            get language() {
                console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead.");
                return this.uiLanguage
            }

            _t(t, e = []) {
                e = Zl(e);
                if (typeof t === "string") {
                    t = {string: t}
                }
                const n = !!t.plural;
                const i = n ? e[0] : 1;
                const o = Yl(this.uiLanguage, t, i);
                return oc(o, e)
            }
        }

        function oc(t, e) {
            return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t))
        }

        class rc extends (j()) {
            constructor(t = {}, e = {}) {
                super();
                const n = yt(t);
                if (!n) {
                    e = t
                }
                this._items = [];
                this._itemMap = new Map;
                this._idProperty = e.idProperty || "id";
                this._bindToExternalToInternalMap = new WeakMap;
                this._bindToInternalToExternalMap = new WeakMap;
                this._skippedIndexesFromExternal = [];
                if (n) {
                    for (const e of t) {
                        this._items.push(e);
                        this._itemMap.set(this._getItemIdBeforeAdding(e), e)
                    }
                }
            }

            get length() {
                return this._items.length
            }

            get first() {
                return this._items[0] || null
            }

            get last() {
                return this._items[this.length - 1] || null
            }

            add(t, e) {
                return this.addMany([t], e)
            }

            addMany(t, e) {
                if (e === undefined) {
                    e = this._items.length
                } else if (e > this._items.length || e < 0) {
                    throw new P("collection-add-item-invalid-index", this)
                }
                let n = 0;
                for (const i of t) {
                    const t = this._getItemIdBeforeAdding(i);
                    const o = e + n;
                    this._items.splice(o, 0, i);
                    this._itemMap.set(t, i);
                    this.fire("add", i, o);
                    n++
                }
                this.fire("change", {added: t, removed: [], index: e});
                return this
            }

            get(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else if (typeof t == "number") {
                    e = this._items[t]
                } else {
                    throw new P("collection-get-invalid-arg", this)
                }
                return e || null
            }

            has(t) {
                if (typeof t == "string") {
                    return this._itemMap.has(t)
                } else {
                    const e = this._idProperty;
                    const n = t[e];
                    return n && this._itemMap.has(n)
                }
            }

            getIndex(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else {
                    e = t
                }
                return e ? this._items.indexOf(e) : -1
            }

            remove(t) {
                const [e, n] = this._remove(t);
                this.fire("change", {added: [], removed: [e], index: n});
                return e
            }

            map(t, e) {
                return this._items.map(t, e)
            }

            find(t, e) {
                return this._items.find(t, e)
            }

            filter(t, e) {
                return this._items.filter(t, e)
            }

            clear() {
                if (this._bindToCollection) {
                    this.stopListening(this._bindToCollection);
                    this._bindToCollection = null
                }
                const t = Array.from(this._items);
                while (this.length) {
                    this._remove(0)
                }
                this.fire("change", {added: [], removed: t, index: 0})
            }

            bindTo(t) {
                if (this._bindToCollection) {
                    throw new P("collection-bind-to-rebind", this)
                }
                this._bindToCollection = t;
                return {
                    as: t => {
                        this._setUpBindToBinding((e => new t(e)))
                    }, using: t => {
                        if (typeof t == "function") {
                            this._setUpBindToBinding(t)
                        } else {
                            this._setUpBindToBinding((e => e[t]))
                        }
                    }
                }
            }

            _setUpBindToBinding(t) {
                const e = this._bindToCollection;
                const n = (n, i, o) => {
                    const r = e._bindToCollection == this;
                    const s = e._bindToInternalToExternalMap.get(i);
                    if (r && s) {
                        this._bindToExternalToInternalMap.set(i, s);
                        this._bindToInternalToExternalMap.set(s, i)
                    } else {
                        const n = t(i);
                        if (!n) {
                            this._skippedIndexesFromExternal.push(o);
                            return
                        }
                        let r = o;
                        for (const t of this._skippedIndexesFromExternal) {
                            if (o > t) {
                                r--
                            }
                        }
                        for (const t of e._skippedIndexesFromExternal) {
                            if (r >= t) {
                                r++
                            }
                        }
                        this._bindToExternalToInternalMap.set(i, n);
                        this._bindToInternalToExternalMap.set(n, i);
                        this.add(n, r);
                        for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                            if (r <= e._skippedIndexesFromExternal[t]) {
                                e._skippedIndexesFromExternal[t]++
                            }
                        }
                    }
                };
                for (const t of e) {
                    n(null, t, e.getIndex(t))
                }
                this.listenTo(e, "add", n);
                this.listenTo(e, "remove", ((t, e, n) => {
                    const i = this._bindToExternalToInternalMap.get(e);
                    if (i) {
                        this.remove(i)
                    }
                    this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => {
                        if (n < e) {
                            t.push(e - 1)
                        }
                        if (n > e) {
                            t.push(e)
                        }
                        return t
                    }), [])
                }))
            }

            _getItemIdBeforeAdding(t) {
                const e = this._idProperty;
                let n;
                if (e in t) {
                    n = t[e];
                    if (typeof n != "string") {
                        throw new P("collection-add-invalid-id", this)
                    }
                    if (this.get(n)) {
                        throw new P("collection-add-item-already-exists", this)
                    }
                } else {
                    t[e] = n = E()
                }
                return n
            }

            _remove(t) {
                let e, n, i;
                let o = false;
                const r = this._idProperty;
                if (typeof t == "string") {
                    n = t;
                    i = this._itemMap.get(n);
                    o = !i;
                    if (i) {
                        e = this._items.indexOf(i)
                    }
                } else if (typeof t == "number") {
                    e = t;
                    i = this._items[e];
                    o = !i;
                    if (i) {
                        n = i[r]
                    }
                } else {
                    i = t;
                    n = i[r];
                    e = this._items.indexOf(i);
                    o = e == -1 || !this._itemMap.get(n)
                }
                if (o) {
                    throw new P("collection-remove-404", this)
                }
                this._items.splice(e, 1);
                this._itemMap.delete(n);
                const s = this._bindToInternalToExternalMap.get(i);
                this._bindToInternalToExternalMap.delete(i);
                this._bindToExternalToInternalMap.delete(s);
                this.fire("remove", i, e);
                return [i, e]
            }

            [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
        }

        function sc(t) {
            const e = t.next();
            if (e.done) {
                return null
            }
            return e.value
        }

        class ac extends (Ka(dt())) {
            constructor() {
                super();
                this._elements = new Set;
                this._nextEventLoopTimeout = null;
                this.set("isFocused", false);
                this.set("focusedElement", null)
            }

            add(t) {
                if (this._elements.has(t)) {
                    throw new P("focustracker-add-element-already-exist", this)
                }
                this.listenTo(t, "focus", (() => this._focus(t)), {useCapture: true});
                this.listenTo(t, "blur", (() => this._blur()), {useCapture: true});
                this._elements.add(t)
            }

            remove(t) {
                if (t === this.focusedElement) {
                    this._blur()
                }
                if (this._elements.has(t)) {
                    this.stopListening(t);
                    this._elements.delete(t)
                }
            }

            destroy() {
                this.stopListening()
            }

            _focus(t) {
                clearTimeout(this._nextEventLoopTimeout);
                this.focusedElement = t;
                this.isFocused = true
            }

            _blur() {
                clearTimeout(this._nextEventLoopTimeout);
                this._nextEventLoopTimeout = setTimeout((() => {
                    this.focusedElement = null;
                    this.isFocused = false
                }), 0)
            }
        }

        class lc {
            constructor() {
                this._listener = new (Ka())
            }

            listenTo(t) {
                this._listener.listenTo(t, "keydown", ((t, e) => {
                    this._listener.fire("_keydown:" + Ml(e), e)
                }))
            }

            set(t, e, n = {}) {
                const i = Hl(t);
                const o = n.priority;
                this._listener.listenTo(this._listener, "_keydown:" + i, ((t, n) => {
                    e(n, (() => {
                        n.preventDefault();
                        n.stopPropagation();
                        t.stop()
                    }));
                    t.return = true
                }), {priority: o})
            }

            press(t) {
                return !!this._listener.fire("_keydown:" + Ml(t), t)
            }

            destroy() {
                this._listener.stopListening()
            }
        }

        function cc(t) {
            const e = new Map;
            for (const n in t) {
                e.set(n, t[n])
            }
            return e
        }

        function dc(t) {
            if (yt(t)) {
                return new Map(t)
            } else {
                return cc(t)
            }
        }

        const uc = 1e4;

        function hc(t, e, n, i) {
            if (Math.max(e.length, t.length) > uc) {
                return t.slice(0, n).concat(e).concat(t.slice(n + i, t.length))
            } else {
                const o = Array.from(t);
                o.splice(n, i, ...e);
                return o
            }
        }

        function fc(t) {
            return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
        }

        function gc(t) {
            return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
        }

        function mc(t) {
            return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
        }

        function pc(t, e) {
            return gc(t.charAt(e - 1)) && mc(t.charAt(e))
        }

        function bc(t, e) {
            return fc(t.charAt(e))
        }

        const kc = _c();

        function wc(t, e) {
            const n = String(t).matchAll(kc);
            return Array.from(n).some((t => t.index < e && e < t.index + t[0].length))
        }

        function _c() {
            const t = [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u];
            const e = /\p{Regional_Indicator}{2}/u.source;
            const n = "(?:" + t.map((t => t.source)).join("|") + ")";
            const i = `${e}|${n}(?:‍${n})*`;
            return new RegExp(i, "ug")
        }

        class Ac extends (dt()) {
            constructor(t) {
                super();
                this.editor = t;
                this.set("isEnabled", true);
                this._disableStack = new Set
            }

            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", Cc, {priority: "highest"});
                    this.isEnabled = false
                }
            }

            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", Cc);
                    this.isEnabled = true
                }
            }

            destroy() {
                this.stopListening()
            }

            static get isContextPlugin() {
                return false
            }
        }

        function Cc(t) {
            t.return = false;
            t.stop()
        }

        class vc extends (dt()) {
            constructor(t) {
                super();
                this.editor = t;
                this.set("value", undefined);
                this.set("isEnabled", false);
                this._affectsData = true;
                this._disableStack = new Set;
                this.decorate("execute");
                this.listenTo(this.editor.model.document, "change", (() => {
                    this.refresh()
                }));
                this.on("execute", (t => {
                    if (!this.isEnabled) {
                        t.stop()
                    }
                }), {priority: "high"});
                this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                    if (n && this.affectsData) {
                        this.forceDisabled("readOnlyMode")
                    } else {
                        this.clearForceDisabled("readOnlyMode")
                    }
                }))
            }

            get affectsData() {
                return this._affectsData
            }

            set affectsData(t) {
                this._affectsData = t
            }

            refresh() {
                this.isEnabled = true
            }

            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", yc, {priority: "highest"});
                    this.isEnabled = false
                }
            }

            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", yc);
                    this.refresh()
                }
            }

            execute(...t) {
                return undefined
            }

            destroy() {
                this.stopListening()
            }
        }

        function yc(t) {
            t.return = false;
            t.stop()
        }

        class xc extends vc {
            constructor(t) {
                super(t);
                this._childCommandsDefinitions = []
            }

            refresh() {
            }

            execute(...t) {
                const e = this._getFirstEnabledCommand();
                return !!e && e.execute(t)
            }

            registerChildCommand(t, e = {}) {
                T(this._childCommandsDefinitions, {command: t, priority: e.priority || "normal"});
                t.on("change:isEnabled", (() => this._checkEnabled()));
                this._checkEnabled()
            }

            _checkEnabled() {
                this.isEnabled = !!this._getFirstEnabledCommand()
            }

            _getFirstEnabledCommand() {
                const t = this._childCommandsDefinitions.find((({command: t}) => t.isEnabled));
                return t && t.command
            }
        }

        class Ec extends (j()) {
            constructor(t, e = [], n = []) {
                super();
                this._context = t;
                this._plugins = new Map;
                this._availablePlugins = new Map;
                for (const t of e) {
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
                this._contextPlugins = new Map;
                for (const [t, e] of n) {
                    this._contextPlugins.set(t, e);
                    this._contextPlugins.set(e, t);
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
            }

            * [Symbol.iterator]() {
                for (const t of this._plugins) {
                    if (typeof t[0] == "function") {
                        yield t
                    }
                }
            }

            get(t) {
                const e = this._plugins.get(t);
                if (!e) {
                    let e = t;
                    if (typeof t == "function") {
                        e = t.pluginName || t.name
                    }
                    throw new P("plugincollection-plugin-not-loaded", this._context, {plugin: e})
                }
                return e
            }

            has(t) {
                return this._plugins.has(t)
            }

            init(t, e = [], n = []) {
                const i = this;
                const o = this._context;
                h(t);
                g(t);
                const r = t.filter((t => !d(t, e)));
                const s = [...f(r)];
                _(s, n);
                const a = k(s);
                return w(a, "init").then((() => w(a, "afterInit"))).then((() => a));

                function l(t) {
                    return typeof t === "function"
                }

                function c(t) {
                    return l(t) && t.isContextPlugin
                }

                function d(t, e) {
                    return e.some((e => {
                        if (e === t) {
                            return true
                        }
                        if (u(t) === e) {
                            return true
                        }
                        if (u(e) === t) {
                            return true
                        }
                        return false
                    }))
                }

                function u(t) {
                    return l(t) ? t.pluginName || t.name : t
                }

                function h(t, e = new Set) {
                    t.forEach((t => {
                        if (!l(t)) {
                            return
                        }
                        if (e.has(t)) {
                            return
                        }
                        e.add(t);
                        if (t.pluginName && !i._availablePlugins.has(t.pluginName)) {
                            i._availablePlugins.set(t.pluginName, t)
                        }
                        if (t.requires) {
                            h(t.requires, e)
                        }
                    }))
                }

                function f(t, e = new Set) {
                    return t.map((t => l(t) ? t : i._availablePlugins.get(t))).reduce(((t, n) => {
                        if (e.has(n)) {
                            return t
                        }
                        e.add(n);
                        if (n.requires) {
                            g(n.requires, n);
                            f(n.requires, e).forEach((e => t.add(e)))
                        }
                        return t.add(n)
                    }), new Set)
                }

                function g(t, e = null) {
                    t.map((t => l(t) ? t : i._availablePlugins.get(t) || t)).forEach((t => {
                        m(t, e);
                        p(t, e);
                        b(t, e)
                    }))
                }

                function m(t, e) {
                    if (l(t)) {
                        return
                    }
                    if (e) {
                        throw new P("plugincollection-soft-required", o, {missingPlugin: t, requiredBy: u(e)})
                    }
                    throw new P("plugincollection-plugin-not-found", o, {plugin: t})
                }

                function p(t, e) {
                    if (!c(e)) {
                        return
                    }
                    if (c(t)) {
                        return
                    }
                    throw new P("plugincollection-context-required", o, {plugin: u(t), requiredBy: u(e)})
                }

                function b(t, n) {
                    if (!n) {
                        return
                    }
                    if (!d(t, e)) {
                        return
                    }
                    throw new P("plugincollection-required", o, {plugin: u(t), requiredBy: u(n)})
                }

                function k(t) {
                    return t.map((t => {
                        let e = i._contextPlugins.get(t);
                        e = e || new t(o);
                        i._add(t, e);
                        return e
                    }))
                }

                function w(t, e) {
                    return t.reduce(((t, n) => {
                        if (!n[e]) {
                            return t
                        }
                        if (i._contextPlugins.has(n)) {
                            return t
                        }
                        return t.then(n[e].bind(n))
                    }), Promise.resolve())
                }

                function _(t, e) {
                    for (const n of e) {
                        if (typeof n != "function") {
                            throw new P("plugincollection-replace-plugin-invalid-type", null, {pluginItem: n})
                        }
                        const e = n.pluginName;
                        if (!e) {
                            throw new P("plugincollection-replace-plugin-missing-name", null, {pluginItem: n})
                        }
                        if (n.requires && n.requires.length) {
                            throw new P("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {pluginName: e})
                        }
                        const o = i._availablePlugins.get(e);
                        if (!o) {
                            throw new P("plugincollection-plugin-for-replacing-not-exist", null, {pluginName: e})
                        }
                        const r = t.indexOf(o);
                        if (r === -1) {
                            if (i._contextPlugins.has(o)) {
                                return
                            }
                            throw new P("plugincollection-plugin-for-replacing-not-loaded", null, {pluginName: e})
                        }
                        if (o.requires && o.requires.length) {
                            throw new P("plugincollection-replaced-plugin-cannot-have-dependencies", null, {pluginName: e})
                        }
                        t.splice(r, 1, n);
                        i._availablePlugins.set(e, n)
                    }
                }
            }

            destroy() {
                const t = [];
                for (const [, e] of this) {
                    if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
                        t.push(e.destroy())
                    }
                }
                return Promise.all(t)
            }

            _add(t, e) {
                this._plugins.set(t, e);
                const n = t.pluginName;
                if (!n) {
                    return
                }
                if (this._plugins.has(n)) {
                    throw new P("plugincollection-plugin-name-conflict", null, {
                        pluginName: n,
                        plugin1: this._plugins.get(n).constructor,
                        plugin2: t
                    })
                }
                this._plugins.set(n, e)
            }
        }

        class Sc {
            constructor(t) {
                this.config = new Wa(t, this.constructor.defaultConfig);
                const e = this.constructor.builtinPlugins;
                this.config.define("plugins", e);
                this.plugins = new Ec(this, e);
                const n = this.config.get("language") || {};
                this.locale = new ic({
                    uiLanguage: typeof n === "string" ? n : n.ui,
                    contentLanguage: this.config.get("language.content")
                });
                this.t = this.locale.t;
                this.editors = new rc;
                this._contextOwner = null
            }

            initPlugins() {
                const t = this.config.get("plugins") || [];
                const e = this.config.get("substitutePlugins") || [];
                for (const n of t.concat(e)) {
                    if (typeof n != "function") {
                        throw new P("context-initplugins-constructor-only", null, {Plugin: n})
                    }
                    if (n.isContextPlugin !== true) {
                        throw new P("context-initplugins-invalid-plugin", null, {Plugin: n})
                    }
                }
                return this.plugins.init(t, [], e)
            }

            destroy() {
                return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy()))
            }

            _addEditor(t, e) {
                if (this._contextOwner) {
                    throw new P("context-addeditor-private-context")
                }
                this.editors.add(t);
                if (e) {
                    this._contextOwner = t
                }
            }

            _removeEditor(t) {
                if (this.editors.has(t)) {
                    this.editors.remove(t)
                }
                if (this._contextOwner === t) {
                    return this.destroy()
                }
                return Promise.resolve()
            }

            _getEditorConfig() {
                const t = {};
                for (const e of this.config.names()) {
                    if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
                        t[e] = this.config.get(e)
                    }
                }
                return t
            }

            static create(t) {
                return new Promise((e => {
                    const n = new this(t);
                    e(n.initPlugins().then((() => n)))
                }))
            }
        }

        class Dc extends (dt()) {
            constructor(t) {
                super();
                this.context = t
            }

            destroy() {
                this.stopListening()
            }

            static get isContextPlugin() {
                return true
            }
        }

        var Tc = n(3379);
        var Bc = n.n(Tc);
        var Pc = n(8894);
        var Ic = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Ic.insert = "head";
        Ic.singleton = true;
        var Rc = Bc()(Pc.Z, Ic);
        const zc = Pc.Z.locals || {};
        const Vc = new WeakMap;

        function Fc(t) {
            const {view: e, element: n, text: i, isDirectHost: o = true, keepOnFocus: r = false} = t;
            const s = e.document;
            if (!Vc.has(s)) {
                Vc.set(s, new Map);
                s.registerPostFixer((t => Hc(s, t)));
                s.on("change:isComposing", (() => {
                    e.change((t => Hc(s, t)))
                }), {priority: "high"})
            }
            Vc.get(s).set(n, {text: i, isDirectHost: o, keepOnFocus: r, hostElement: o ? n : null});
            e.change((t => Hc(s, t)))
        }

        function Lc(t, e) {
            const n = e.document;
            t.change((t => {
                if (!Vc.has(n)) {
                    return
                }
                const i = Vc.get(n);
                const o = i.get(e);
                t.removeAttribute("data-placeholder", o.hostElement);
                Nc(t, o.hostElement);
                i.delete(e)
            }))
        }

        function Oc(t, e) {
            if (!e.hasClass("ck-placeholder")) {
                t.addClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function Nc(t, e) {
            if (e.hasClass("ck-placeholder")) {
                t.removeClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function Mc(t, e) {
            if (!t.isAttached()) {
                return false
            }
            const n = Array.from(t.getChildren()).some((t => !t.is("uiElement")));
            if (n) {
                return false
            }
            const i = t.document;
            const o = i.selection;
            const r = o.anchor;
            if (i.isComposing && r && r.parent === t) {
                return false
            }
            if (e) {
                return true
            }
            if (!i.isFocused) {
                return true
            }
            return !!r && r.parent !== t
        }

        function Hc(t, e) {
            const n = Vc.get(t);
            const i = [];
            let o = false;
            for (const [t, r] of n) {
                if (r.isDirectHost) {
                    i.push(t);
                    if (Wc(e, t, r)) {
                        o = true
                    }
                }
            }
            for (const [t, r] of n) {
                if (r.isDirectHost) {
                    continue
                }
                const n = qc(t);
                if (!n) {
                    continue
                }
                if (i.includes(n)) {
                    continue
                }
                r.hostElement = n;
                if (Wc(e, t, r)) {
                    o = true
                }
            }
            return o
        }

        function Wc(t, e, n) {
            const {text: i, isDirectHost: o, hostElement: r} = n;
            let s = false;
            if (r.getAttribute("data-placeholder") !== i) {
                t.setAttribute("data-placeholder", i, r);
                s = true
            }
            const a = o || e.childCount == 1;
            if (a && Mc(r, n.keepOnFocus)) {
                if (Oc(t, r)) {
                    s = true
                }
            } else if (Nc(t, r)) {
                s = true
            }
            return s
        }

        function qc(t) {
            if (t.childCount) {
                const e = t.getChild(0);
                if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) {
                    return e
                }
            }
            return null
        }

        class jc {
            is() {
                throw new Error("is() method is abstract")
            }
        }

        var $c = 4;

        function Uc(t) {
            return Va(t, $c)
        }

        const Gc = Uc;

        class Kc extends (j(jc)) {
            constructor(t) {
                super();
                this.document = t;
                this.parent = null
            }

            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) == -1) {
                    throw new P("view-node-not-found-in-parent", this)
                }
                return t
            }

            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }

            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }

            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }

            isAttached() {
                return this.root.is("rootElement")
            }

            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.index);
                    e = e.parent
                }
                return t
            }

            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const i = t.getAncestors(e);
                let o = 0;
                while (n[o] == i[o] && n[o]) {
                    o++
                }
                return o === 0 ? null : n[o - 1]
            }

            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const i = vt(e, n);
                switch (i) {
                    case"prefix":
                        return true;
                    case"extension":
                        return false;
                    default:
                        return e[i] < n[i]
                }
            }

            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }

            _remove() {
                this.parent._removeChildren(this.index)
            }

            _fireChange(t, e) {
                this.fire(`change:${t}`, e);
                if (this.parent) {
                    this.parent._fireChange(t, e)
                }
            }

            toJSON() {
                const t = Gc(this);
                delete t.parent;
                return t
            }
        }

        Kc.prototype.is = function (t) {
            return t === "node" || t === "view:node"
        };

        class Zc extends Kc {
            constructor(t, e) {
                super(t);
                this._textData = e
            }

            get data() {
                return this._textData
            }

            get _data() {
                return this.data
            }

            set _data(t) {
                this._fireChange("text", this);
                this._textData = t
            }

            isSimilar(t) {
                if (!(t instanceof Zc)) {
                    return false
                }
                return this === t || this.data === t.data
            }

            _clone() {
                return new Zc(this.document, this.data)
            }
        }

        Zc.prototype.is = function (t) {
            return t === "$text" || t === "view:$text" || t === "text" || t === "view:text" || t === "node" || t === "view:node"
        };

        class Jc extends jc {
            constructor(t, e, n) {
                super();
                this.textNode = t;
                if (e < 0 || e > t.data.length) {
                    throw new P("view-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.data.length) {
                    throw new P("view-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }

            get offsetSize() {
                return this.data.length
            }

            get isPartial() {
                return this.data.length !== this.textNode.data.length
            }

            get parent() {
                return this.textNode.parent
            }

            get root() {
                return this.textNode.root
            }

            get document() {
                return this.textNode.document
            }

            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this.textNode : this.parent;
                while (n !== null) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
        }

        Jc.prototype.is = function (t) {
            return t === "$textProxy" || t === "view:$textProxy" || t === "textProxy" || t === "view:textProxy"
        };

        class Yc {
            constructor(...t) {
                this._patterns = [];
                this.add(...t)
            }

            add(...t) {
                for (let e of t) {
                    if (typeof e == "string" || e instanceof RegExp) {
                        e = {name: e}
                    }
                    this._patterns.push(e)
                }
            }

            match(...t) {
                for (const e of t) {
                    for (const t of this._patterns) {
                        const n = Qc(e, t);
                        if (n) {
                            return {element: e, pattern: t, match: n}
                        }
                    }
                }
                return null
            }

            matchAll(...t) {
                const e = [];
                for (const n of t) {
                    for (const t of this._patterns) {
                        const i = Qc(n, t);
                        if (i) {
                            e.push({element: n, pattern: t, match: i})
                        }
                    }
                }
                return e.length > 0 ? e : null
            }

            getElementName() {
                if (this._patterns.length !== 1) {
                    return null
                }
                const t = this._patterns[0];
                const e = t.name;
                return typeof t != "function" && e && !(e instanceof RegExp) ? e : null
            }
        }

        function Qc(t, e) {
            if (typeof e == "function") {
                return e(t)
            }
            const n = {};
            if (e.name) {
                n.name = Xc(e.name, t.name);
                if (!n.name) {
                    return null
                }
            }
            if (e.attributes) {
                n.attributes = od(e.attributes, t);
                if (!n.attributes) {
                    return null
                }
            }
            if (e.classes) {
                n.classes = rd(e.classes, t);
                if (!n.classes) {
                    return null
                }
            }
            if (e.styles) {
                n.styles = sd(e.styles, t);
                if (!n.styles) {
                    return null
                }
            }
            return n
        }

        function Xc(t, e) {
            if (t instanceof RegExp) {
                return !!e.match(t)
            }
            return t === e
        }

        function td(t, e, n) {
            const i = ed(t);
            const o = Array.from(e);
            const r = [];
            i.forEach((([t, e]) => {
                o.forEach((i => {
                    if (nd(t, i) && id(e, i, n)) {
                        r.push(i)
                    }
                }))
            }));
            if (!i.length || r.length < i.length) {
                return undefined
            }
            return r
        }

        function ed(t) {
            if (Array.isArray(t)) {
                return t.map((t => {
                    if (he(t)) {
                        if (t.key === undefined || t.value === undefined) {
                            I("matcher-pattern-missing-key-or-value", t)
                        }
                        return [t.key, t.value]
                    }
                    return [t, true]
                }))
            }
            if (he(t)) {
                return Object.entries(t)
            }
            return [[t, true]]
        }

        function nd(t, e) {
            return t === true || t === e || t instanceof RegExp && e.match(t)
        }

        function id(t, e, n) {
            if (t === true) {
                return true
            }
            const i = n(e);
            return t === i || t instanceof RegExp && !!String(i).match(t)
        }

        function od(t, e) {
            const n = new Set(e.getAttributeKeys());
            if (he(t)) {
                if (t.style !== undefined) {
                    I("matcher-pattern-deprecated-attributes-style-key", t)
                }
                if (t.class !== undefined) {
                    I("matcher-pattern-deprecated-attributes-class-key", t)
                }
            } else {
                n.delete("style");
                n.delete("class")
            }
            return td(t, n, (t => e.getAttribute(t)))
        }

        function rd(t, e) {
            return td(t, e.getClassNames(), (() => {
            }))
        }

        function sd(t, e) {
            return td(t, e.getStyleNames(true), (t => e.getStyle(t)))
        }

        var ad = "[object Symbol]";

        function ld(t) {
            return typeof t == "symbol" || Jt(t) && Ut(t) == ad
        }

        const cd = ld;
        var dd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ud = /^\w*$/;

        function hd(t, e) {
            if (Kt(t)) {
                return false
            }
            var n = typeof t;
            if (n == "number" || n == "symbol" || n == "boolean" || t == null || cd(t)) {
                return true
            }
            return ud.test(t) || !dd.test(t) || e != null && t in Object(e)
        }

        const fd = hd;
        var gd = "Expected a function";

        function md(t, e) {
            if (typeof t != "function" || e != null && typeof e != "function") {
                throw new TypeError(gd)
            }
            var n = function () {
                var i = arguments, o = e ? e.apply(this, i) : i[0], r = n.cache;
                if (r.has(o)) {
                    return r.get(o)
                }
                var s = t.apply(this, i);
                n.cache = r.set(o, s) || r;
                return s
            };
            n.cache = new (md.Cache || Yn);
            return n
        }

        md.Cache = Yn;
        const pd = md;
        var bd = 500;

        function kd(t) {
            var e = pd(t, (function (t) {
                if (n.size === bd) {
                    n.clear()
                }
                return t
            }));
            var n = e.cache;
            return e
        }

        const wd = kd;
        var _d = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var Ad = /\\(\\)?/g;
        var Cd = wd((function (t) {
            var e = [];
            if (t.charCodeAt(0) === 46) {
                e.push("")
            }
            t.replace(_d, (function (t, n, i, o) {
                e.push(i ? o.replace(Ad, "$1") : n || t)
            }));
            return e
        }));
        const vd = Cd;

        function yd(t, e) {
            var n = -1, i = t == null ? 0 : t.length, o = Array(i);
            while (++n < i) {
                o[n] = e(t[n], n, t)
            }
            return o
        }

        const xd = yd;
        var Ed = 1 / 0;
        var Sd = Pt ? Pt.prototype : undefined, Dd = Sd ? Sd.toString : undefined;

        function Td(t) {
            if (typeof t == "string") {
                return t
            }
            if (Kt(t)) {
                return xd(t, Td) + ""
            }
            if (cd(t)) {
                return Dd ? Dd.call(t) : ""
            }
            var e = t + "";
            return e == "0" && 1 / t == -Ed ? "-0" : e
        }

        const Bd = Td;

        function Pd(t) {
            return t == null ? "" : Bd(t)
        }

        const Id = Pd;

        function Rd(t, e) {
            if (Kt(t)) {
                return t
            }
            return fd(t, e) ? [t] : vd(Id(t))
        }

        const zd = Rd;

        function Vd(t) {
            var e = t == null ? 0 : t.length;
            return e ? t[e - 1] : undefined
        }

        const Fd = Vd;
        var Ld = 1 / 0;

        function Od(t) {
            if (typeof t == "string" || cd(t)) {
                return t
            }
            var e = t + "";
            return e == "0" && 1 / t == -Ld ? "-0" : e
        }

        const Nd = Od;

        function Md(t, e) {
            e = zd(e, t);
            var n = 0, i = e.length;
            while (t != null && n < i) {
                t = t[Nd(e[n++])]
            }
            return n && n == i ? t : undefined
        }

        const Hd = Md;

        function Wd(t, e, n) {
            var i = -1, o = t.length;
            if (e < 0) {
                e = -e > o ? 0 : o + e
            }
            n = n > o ? o : n;
            if (n < 0) {
                n += o
            }
            o = e > n ? 0 : n - e >>> 0;
            e >>>= 0;
            var r = Array(o);
            while (++i < o) {
                r[i] = t[i + e]
            }
            return r
        }

        const qd = Wd;

        function jd(t, e) {
            return e.length < 2 ? t : Hd(t, qd(e, 0, -1))
        }

        const $d = jd;

        function Ud(t, e) {
            e = zd(e, t);
            t = $d(t, e);
            return t == null || delete t[Nd(Fd(e))]
        }

        const Gd = Ud;

        function Kd(t, e) {
            return t == null ? true : Gd(t, e)
        }

        const Zd = Kd;

        function Jd(t, e, n) {
            var i = t == null ? undefined : Hd(t, e);
            return i === undefined ? n : i
        }

        const Yd = Jd;

        function Qd(t, e, n) {
            if (n !== undefined && !pe(t[e], n) || n === undefined && !(e in t)) {
                li(t, e, n)
            }
        }

        const Xd = Qd;

        function tu(t) {
            return function (e, n, i) {
                var o = -1, r = Object(e), s = i(e), a = s.length;
                while (a--) {
                    var l = s[t ? a : ++o];
                    if (n(r[l], l, r) === false) {
                        break
                    }
                }
                return e
            }
        }

        const eu = tu;
        var nu = eu();
        const iu = nu;

        function ou(t) {
            return Jt(t) && Mo(t)
        }

        const ru = ou;

        function su(t, e) {
            if (e === "constructor" && typeof t[e] === "function") {
                return
            }
            if (e == "__proto__") {
                return
            }
            return t[e]
        }

        const au = su;

        function lu(t) {
            return gi(t, Qo(t))
        }

        const cu = lu;

        function du(t, e, n, i, o, r, s) {
            var a = au(t, n), l = au(e, n), c = s.get(l);
            if (c) {
                Xd(t, n, c);
                return
            }
            var d = r ? r(a, l, n + "", t, e, s) : undefined;
            var u = d === undefined;
            if (u) {
                var h = Kt(l), f = !h && Ri(l), g = !h && !f && xo(l);
                d = l;
                if (h || f || g) {
                    if (Kt(a)) {
                        d = a
                    } else if (ru(a)) {
                        d = cr(a)
                    } else if (f) {
                        u = false;
                        d = ar(l, true)
                    } else if (g) {
                        u = false;
                        d = ws(l, true)
                    } else {
                        d = []
                    }
                } else if (he(l) || yi(l)) {
                    d = a;
                    if (yi(a)) {
                        d = cu(a)
                    } else if (!it(a) || je(a)) {
                        d = $s(l)
                    }
                } else {
                    u = false
                }
            }
            if (u) {
                s.set(l, d);
                o(d, l, i, r, s);
                s["delete"](l)
            }
            Xd(t, n, d)
        }

        const uu = du;

        function hu(t, e, n, i, o) {
            if (t === e) {
                return
            }
            iu(e, (function (r, s) {
                o || (o = new ni);
                if (it(r)) {
                    uu(t, e, s, n, hu, i, o)
                } else {
                    var a = i ? i(au(t, s), r, s + "", t, e, o) : undefined;
                    if (a === undefined) {
                        a = r
                    }
                    Xd(t, s, a)
                }
            }), Qo)
        }

        const fu = hu;

        function gu(t) {
            return t
        }

        const mu = gu;

        function pu(t, e, n) {
            switch (n.length) {
                case 0:
                    return t.call(e);
                case 1:
                    return t.call(e, n[0]);
                case 2:
                    return t.call(e, n[0], n[1]);
                case 3:
                    return t.call(e, n[0], n[1], n[2])
            }
            return t.apply(e, n)
        }

        const bu = pu;
        var ku = Math.max;

        function wu(t, e, n) {
            e = ku(e === undefined ? t.length - 1 : e, 0);
            return function () {
                var i = arguments, o = -1, r = ku(i.length - e, 0), s = Array(r);
                while (++o < r) {
                    s[o] = i[e + o]
                }
                o = -1;
                var a = Array(e + 1);
                while (++o < e) {
                    a[o] = i[o]
                }
                a[e] = n(s);
                return bu(t, this, a)
            }
        }

        const _u = wu;

        function Au(t) {
            return function () {
                return t
            }
        }

        const Cu = Au;
        var vu = !si ? mu : function (t, e) {
            return si(t, "toString", {configurable: true, enumerable: false, value: Cu(e), writable: true})
        };
        const yu = vu;
        var xu = 800, Eu = 16;
        var Su = Date.now;

        function Du(t) {
            var e = 0, n = 0;
            return function () {
                var i = Su(), o = Eu - (i - n);
                n = i;
                if (o > 0) {
                    if (++e >= xu) {
                        return arguments[0]
                    }
                } else {
                    e = 0
                }
                return t.apply(undefined, arguments)
            }
        }

        const Tu = Du;
        var Bu = Tu(yu);
        const Pu = Bu;

        function Iu(t, e) {
            return Pu(_u(t, e, mu), t + "")
        }

        const Ru = Iu;

        function zu(t, e, n) {
            if (!it(n)) {
                return false
            }
            var i = typeof e;
            if (i == "number" ? Mo(n) && Li(e, n.length) : i == "string" && e in n) {
                return pe(n[e], t)
            }
            return false
        }

        const Vu = zu;

        function Fu(t) {
            return Ru((function (e, n) {
                var i = -1, o = n.length, r = o > 1 ? n[o - 1] : undefined, s = o > 2 ? n[2] : undefined;
                r = t.length > 3 && typeof r == "function" ? (o--, r) : undefined;
                if (s && Vu(n[0], n[1], s)) {
                    r = o < 3 ? undefined : r;
                    o = 1
                }
                e = Object(e);
                while (++i < o) {
                    var a = n[i];
                    if (a) {
                        t(e, a, i, r)
                    }
                }
                return e
            }))
        }

        const Lu = Fu;
        var Ou = Lu((function (t, e, n) {
            fu(t, e, n)
        }));
        const Nu = Ou;

        function Mu(t, e, n, i) {
            if (!it(t)) {
                return t
            }
            e = zd(e, t);
            var o = -1, r = e.length, s = r - 1, a = t;
            while (a != null && ++o < r) {
                var l = Nd(e[o]), c = n;
                if (l === "__proto__" || l === "constructor" || l === "prototype") {
                    return t
                }
                if (o != s) {
                    var d = a[l];
                    c = i ? i(d, l, a) : undefined;
                    if (c === undefined) {
                        c = it(d) ? d : Li(e[o + 1]) ? [] : {}
                    }
                }
                hi(a, l, c);
                a = a[l]
            }
            return t
        }

        const Hu = Mu;

        function Wu(t, e, n) {
            return t == null ? t : Hu(t, e, n)
        }

        const qu = Wu;

        class ju {
            constructor(t) {
                this._styles = {};
                this._styleProcessor = t
            }

            get isEmpty() {
                const t = Object.entries(this._styles);
                const e = Array.from(t);
                return !e.length
            }

            get size() {
                if (this.isEmpty) {
                    return 0
                }
                return this.getStyleNames().length
            }

            setTo(t) {
                this.clear();
                const e = Array.from(Uu(t).entries());
                for (const [t, n] of e) {
                    this._styleProcessor.toNormalizedForm(t, n, this._styles)
                }
            }

            has(t) {
                if (this.isEmpty) {
                    return false
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                return Array.isArray(n)
            }

            set(t, e) {
                if (it(t)) {
                    for (const [e, n] of Object.entries(t)) {
                        this._styleProcessor.toNormalizedForm(e, n, this._styles)
                    }
                } else {
                    this._styleProcessor.toNormalizedForm(t, e, this._styles)
                }
            }

            remove(t) {
                const e = Gu(t);
                Zd(this._styles, e);
                delete this._styles[t];
                this._cleanEmptyObjectsOnPath(e)
            }

            getNormalized(t) {
                return this._styleProcessor.getNormalized(t, this._styles)
            }

            toString() {
                if (this.isEmpty) {
                    return ""
                }
                return this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";"
            }

            getAsString(t) {
                if (this.isEmpty) {
                    return
                }
                if (this._styles[t] && !it(this._styles[t])) {
                    return this._styles[t]
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                if (Array.isArray(n)) {
                    return n[1]
                }
            }

            getStyleNames(t = false) {
                if (this.isEmpty) {
                    return []
                }
                if (t) {
                    return this._styleProcessor.getStyleNames(this._styles)
                }
                const e = this._getStylesEntries();
                return e.map((([t]) => t))
            }

            clear() {
                this._styles = {}
            }

            _getStylesEntries() {
                const t = [];
                const e = Object.keys(this._styles);
                for (const n of e) {
                    t.push(...this._styleProcessor.getReducedForm(n, this._styles))
                }
                return t
            }

            _cleanEmptyObjectsOnPath(t) {
                const e = t.split(".");
                const n = e.length > 1;
                if (!n) {
                    return
                }
                const i = e.splice(0, e.length - 1).join(".");
                const o = Yd(this._styles, i);
                if (!o) {
                    return
                }
                const r = !Array.from(Object.keys(o)).length;
                if (r) {
                    this.remove(i)
                }
            }
        }

        class $u {
            constructor() {
                this._normalizers = new Map;
                this._extractors = new Map;
                this._reducers = new Map;
                this._consumables = new Map
            }

            toNormalizedForm(t, e, n) {
                if (it(e)) {
                    Ku(n, Gu(t), e);
                    return
                }
                if (this._normalizers.has(t)) {
                    const i = this._normalizers.get(t);
                    const {path: o, value: r} = i(e);
                    Ku(n, o, r)
                } else {
                    Ku(n, t, e)
                }
            }

            getNormalized(t, e) {
                if (!t) {
                    return Nu({}, e)
                }
                if (e[t] !== undefined) {
                    return e[t]
                }
                if (this._extractors.has(t)) {
                    const n = this._extractors.get(t);
                    if (typeof n === "string") {
                        return Yd(e, n)
                    }
                    const i = n(t, e);
                    if (i) {
                        return i
                    }
                }
                return Yd(e, Gu(t))
            }

            getReducedForm(t, e) {
                const n = this.getNormalized(t, e);
                if (n === undefined) {
                    return []
                }
                if (this._reducers.has(t)) {
                    const e = this._reducers.get(t);
                    return e(n)
                }
                return [[t, n]]
            }

            getStyleNames(t) {
                const e = Array.from(this._consumables.keys()).filter((e => {
                    const n = this.getNormalized(e, t);
                    if (n && typeof n == "object") {
                        return Object.keys(n).length
                    }
                    return n
                }));
                const n = new Set([...e, ...Object.keys(t)]);
                return Array.from(n.values())
            }

            getRelatedStyles(t) {
                return this._consumables.get(t) || []
            }

            setNormalizer(t, e) {
                this._normalizers.set(t, e)
            }

            setExtractor(t, e) {
                this._extractors.set(t, e)
            }

            setReducer(t, e) {
                this._reducers.set(t, e)
            }

            setStyleRelation(t, e) {
                this._mapStyleNames(t, e);
                for (const n of e) {
                    this._mapStyleNames(n, [t])
                }
            }

            _mapStyleNames(t, e) {
                if (!this._consumables.has(t)) {
                    this._consumables.set(t, [])
                }
                this._consumables.get(t).push(...e)
            }
        }

        function Uu(t) {
            let e = null;
            let n = 0;
            let i = 0;
            let o = null;
            const r = new Map;
            if (t === "") {
                return r
            }
            if (t.charAt(t.length - 1) != ";") {
                t = t + ";"
            }
            for (let s = 0; s < t.length; s++) {
                const a = t.charAt(s);
                if (e === null) {
                    switch (a) {
                        case":":
                            if (!o) {
                                o = t.substr(n, s - n);
                                i = s + 1
                            }
                            break;
                        case'"':
                        case"'":
                            e = a;
                            break;
                        case";": {
                            const e = t.substr(i, s - i);
                            if (o) {
                                r.set(o.trim(), e.trim())
                            }
                            o = null;
                            n = s + 1;
                            break
                        }
                    }
                } else if (a === e) {
                    e = null
                }
            }
            return r
        }

        function Gu(t) {
            return t.replace("-", ".")
        }

        function Ku(t, e, n) {
            let i = n;
            if (it(n)) {
                i = Nu({}, Yd(t, e), n)
            }
            qu(t, e, i)
        }

        class Zu extends Kc {
            constructor(t, e, n, i) {
                super(t);
                this.name = e;
                this._attrs = Ju(n);
                this._children = [];
                if (i) {
                    this._insertChild(0, i)
                }
                this._classes = new Set;
                if (this._attrs.has("class")) {
                    const t = this._attrs.get("class");
                    Yu(this._classes, t);
                    this._attrs.delete("class")
                }
                this._styles = new ju(this.document.stylesProcessor);
                if (this._attrs.has("style")) {
                    this._styles.setTo(this._attrs.get("style"));
                    this._attrs.delete("style")
                }
                this._customProperties = new Map;
                this._unsafeAttributesToRender = []
            }

            get childCount() {
                return this._children.length
            }

            get isEmpty() {
                return this._children.length === 0
            }

            getChild(t) {
                return this._children[t]
            }

            getChildIndex(t) {
                return this._children.indexOf(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            * getAttributeKeys() {
                if (this._classes.size > 0) {
                    yield"class"
                }
                if (!this._styles.isEmpty) {
                    yield"style"
                }
                yield* this._attrs.keys()
            }

            * getAttributes() {
                yield* this._attrs.entries();
                if (this._classes.size > 0) {
                    yield["class", this.getAttribute("class")]
                }
                if (!this._styles.isEmpty) {
                    yield["style", this.getAttribute("style")]
                }
            }

            getAttribute(t) {
                if (t == "class") {
                    if (this._classes.size > 0) {
                        return [...this._classes].join(" ")
                    }
                    return undefined
                }
                if (t == "style") {
                    const t = this._styles.toString();
                    return t == "" ? undefined : t
                }
                return this._attrs.get(t)
            }

            hasAttribute(t) {
                if (t == "class") {
                    return this._classes.size > 0
                }
                if (t == "style") {
                    return !this._styles.isEmpty
                }
                return this._attrs.has(t)
            }

            isSimilar(t) {
                if (!(t instanceof Zu)) {
                    return false
                }
                if (this === t) {
                    return true
                }
                if (this.name != t.name) {
                    return false
                }
                if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) {
                    return false
                }
                for (const [e, n] of this._attrs) {
                    if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
                        return false
                    }
                }
                for (const e of this._classes) {
                    if (!t._classes.has(e)) {
                        return false
                    }
                }
                for (const e of this._styles.getStyleNames()) {
                    if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
                        return false
                    }
                }
                return true
            }

            hasClass(...t) {
                for (const e of t) {
                    if (!this._classes.has(e)) {
                        return false
                    }
                }
                return true
            }

            getClassNames() {
                return this._classes.keys()
            }

            getStyle(t) {
                return this._styles.getAsString(t)
            }

            getNormalizedStyle(t) {
                return this._styles.getNormalized(t)
            }

            getStyleNames(t) {
                return this._styles.getStyleNames(t)
            }

            hasStyle(...t) {
                for (const e of t) {
                    if (!this._styles.has(e)) {
                        return false
                    }
                }
                return true
            }

            findAncestor(...t) {
                const e = new Yc(...t);
                let n = this.parent;
                while (n && !n.is("documentFragment")) {
                    if (e.match(n)) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }

            getCustomProperty(t) {
                return this._customProperties.get(t)
            }

            * getCustomProperties() {
                yield* this._customProperties.entries()
            }

            getIdentity() {
                const t = Array.from(this._classes).sort().join(",");
                const e = this._styles.toString();
                const n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" ");
                return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`)
            }

            shouldRenderUnsafeAttribute(t) {
                return this._unsafeAttributesToRender.includes(t)
            }

            _clone(t = false) {
                const e = [];
                if (t) {
                    for (const n of this.getChildren()) {
                        e.push(n._clone(t))
                    }
                }
                const n = new this.constructor(this.document, this.name, this._attrs, e);
                n._classes = new Set(this._classes);
                n._styles.set(this._styles.getNormalized());
                n._customProperties = new Map(this._customProperties);
                n.getFillerOffset = this.getFillerOffset;
                n._unsafeAttributesToRender = this._unsafeAttributesToRender;
                return n
            }

            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const i = Qu(this.document, e);
                for (const e of i) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    e.document = this.document;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }

            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }

            _setAttribute(t, e) {
                e = String(e);
                this._fireChange("attributes", this);
                if (t == "class") {
                    Yu(this._classes, e)
                } else if (t == "style") {
                    this._styles.setTo(e)
                } else {
                    this._attrs.set(t, e)
                }
            }

            _removeAttribute(t) {
                this._fireChange("attributes", this);
                if (t == "class") {
                    if (this._classes.size > 0) {
                        this._classes.clear();
                        return true
                    }
                    return false
                }
                if (t == "style") {
                    if (!this._styles.isEmpty) {
                        this._styles.clear();
                        return true
                    }
                    return false
                }
                return this._attrs.delete(t)
            }

            _addClass(t) {
                this._fireChange("attributes", this);
                for (const e of Zl(t)) {
                    this._classes.add(e)
                }
            }

            _removeClass(t) {
                this._fireChange("attributes", this);
                for (const e of Zl(t)) {
                    this._classes.delete(e)
                }
            }

            _setStyle(t, e) {
                this._fireChange("attributes", this);
                if (he(t)) {
                    this._styles.set(t)
                } else {
                    this._styles.set(t, e)
                }
            }

            _removeStyle(t) {
                this._fireChange("attributes", this);
                for (const e of Zl(t)) {
                    this._styles.remove(e)
                }
            }

            _setCustomProperty(t, e) {
                this._customProperties.set(t, e)
            }

            _removeCustomProperty(t) {
                return this._customProperties.delete(t)
            }
        }

        Zu.prototype.is = function (t, e) {
            if (!e) {
                return t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "element" || t === "view:element")
            }
        };

        function Ju(t) {
            const e = dc(t);
            for (const [t, n] of e) {
                if (n === null) {
                    e.delete(t)
                } else if (typeof n != "string") {
                    e.set(t, String(n))
                }
            }
            return e
        }

        function Yu(t, e) {
            const n = e.split(/\s+/);
            t.clear();
            n.forEach((e => t.add(e)))
        }

        function Qu(t, e) {
            if (typeof e == "string") {
                return [new Zc(t, e)]
            }
            if (!yt(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Zc(t, e)
                }
                if (e instanceof Jc) {
                    return new Zc(t, e.data)
                }
                return e
            }))
        }

        class Xu extends Zu {
            constructor(...t) {
                super(...t);
                this.getFillerOffset = th
            }
        }

        Xu.prototype.is = function (t, e) {
            if (!e) {
                return t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
            }
        };

        function th() {
            const t = [...this.getChildren()];
            const e = t[this.childCount - 1];
            if (e && e.is("element", "br")) {
                return this.childCount
            }
            for (const e of t) {
                if (!e.is("uiElement")) {
                    return null
                }
            }
            return this.childCount
        }

        class eh extends (dt(Xu)) {
            constructor(...t) {
                super(...t);
                const e = t[0];
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.bind("isReadOnly").to(e);
                this.bind("isFocused").to(e, "isFocused", (t => t && e.selection.editableElement == this));
                this.listenTo(e.selection, "change", (() => {
                    this.isFocused = e.isFocused && e.selection.editableElement == this
                }))
            }

            destroy() {
                this.stopListening()
            }
        }

        eh.prototype.is = function (t, e) {
            if (!e) {
                return t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
            }
        };
        const nh = Symbol("rootName");

        class ih extends eh {
            constructor(t, e) {
                super(t, e);
                this.rootName = "main"
            }

            get rootName() {
                return this.getCustomProperty(nh)
            }

            set rootName(t) {
                this._setCustomProperty(nh, t)
            }

            set _name(t) {
                this.name = t
            }
        }

        ih.prototype.is = function (t, e) {
            if (!e) {
                return t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
            }
        };

        class oh {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new P("view-tree-walker-no-start-position", null)
                }
                if (t.direction && t.direction != "forward" && t.direction != "backward") {
                    throw new P("view-tree-walker-unknown-direction", t.startPosition, {direction: t.direction})
                }
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = rh._createAt(t.startPosition)
                } else {
                    this.position = rh._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"])
                }
                this.direction = t.direction || "forward";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
            }

            [Symbol.iterator]() {
                return this
            }

            skip(t) {
                let e, n, i;
                do {
                    i = this.position;
                    ({done: e, value: n} = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = i
                }
            }

            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }

            _next() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === n.childCount) {
                    return {done: true, value: undefined}
                }
                if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
                    return {done: true, value: undefined}
                }
                let i;
                if (n instanceof Zc) {
                    if (t.isAtEnd) {
                        this.position = rh._createAfter(n);
                        return this._next()
                    }
                    i = n.data[t.offset]
                } else {
                    i = n.getChild(t.offset)
                }
                if (i instanceof Zu) {
                    if (!this.shallow) {
                        t = new rh(i, 0)
                    } else {
                        t.offset++
                    }
                    this.position = t;
                    return this._formatReturnValue("elementStart", i, e, t, 1)
                } else if (i instanceof Zc) {
                    if (this.singleCharacters) {
                        t = new rh(i, 0);
                        this.position = t;
                        return this._next()
                    } else {
                        let n = i.data.length;
                        let o;
                        if (i == this._boundaryEndParent) {
                            n = this.boundaries.end.offset;
                            o = new Jc(i, 0, n);
                            t = rh._createAfter(o)
                        } else {
                            o = new Jc(i, 0, i.data.length);
                            t.offset++
                        }
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, n)
                    }
                } else if (typeof i == "string") {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length;
                        i = e - t.offset
                    }
                    const o = new Jc(n, t.offset, i);
                    t.offset += i;
                    this.position = t;
                    return this._formatReturnValue("text", o, e, t, i)
                } else {
                    t = rh._createAfter(n);
                    this.position = t;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return this._formatReturnValue("elementEnd", n, e, t)
                    }
                }
            }

            _previous() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === 0) {
                    return {done: true, value: undefined}
                }
                if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
                    return {done: true, value: undefined}
                }
                let i;
                if (n instanceof Zc) {
                    if (t.isAtStart) {
                        this.position = rh._createBefore(n);
                        return this._previous()
                    }
                    i = n.data[t.offset - 1]
                } else {
                    i = n.getChild(t.offset - 1)
                }
                if (i instanceof Zu) {
                    if (!this.shallow) {
                        t = new rh(i, i.childCount);
                        this.position = t;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return this._formatReturnValue("elementEnd", i, e, t)
                        }
                    } else {
                        t.offset--;
                        this.position = t;
                        return this._formatReturnValue("elementStart", i, e, t, 1)
                    }
                } else if (i instanceof Zc) {
                    if (this.singleCharacters) {
                        t = new rh(i, i.data.length);
                        this.position = t;
                        return this._previous()
                    } else {
                        let n = i.data.length;
                        let o;
                        if (i == this._boundaryStartParent) {
                            const e = this.boundaries.start.offset;
                            o = new Jc(i, e, i.data.length - e);
                            n = o.data.length;
                            t = rh._createBefore(o)
                        } else {
                            o = new Jc(i, 0, i.data.length);
                            t.offset--
                        }
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, n)
                    }
                } else if (typeof i == "string") {
                    let i;
                    if (!this.singleCharacters) {
                        const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                        i = t.offset - e
                    } else {
                        i = 1
                    }
                    t.offset -= i;
                    const o = new Jc(n, t.offset, i);
                    this.position = t;
                    return this._formatReturnValue("text", o, e, t, i)
                } else {
                    t = rh._createBefore(n);
                    this.position = t;
                    return this._formatReturnValue("elementStart", n, e, t, 1)
                }
            }

            _formatReturnValue(t, e, n, i, o) {
                if (e instanceof Jc) {
                    if (e.offsetInText + e.data.length == e.textNode.data.length) {
                        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                            i = rh._createAfter(e.textNode);
                            this.position = i
                        } else {
                            n = rh._createAfter(e.textNode)
                        }
                    }
                    if (e.offsetInText === 0) {
                        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                            i = rh._createBefore(e.textNode);
                            this.position = i
                        } else {
                            n = rh._createBefore(e.textNode)
                        }
                    }
                }
                return {done: false, value: {type: t, item: e, previousPosition: n, nextPosition: i, length: o}}
            }
        }

        class rh extends jc {
            constructor(t, e) {
                super();
                this.parent = t;
                this.offset = e
            }

            get nodeAfter() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset) || null
            }

            get nodeBefore() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset - 1) || null
            }

            get isAtStart() {
                return this.offset === 0
            }

            get isAtEnd() {
                const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                return this.offset === t
            }

            get root() {
                return this.parent.root
            }

            get editableElement() {
                let t = this.parent;
                while (!(t instanceof eh)) {
                    if (t.parent) {
                        t = t.parent
                    } else {
                        return null
                    }
                }
                return t
            }

            getShiftedBy(t) {
                const e = rh._createAt(this);
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }

            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new oh(e);
                n.skip(t);
                return n.position
            }

            getAncestors() {
                if (this.parent.is("documentFragment")) {
                    return [this.parent]
                } else {
                    return this.parent.getAncestors({includeSelf: true})
                }
            }

            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let i = 0;
                while (e[i] == n[i] && e[i]) {
                    i++
                }
                return i === 0 ? null : e[i - 1]
            }

            isEqual(t) {
                return this.parent == t.parent && this.offset == t.offset
            }

            isBefore(t) {
                return this.compareWith(t) == "before"
            }

            isAfter(t) {
                return this.compareWith(t) == "after"
            }

            compareWith(t) {
                if (this.root !== t.root) {
                    return "different"
                }
                if (this.isEqual(t)) {
                    return "same"
                }
                const e = this.parent.is("node") ? this.parent.getPath() : [];
                const n = t.parent.is("node") ? t.parent.getPath() : [];
                e.push(this.offset);
                n.push(t.offset);
                const i = vt(e, n);
                switch (i) {
                    case"prefix":
                        return "before";
                    case"extension":
                        return "after";
                    default:
                        return e[i] < n[i] ? "before" : "after"
                }
            }

            getWalker(t = {}) {
                t.startPosition = this;
                return new oh(t)
            }

            clone() {
                return new rh(this.parent, this.offset)
            }

            static _createAt(t, e) {
                if (t instanceof rh) {
                    return new this(t.parent, t.offset)
                } else {
                    const n = t;
                    if (e == "end") {
                        e = n.is("$text") ? n.data.length : n.childCount
                    } else if (e == "before") {
                        return this._createBefore(n)
                    } else if (e == "after") {
                        return this._createAfter(n)
                    } else if (e !== 0 && !e) {
                        throw new P("view-createpositionat-offset-required", n)
                    }
                    return new rh(n, e)
                }
            }

            static _createAfter(t) {
                if (t.is("$textProxy")) {
                    return new rh(t.textNode, t.offsetInText + t.data.length)
                }
                if (!t.parent) {
                    throw new P("view-position-after-root", t, {root: t})
                }
                return new rh(t.parent, t.index + 1)
            }

            static _createBefore(t) {
                if (t.is("$textProxy")) {
                    return new rh(t.textNode, t.offsetInText)
                }
                if (!t.parent) {
                    throw new P("view-position-before-root", t, {root: t})
                }
                return new rh(t.parent, t.index)
            }
        }

        rh.prototype.is = function (t) {
            return t === "position" || t === "view:position"
        };

        class sh extends jc {
            constructor(t, e = null) {
                super();
                this.start = t.clone();
                this.end = e ? e.clone() : t.clone()
            }

            * [Symbol.iterator]() {
                yield* new oh({boundaries: this, ignoreElementEnd: true})
            }

            get isCollapsed() {
                return this.start.isEqual(this.end)
            }

            get isFlat() {
                return this.start.parent === this.end.parent
            }

            get root() {
                return this.start.root
            }

            getEnlarged() {
                let t = this.start.getLastMatchingPosition(ah, {direction: "backward"});
                let e = this.end.getLastMatchingPosition(ah);
                if (t.parent.is("$text") && t.isAtStart) {
                    t = rh._createBefore(t.parent)
                }
                if (e.parent.is("$text") && e.isAtEnd) {
                    e = rh._createAfter(e.parent)
                }
                return new sh(t, e)
            }

            getTrimmed() {
                let t = this.start.getLastMatchingPosition(ah);
                if (t.isAfter(this.end) || t.isEqual(this.end)) {
                    return new sh(t, t)
                }
                let e = this.end.getLastMatchingPosition(ah, {direction: "backward"});
                const n = t.nodeAfter;
                const i = e.nodeBefore;
                if (n && n.is("$text")) {
                    t = new rh(n, 0)
                }
                if (i && i.is("$text")) {
                    e = new rh(i, i.data.length)
                }
                return new sh(t, e)
            }

            isEqual(t) {
                return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }

            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }

            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && i
            }

            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new sh(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new sh(t.end, this.end))
                    }
                } else {
                    e.push(this.clone())
                }
                return e
            }

            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new sh(e, n)
                }
                return null
            }

            getWalker(t = {}) {
                t.boundaries = this;
                return new oh(t)
            }

            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }

            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                let t = this.start.nodeAfter;
                let e = this.end.nodeBefore;
                if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
                    t = this.start.parent.nextSibling
                }
                if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
                    e = this.end.parent.previousSibling
                }
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }

            clone() {
                return new sh(this.start, this.end)
            }

            * getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new oh(t);
                for (const t of e) {
                    yield t.item
                }
            }

            * getPositions(t = {}) {
                t.boundaries = this;
                const e = new oh(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }

            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }

            static _createFromParentsAndOffsets(t, e, n, i) {
                return new this(new rh(t, e), new rh(n, i))
            }

            static _createFromPositionAndShift(t, e) {
                const n = t;
                const i = t.getShiftedBy(e);
                return e > 0 ? new this(n, i) : new this(i, n)
            }

            static _createIn(t) {
                return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
            }

            static _createOn(t) {
                const e = t.is("$textProxy") ? t.offsetSize : 1;
                return this._createFromPositionAndShift(rh._createBefore(t), e)
            }
        }

        sh.prototype.is = function (t) {
            return t === "range" || t === "view:range"
        };

        function ah(t) {
            if (t.item.is("attributeElement") || t.item.is("uiElement")) {
                return true
            }
            return false
        }

        class lh extends (j(jc)) {
            constructor(...t) {
                super();
                this._ranges = [];
                this._lastRangeBackward = false;
                this._isFake = false;
                this._fakeSelectionLabel = "";
                if (t.length) {
                    this.setTo(...t)
                }
            }

            get isFake() {
                return this._isFake
            }

            get fakeSelectionLabel() {
                return this._fakeSelectionLabel
            }

            get anchor() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.end : t.start;
                return e.clone()
            }

            get focus() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.start : t.end;
                return e.clone()
            }

            get isCollapsed() {
                return this.rangeCount === 1 && this._ranges[0].isCollapsed
            }

            get rangeCount() {
                return this._ranges.length
            }

            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }

            get editableElement() {
                if (this.anchor) {
                    return this.anchor.editableElement
                }
                return null
            }

            * getRanges() {
                for (const t of this._ranges) {
                    yield t.clone()
                }
            }

            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }

            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }

            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }

            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }

            isEqual(t) {
                if (this.isFake != t.isFake) {
                    return false
                }
                if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
                    return false
                }
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const i of t._ranges) {
                        if (e.isEqual(i)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            isSimilar(t) {
                if (this.isBackward != t.isBackward) {
                    return false
                }
                const e = Ct(this.getRanges());
                const n = Ct(t.getRanges());
                if (e != n) {
                    return false
                }
                if (e == 0) {
                    return true
                }
                for (let e of this.getRanges()) {
                    e = e.getTrimmed();
                    let n = false;
                    for (let i of t.getRanges()) {
                        i = i.getTrimmed();
                        if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }

            setTo(...t) {
                let [e, n, i] = t;
                if (typeof n == "object") {
                    i = n;
                    n = undefined
                }
                if (e === null) {
                    this._setRanges([]);
                    this._setFakeOptions(i)
                } else if (e instanceof lh || e instanceof ch) {
                    this._setRanges(e.getRanges(), e.isBackward);
                    this._setFakeOptions({fake: e.isFake, label: e.fakeSelectionLabel})
                } else if (e instanceof sh) {
                    this._setRanges([e], i && i.backward);
                    this._setFakeOptions(i)
                } else if (e instanceof rh) {
                    this._setRanges([new sh(e)]);
                    this._setFakeOptions(i)
                } else if (e instanceof Kc) {
                    const t = !!i && !!i.backward;
                    let o;
                    if (n === undefined) {
                        throw new P("view-selection-setto-required-second-parameter", this)
                    } else if (n == "in") {
                        o = sh._createIn(e)
                    } else if (n == "on") {
                        o = sh._createOn(e)
                    } else {
                        o = new sh(rh._createAt(e, n))
                    }
                    this._setRanges([o], t);
                    this._setFakeOptions(i)
                } else if (yt(e)) {
                    this._setRanges(e, i && i.backward);
                    this._setFakeOptions(i)
                } else {
                    throw new P("view-selection-setto-not-selectable", this)
                }
                this.fire("change")
            }

            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new P("view-selection-setfocus-no-ranges", this)
                }
                const n = rh._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const i = this.anchor;
                this._ranges.pop();
                if (n.compareWith(i) == "before") {
                    this._addRange(new sh(n, i), true)
                } else {
                    this._addRange(new sh(i, n))
                }
                this.fire("change")
            }

            _setRanges(t, e = false) {
                t = Array.from(t);
                this._ranges = [];
                for (const e of t) {
                    this._addRange(e)
                }
                this._lastRangeBackward = !!e
            }

            _setFakeOptions(t = {}) {
                this._isFake = !!t.fake;
                this._fakeSelectionLabel = t.fake ? t.label || "" : ""
            }

            _addRange(t, e = false) {
                if (!(t instanceof sh)) {
                    throw new P("view-selection-add-range-not-range", this)
                }
                this._pushRange(t);
                this._lastRangeBackward = !!e
            }

            _pushRange(t) {
                for (const e of this._ranges) {
                    if (t.isIntersecting(e)) {
                        throw new P("view-selection-range-intersects", this, {addedRange: t, intersectingRange: e})
                    }
                }
                this._ranges.push(new sh(t.start, t.end))
            }
        }

        lh.prototype.is = function (t) {
            return t === "selection" || t === "view:selection"
        };

        class ch extends (j(jc)) {
            constructor(...t) {
                super();
                this._selection = new lh;
                this._selection.delegate("change").to(this);
                if (t.length) {
                    this._selection.setTo(...t)
                }
            }

            get isFake() {
                return this._selection.isFake
            }

            get fakeSelectionLabel() {
                return this._selection.fakeSelectionLabel
            }

            get anchor() {
                return this._selection.anchor
            }

            get focus() {
                return this._selection.focus
            }

            get isCollapsed() {
                return this._selection.isCollapsed
            }

            get rangeCount() {
                return this._selection.rangeCount
            }

            get isBackward() {
                return this._selection.isBackward
            }

            get editableElement() {
                return this._selection.editableElement
            }

            get _ranges() {
                return this._selection._ranges
            }

            * getRanges() {
                yield* this._selection.getRanges()
            }

            getFirstRange() {
                return this._selection.getFirstRange()
            }

            getLastRange() {
                return this._selection.getLastRange()
            }

            getFirstPosition() {
                return this._selection.getFirstPosition()
            }

            getLastPosition() {
                return this._selection.getLastPosition()
            }

            getSelectedElement() {
                return this._selection.getSelectedElement()
            }

            isEqual(t) {
                return this._selection.isEqual(t)
            }

            isSimilar(t) {
                return this._selection.isSimilar(t)
            }

            _setTo(...t) {
                this._selection.setTo(...t)
            }

            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
        }

        ch.prototype.is = function (t) {
            return t === "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection"
        };

        class dh extends y {
            constructor(t, e, n) {
                super(t, e);
                this.startRange = n;
                this._eventPhase = "none";
                this._currentTarget = null
            }

            get eventPhase() {
                return this._eventPhase
            }

            get currentTarget() {
                return this._currentTarget
            }
        }

        const uh = Symbol("bubbling contexts");

        function hh(t) {
            class e extends t {
                fire(t, ...e) {
                    try {
                        const n = t instanceof y ? t : new y(this, t);
                        const i = ph(this);
                        if (!i.size) {
                            return
                        }
                        fh(n, "capturing", this);
                        if (gh(i, "$capture", n, ...e)) {
                            return n.return
                        }
                        const o = n.startRange || this.selection.getFirstRange();
                        const r = o ? o.getContainedElement() : null;
                        const s = r ? Boolean(mh(i, r)) : false;
                        let a = r || bh(o);
                        fh(n, "atTarget", a);
                        if (!s) {
                            if (gh(i, "$text", n, ...e)) {
                                return n.return
                            }
                            fh(n, "bubbling", a)
                        }
                        while (a) {
                            if (a.is("rootElement")) {
                                if (gh(i, "$root", n, ...e)) {
                                    return n.return
                                }
                            } else if (a.is("element")) {
                                if (gh(i, a.name, n, ...e)) {
                                    return n.return
                                }
                            }
                            if (gh(i, a, n, ...e)) {
                                return n.return
                            }
                            a = a.parent;
                            fh(n, "bubbling", a)
                        }
                        fh(n, "bubbling", this);
                        gh(i, "$document", n, ...e);
                        return n.return
                    } catch (t) {
                        P.rethrowUnexpectedError(t, this)
                    }
                }

                _addEventListener(t, e, n) {
                    const i = Zl(n.context || "$document");
                    const o = ph(this);
                    for (const r of i) {
                        let i = o.get(r);
                        if (!i) {
                            i = new (j());
                            o.set(r, i)
                        }
                        this.listenTo(i, t, e, n)
                    }
                }

                _removeEventListener(t, e) {
                    const n = ph(this);
                    for (const i of n.values()) {
                        this.stopListening(i, t, e)
                    }
                }
            }

            return e
        }

        {
            const t = hh(Object);
            ["fire", "_addEventListener", "_removeEventListener"].forEach((e => {
                hh[e] = t.prototype[e]
            }))
        }

        function fh(t, e, n) {
            if (t instanceof dh) {
                t._eventPhase = e;
                t._currentTarget = n
            }
        }

        function gh(t, e, n, ...i) {
            const o = typeof e == "string" ? t.get(e) : mh(t, e);
            if (!o) {
                return false
            }
            o.fire(n, ...i);
            return n.stop.called
        }

        function mh(t, e) {
            for (const [n, i] of t) {
                if (typeof n == "function" && n(e)) {
                    return i
                }
            }
            return null
        }

        function ph(t) {
            if (!t[uh]) {
                t[uh] = new Map
            }
            return t[uh]
        }

        function bh(t) {
            if (!t) {
                return null
            }
            const e = t.start.parent;
            const n = t.end.parent;
            const i = e.getPath();
            const o = n.getPath();
            return i.length > o.length ? e : n
        }

        class kh extends (hh(dt())) {
            constructor(t) {
                super();
                this.selection = new ch;
                this.roots = new rc({idProperty: "rootName"});
                this.stylesProcessor = t;
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.set("_isFocusChanging", false);
                this.set("isSelecting", false);
                this.set("isComposing", false);
                this._postFixers = new Set
            }

            getRoot(t = "main") {
                return this.roots.get(t)
            }

            registerPostFixer(t) {
                this._postFixers.add(t)
            }

            destroy() {
                this.roots.map((t => t.destroy()));
                this.stopListening()
            }

            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }

        const wh = 10;

        class _h extends Zu {
            constructor(...t) {
                super(...t);
                this.getFillerOffset = Ah;
                this._priority = wh;
                this._id = null;
                this._clonesGroup = null
            }

            get priority() {
                return this._priority
            }

            get id() {
                return this._id
            }

            getElementsWithSameId() {
                if (this.id === null) {
                    throw new P("attribute-element-get-elements-with-same-id-no-id", this)
                }
                return new Set(this._clonesGroup)
            }

            isSimilar(t) {
                if (this.id !== null || t.id !== null) {
                    return this.id === t.id
                }
                return super.isSimilar(t) && this.priority == t.priority
            }

            _clone(t = false) {
                const e = super._clone(t);
                e._priority = this._priority;
                e._id = this._id;
                return e
            }
        }

        _h.DEFAULT_PRIORITY = wh;
        _h.prototype.is = function (t, e) {
            if (!e) {
                return t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element")
            }
        };

        function Ah() {
            if (Ch(this)) {
                return null
            }
            let t = this.parent;
            while (t && t.is("attributeElement")) {
                if (Ch(t) > 1) {
                    return null
                }
                t = t.parent
            }
            if (!t || Ch(t) > 1) {
                return null
            }
            return this.childCount
        }

        function Ch(t) {
            return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length
        }

        class vh extends Zu {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = yh
            }

            _insertChild(t, e) {
                if (e && (e instanceof Kc || Array.from(e).length > 0)) {
                    throw new P("view-emptyelement-cannot-add", [this, e])
                }
                return 0
            }
        }

        vh.prototype.is = function (t, e) {
            if (!e) {
                return t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element")
            }
        };

        function yh() {
            return null
        }

        class xh extends Zu {
            constructor(...t) {
                super(...t);
                this.getFillerOffset = Sh
            }

            _insertChild(t, e) {
                if (e && (e instanceof Kc || Array.from(e).length > 0)) {
                    throw new P("view-uielement-cannot-add", [this, e])
                }
                return 0
            }

            render(t, e) {
                return this.toDomElement(t)
            }

            toDomElement(t) {
                const e = t.createElement(this.name);
                for (const t of this.getAttributeKeys()) {
                    e.setAttribute(t, this.getAttribute(t))
                }
                return e
            }
        }

        xh.prototype.is = function (t, e) {
            if (!e) {
                return t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element")
            }
        };

        function Eh(t) {
            t.document.on("arrowKey", ((e, n) => Dh(e, n, t.domConverter)), {priority: "low"})
        }

        function Sh() {
            return null
        }

        function Dh(t, e, n) {
            if (e.keyCode == Ol.arrowright) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
                if (i || e.shiftKey) {
                    const e = t.focusNode;
                    const o = t.focusOffset;
                    const r = n.domPositionToView(e, o);
                    if (r === null) {
                        return
                    }
                    let s = false;
                    const a = r.getLastMatchingPosition((t => {
                        if (t.item.is("uiElement")) {
                            s = true
                        }
                        if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                            return true
                        }
                        return false
                    }));
                    if (s) {
                        const e = n.viewPositionToDom(a);
                        if (i) {
                            t.collapse(e.parent, e.offset)
                        } else {
                            t.extend(e.parent, e.offset)
                        }
                    }
                }
            }
        }

        class Th extends Zu {
            constructor(...t) {
                super(...t);
                this.getFillerOffset = Bh
            }

            _insertChild(t, e) {
                if (e && (e instanceof Kc || Array.from(e).length > 0)) {
                    throw new P("view-rawelement-cannot-add", [this, e])
                }
                return 0
            }

            render() {
            }
        }

        Th.prototype.is = function (t, e) {
            if (!e) {
                return t === "rawElement" || t === "view:rawElement" || t === this.name || t === "view:" + this.name || t === "element" || t === "view:element" || t === "node" || t === "view:node"
            } else {
                return e === this.name && (t === "rawElement" || t === "view:rawElement" || t === "element" || t === "view:element")
            }
        };

        function Bh() {
            return null
        }

        class Ph extends (j(jc)) {
            constructor(t, e) {
                super();
                this.document = t;
                this._children = [];
                if (e) {
                    this._insertChild(0, e)
                }
            }

            [Symbol.iterator]() {
                return this._children[Symbol.iterator]()
            }

            get childCount() {
                return this._children.length
            }

            get isEmpty() {
                return this.childCount === 0
            }

            get root() {
                return this
            }

            get parent() {
                return null
            }

            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }

            getChild(t) {
                return this._children[t]
            }

            getChildIndex(t) {
                return this._children.indexOf(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const i = Ih(this.document, e);
                for (const e of i) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }

            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }

            _fireChange(t, e) {
                this.fire("change:" + t, e)
            }
        }

        Ph.prototype.is = function (t) {
            return t === "documentFragment" || t === "view:documentFragment"
        };

        function Ih(t, e) {
            if (typeof e == "string") {
                return [new Zc(t, e)]
            }
            if (!yt(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Zc(t, e)
                }
                if (e instanceof Jc) {
                    return new Zc(t, e.data)
                }
                return e
            }))
        }

        class Rh {
            constructor(t) {
                this.document = t;
                this._cloneGroups = new Map;
                this._slotFactory = null
            }

            setSelection(...t) {
                this.document.selection._setTo(...t)
            }

            setSelectionFocus(...t) {
                this.document.selection._setFocus(...t)
            }

            createDocumentFragment(t) {
                return new Ph(this.document, t)
            }

            createText(t) {
                return new Zc(this.document, t)
            }

            createAttributeElement(t, e, n = {}) {
                const i = new _h(this.document, t, e);
                if (typeof n.priority === "number") {
                    i._priority = n.priority
                }
                if (n.id) {
                    i._id = n.id
                }
                if (n.renderUnsafeAttributes) {
                    i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
                }
                return i
            }

            createContainerElement(t, e, n = {}, i = {}) {
                let o = null;
                if (he(n)) {
                    i = n
                } else {
                    o = n
                }
                const r = new Xu(this.document, t, e, o);
                if (i.renderUnsafeAttributes) {
                    r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes)
                }
                return r
            }

            createEditableElement(t, e, n = {}) {
                const i = new eh(this.document, t, e);
                if (n.renderUnsafeAttributes) {
                    i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
                }
                return i
            }

            createEmptyElement(t, e, n = {}) {
                const i = new vh(this.document, t, e);
                if (n.renderUnsafeAttributes) {
                    i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
                }
                return i
            }

            createUIElement(t, e, n) {
                const i = new xh(this.document, t, e);
                if (n) {
                    i.render = n
                }
                return i
            }

            createRawElement(t, e, n, i = {}) {
                const o = new Th(this.document, t, e);
                if (n) {
                    o.render = n
                }
                if (i.renderUnsafeAttributes) {
                    o._unsafeAttributesToRender.push(...i.renderUnsafeAttributes)
                }
                return o
            }

            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }

            removeAttribute(t, e) {
                e._removeAttribute(t)
            }

            addClass(t, e) {
                e._addClass(t)
            }

            removeClass(t, e) {
                e._removeClass(t)
            }

            setStyle(t, e, n) {
                if (he(t) && n === undefined) {
                    e._setStyle(t)
                } else {
                    n._setStyle(t, e)
                }
            }

            removeStyle(t, e) {
                e._removeStyle(t)
            }

            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }

            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }

            breakAttributes(t) {
                if (t instanceof rh) {
                    return this._breakAttributes(t)
                } else {
                    return this._breakAttributesRange(t)
                }
            }

            breakContainer(t) {
                const e = t.parent;
                if (!e.is("containerElement")) {
                    throw new P("view-writer-break-non-container-element", this.document)
                }
                if (!e.parent) {
                    throw new P("view-writer-break-root", this.document)
                }
                if (t.isAtStart) {
                    return rh._createBefore(e)
                } else if (!t.isAtEnd) {
                    const n = e._clone(false);
                    this.insert(rh._createAfter(e), n);
                    const i = new sh(t, rh._createAt(e, "end"));
                    const o = new rh(n, 0);
                    this.move(i, o)
                }
                return rh._createAfter(e)
            }

            mergeAttributes(t) {
                const e = t.offset;
                const n = t.parent;
                if (n.is("$text")) {
                    return t
                }
                if (n.is("attributeElement") && n.childCount === 0) {
                    const t = n.parent;
                    const e = n.index;
                    n._remove();
                    this._removeFromClonedElementsGroup(n);
                    return this.mergeAttributes(new rh(t, e))
                }
                const i = n.getChild(e - 1);
                const o = n.getChild(e);
                if (!i || !o) {
                    return t
                }
                if (i.is("$text") && o.is("$text")) {
                    return Nh(i, o)
                } else if (i.is("attributeElement") && o.is("attributeElement") && i.isSimilar(o)) {
                    const t = i.childCount;
                    i._appendChild(o.getChildren());
                    o._remove();
                    this._removeFromClonedElementsGroup(o);
                    return this.mergeAttributes(new rh(i, t))
                }
                return t
            }

            mergeContainers(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
                    throw new P("view-writer-merge-containers-invalid-position", this.document)
                }
                const i = e.getChild(e.childCount - 1);
                const o = i instanceof Zc ? rh._createAt(i, "end") : rh._createAt(e, "end");
                this.move(sh._createIn(n), rh._createAt(e, "end"));
                this.remove(sh._createOn(n));
                return o
            }

            insert(t, e) {
                e = yt(e) ? [...e] : [e];
                Hh(e, this.document);
                const n = e.reduce(((t, e) => {
                    const n = t[t.length - 1];
                    const i = !e.is("uiElement");
                    if (!n || n.breakAttributes != i) {
                        t.push({breakAttributes: i, nodes: [e]})
                    } else {
                        n.nodes.push(e)
                    }
                    return t
                }), []);
                let i = null;
                let o = t;
                for (const {nodes: t, breakAttributes: e} of n) {
                    const n = this._insertNodes(o, t, e);
                    if (!i) {
                        i = n.start
                    }
                    o = n.end
                }
                if (!i) {
                    return new sh(t)
                }
                return new sh(i, o)
            }

            remove(t) {
                const e = t instanceof sh ? t : sh._createOn(t);
                qh(e, this.document);
                if (e.isCollapsed) {
                    return new Ph(this.document)
                }
                const {start: n, end: i} = this._breakAttributesRange(e, true);
                const o = n.parent;
                const r = i.offset - n.offset;
                const s = o._removeChildren(n.offset, r);
                for (const t of s) {
                    this._removeFromClonedElementsGroup(t)
                }
                const a = this.mergeAttributes(n);
                e.start = a;
                e.end = a.clone();
                return new Ph(this.document, s)
            }

            clear(t, e) {
                qh(t, this.document);
                const n = t.getWalker({direction: "backward", ignoreElementEnd: true});
                for (const i of n) {
                    const n = i.item;
                    let o;
                    if (n.is("element") && e.isSimilar(n)) {
                        o = sh._createOn(n)
                    } else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
                        const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t)));
                        if (t) {
                            o = sh._createIn(t)
                        }
                    }
                    if (o) {
                        if (o.end.isAfter(t.end)) {
                            o.end = t.end
                        }
                        if (o.start.isBefore(t.start)) {
                            o.start = t.start
                        }
                        this.remove(o)
                    }
                }
            }

            move(t, e) {
                let n;
                if (e.isAfter(t.end)) {
                    e = this._breakAttributes(e, true);
                    const i = e.parent;
                    const o = i.childCount;
                    t = this._breakAttributesRange(t, true);
                    n = this.remove(t);
                    e.offset += i.childCount - o
                } else {
                    n = this.remove(t)
                }
                return this.insert(e, n)
            }

            wrap(t, e) {
                if (!(e instanceof _h)) {
                    throw new P("view-writer-wrap-invalid-attribute", this.document)
                }
                qh(t, this.document);
                if (!t.isCollapsed) {
                    return this._wrapRange(t, e)
                } else {
                    let n = t.start;
                    if (n.parent.is("element") && !zh(n.parent)) {
                        n = n.getLastMatchingPosition((t => t.item.is("uiElement")))
                    }
                    n = this._wrapPosition(n, e);
                    const i = this.document.selection;
                    if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) {
                        this.setSelection(n)
                    }
                    return new sh(n)
                }
            }

            unwrap(t, e) {
                if (!(e instanceof _h)) {
                    throw new P("view-writer-unwrap-invalid-attribute", this.document)
                }
                qh(t, this.document);
                if (t.isCollapsed) {
                    return t
                }
                const {start: n, end: i} = this._breakAttributesRange(t, true);
                const o = n.parent;
                const r = this._unwrapChildren(o, n.offset, i.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new sh(s, a)
            }

            rename(t, e) {
                const n = new Xu(this.document, t, e.getAttributes());
                this.insert(rh._createAfter(e), n);
                this.move(sh._createIn(e), rh._createAt(n, 0));
                this.remove(sh._createOn(e));
                return n
            }

            clearClonedElementsGroup(t) {
                this._cloneGroups.delete(t)
            }

            createPositionAt(t, e) {
                return rh._createAt(t, e)
            }

            createPositionAfter(t) {
                return rh._createAfter(t)
            }

            createPositionBefore(t) {
                return rh._createBefore(t)
            }

            createRange(...t) {
                return new sh(...t)
            }

            createRangeOn(t) {
                return sh._createOn(t)
            }

            createRangeIn(t) {
                return sh._createIn(t)
            }

            createSelection(...t) {
                return new lh(...t)
            }

            createSlot(t) {
                if (!this._slotFactory) {
                    throw new P("view-writer-invalid-create-slot-context", this.document)
                }
                return this._slotFactory(this, t)
            }

            _registerSlotFactory(t) {
                this._slotFactory = t
            }

            _clearSlotFactory() {
                this._slotFactory = null
            }

            _insertNodes(t, e, n) {
                let i;
                if (n) {
                    i = Vh(t)
                } else {
                    i = t.parent.is("$text") ? t.parent.parent : t.parent
                }
                if (!i) {
                    throw new P("view-writer-invalid-position-container", this.document)
                }
                let o;
                if (n) {
                    o = this._breakAttributes(t, true)
                } else {
                    o = t.parent.is("$text") ? Oh(t) : t
                }
                const r = i._insertChild(o.offset, e);
                for (const t of e) {
                    this._addToClonedElementsGroup(t)
                }
                const s = o.getShiftedBy(r);
                const a = this.mergeAttributes(o);
                if (!a.isEqual(o)) {
                    s.offset--
                }
                const l = this.mergeAttributes(s);
                return new sh(a, l)
            }

            _wrapChildren(t, e, n, i) {
                let o = e;
                const r = [];
                while (o < n) {
                    const e = t.getChild(o);
                    const n = e.is("$text");
                    const s = e.is("attributeElement");
                    if (s && this._wrapAttributeElement(i, e)) {
                        r.push(new rh(t, o))
                    } else if (n || !s || Fh(i, e)) {
                        const n = i._clone();
                        e._remove();
                        n._appendChild(e);
                        t._insertChild(o, n);
                        this._addToClonedElementsGroup(n);
                        r.push(new rh(t, o))
                    } else {
                        this._wrapChildren(e, 0, e.childCount, i)
                    }
                    o++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e) {
                        continue
                    }
                    const i = this.mergeAttributes(t);
                    if (!i.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return sh._createFromParentsAndOffsets(t, e, t, n)
            }

            _unwrapChildren(t, e, n, i) {
                let o = e;
                const r = [];
                while (o < n) {
                    const e = t.getChild(o);
                    if (!e.is("attributeElement")) {
                        o++;
                        continue
                    }
                    if (e.isSimilar(i)) {
                        const i = e.getChildren();
                        const s = e.childCount;
                        e._remove();
                        t._insertChild(o, i);
                        this._removeFromClonedElementsGroup(e);
                        r.push(new rh(t, o), new rh(t, o + s));
                        o += s;
                        n += s - 1;
                        continue
                    }
                    if (this._unwrapAttributeElement(i, e)) {
                        r.push(new rh(t, o), new rh(t, o + 1));
                        o++;
                        continue
                    }
                    this._unwrapChildren(e, 0, e.childCount, i);
                    o++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e || t.offset == n) {
                        continue
                    }
                    const i = this.mergeAttributes(t);
                    if (!i.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return sh._createFromParentsAndOffsets(t, e, t, n)
            }

            _wrapRange(t, e) {
                const {start: n, end: i} = this._breakAttributesRange(t, true);
                const o = n.parent;
                const r = this._wrapChildren(o, n.offset, i.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new sh(s, a)
            }

            _wrapPosition(t, e) {
                if (e.isSimilar(t.parent)) {
                    return Lh(t.clone())
                }
                if (t.parent.is("$text")) {
                    t = Oh(t)
                }
                const n = this.createAttributeElement("_wrapPosition-fake-element");
                n._priority = Number.POSITIVE_INFINITY;
                n.isSimilar = () => false;
                t.parent._insertChild(t.offset, n);
                const i = new sh(t, t.getShiftedBy(1));
                this.wrap(i, e);
                const o = new rh(n.parent, n.index);
                n._remove();
                const r = o.nodeBefore;
                const s = o.nodeAfter;
                if (r instanceof Zc && s instanceof Zc) {
                    return Nh(r, s)
                }
                return Lh(o)
            }

            _wrapAttributeElement(t, e) {
                if (!jh(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n)) {
                        this.setAttribute(n, t.getAttribute(n), e)
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n)) {
                        this.setStyle(n, t.getStyle(n), e)
                    }
                }
                for (const n of t.getClassNames()) {
                    if (!e.hasClass(n)) {
                        this.addClass(n, e)
                    }
                }
                return true
            }

            _unwrapAttributeElement(t, e) {
                if (!jh(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                if (!e.hasClass(...t.getClassNames())) {
                    return false
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    this.removeAttribute(n, e)
                }
                this.removeClass(Array.from(t.getClassNames()), e);
                this.removeStyle(Array.from(t.getStyleNames()), e);
                return true
            }

            _breakAttributesRange(t, e = false) {
                const n = t.start;
                const i = t.end;
                qh(t, this.document);
                if (t.isCollapsed) {
                    const n = this._breakAttributes(t.start, e);
                    return new sh(n, n)
                }
                const o = this._breakAttributes(i, e);
                const r = o.parent.childCount;
                const s = this._breakAttributes(n, e);
                o.offset += o.parent.childCount - r;
                return new sh(s, o)
            }

            _breakAttributes(t, e = false) {
                const n = t.offset;
                const i = t.parent;
                if (t.parent.is("emptyElement")) {
                    throw new P("view-writer-cannot-break-empty-element", this.document)
                }
                if (t.parent.is("uiElement")) {
                    throw new P("view-writer-cannot-break-ui-element", this.document)
                }
                if (t.parent.is("rawElement")) {
                    throw new P("view-writer-cannot-break-raw-element", this.document)
                }
                if (!e && i.is("$text") && Wh(i.parent)) {
                    return t.clone()
                }
                if (Wh(i)) {
                    return t.clone()
                }
                if (i.is("$text")) {
                    return this._breakAttributes(Oh(t), e)
                }
                const o = i.childCount;
                if (n == o) {
                    const t = new rh(i.parent, i.index + 1);
                    return this._breakAttributes(t, e)
                } else {
                    if (n === 0) {
                        const t = new rh(i.parent, i.index);
                        return this._breakAttributes(t, e)
                    } else {
                        const t = i.index + 1;
                        const o = i._clone();
                        i.parent._insertChild(t, o);
                        this._addToClonedElementsGroup(o);
                        const r = i.childCount - n;
                        const s = i._removeChildren(n, r);
                        o._appendChild(s);
                        const a = new rh(i.parent, t);
                        return this._breakAttributes(a, e)
                    }
                }
            }

            _addToClonedElementsGroup(t) {
                if (!t.root.is("rootElement")) {
                    return
                }
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._addToClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                let n = this._cloneGroups.get(e);
                if (!n) {
                    n = new Set;
                    this._cloneGroups.set(e, n)
                }
                n.add(t);
                t._clonesGroup = n
            }

            _removeFromClonedElementsGroup(t) {
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._removeFromClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                const n = this._cloneGroups.get(e);
                if (!n) {
                    return
                }
                n.delete(t)
            }
        }

        function zh(t) {
            return Array.from(t.getChildren()).some((t => !t.is("uiElement")))
        }

        function Vh(t) {
            let e = t.parent;
            while (!Wh(e)) {
                if (!e) {
                    return undefined
                }
                e = e.parent
            }
            return e
        }

        function Fh(t, e) {
            if (t.priority < e.priority) {
                return true
            } else if (t.priority > e.priority) {
                return false
            }
            return t.getIdentity() < e.getIdentity()
        }

        function Lh(t) {
            const e = t.nodeBefore;
            if (e && e.is("$text")) {
                return new rh(e, e.data.length)
            }
            const n = t.nodeAfter;
            if (n && n.is("$text")) {
                return new rh(n, 0)
            }
            return t
        }

        function Oh(t) {
            if (t.offset == t.parent.data.length) {
                return new rh(t.parent.parent, t.parent.index + 1)
            }
            if (t.offset === 0) {
                return new rh(t.parent.parent, t.parent.index)
            }
            const e = t.parent.data.slice(t.offset);
            t.parent._data = t.parent.data.slice(0, t.offset);
            t.parent.parent._insertChild(t.parent.index + 1, new Zc(t.root.document, e));
            return new rh(t.parent.parent, t.parent.index + 1)
        }

        function Nh(t, e) {
            const n = t.data.length;
            t._data += e.data;
            e._remove();
            return new rh(t, n)
        }

        const Mh = [Zc, _h, Xu, vh, Th, xh];

        function Hh(t, e) {
            for (const n of t) {
                if (!Mh.some((t => n instanceof t))) {
                    throw new P("view-writer-insert-invalid-node-type", e)
                }
                if (!n.is("$text")) {
                    Hh(n.getChildren(), e)
                }
            }
        }

        function Wh(t) {
            return t && (t.is("containerElement") || t.is("documentFragment"))
        }

        function qh(t, e) {
            const n = Vh(t.start);
            const i = Vh(t.end);
            if (!n || !i || n !== i) {
                throw new P("view-writer-invalid-range-container", e)
            }
        }

        function jh(t, e) {
            return t.id === null && e.id === null
        }

        const $h = t => t.createTextNode(" ");
        const Uh = t => {
            const e = t.createElement("span");
            e.dataset.ckeFiller = "true";
            e.innerText = " ";
            return e
        };
        const Gh = t => {
            const e = t.createElement("br");
            e.dataset.ckeFiller = "true";
            return e
        };
        const Kh = 7;
        const Zh = "⁠".repeat(Kh);

        function Jh(t) {
            return nl(t) && t.data.substr(0, Kh) === Zh
        }

        function Yh(t) {
            return t.data.length == Kh && Jh(t)
        }

        function Qh(t) {
            if (Jh(t)) {
                return t.data.slice(Kh)
            } else {
                return t.data
            }
        }

        function Xh(t) {
            t.document.on("arrowKey", tf, {priority: "low"})
        }

        function tf(t, e) {
            if (e.keyCode == Ol.arrowleft) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                    const e = t.getRangeAt(0).startContainer;
                    const n = t.getRangeAt(0).startOffset;
                    if (Jh(e) && n <= Kh) {
                        t.collapse(e, 0)
                    }
                }
            }
        }

        var ef = n(4401);
        var nf = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        nf.insert = "head";
        nf.singleton = true;
        var of = Bc()(ef.Z, nf);
        const rf = ef.Z.locals || {};

        class sf extends (dt()) {
            constructor(t, e) {
                super();
                this.domDocuments = new Set;
                this.domConverter = t;
                this.markedAttributes = new Set;
                this.markedChildren = new Set;
                this.markedTexts = new Set;
                this.selection = e;
                this.set("isFocused", false);
                this.set("_isFocusChanging", false);
                this.set("isSelecting", false);
                if (r.isBlink && !r.isAndroid) {
                    this.on("change:isSelecting", (() => {
                        if (!this.isSelecting) {
                            this.render()
                        }
                    }))
                }
                this.set("isComposing", false);
                this.on("change:isComposing", (() => {
                    if (!this.isComposing) {
                        this.render()
                    }
                }));
                this._inlineFiller = null;
                this._fakeSelectionContainer = null
            }

            markToSync(t, e) {
                if (t === "text") {
                    if (this.domConverter.mapViewToDom(e.parent)) {
                        this.markedTexts.add(e)
                    }
                } else {
                    if (!this.domConverter.mapViewToDom(e)) {
                        return
                    }
                    if (t === "attributes") {
                        this.markedAttributes.add(e)
                    } else if (t === "children") {
                        this.markedChildren.add(e)
                    } else {
                        throw new P("view-renderer-unknown-type", this)
                    }
                }
            }

            render() {
                if (this.isComposing && !r.isAndroid) {
                    return
                }
                let t = null;
                const e = r.isBlink && !r.isAndroid ? !this.isSelecting : true;
                for (const t of this.markedChildren) {
                    this._updateChildrenMappings(t)
                }
                if (e) {
                    if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
                        this._removeInlineFiller()
                    }
                    if (this._inlineFiller) {
                        t = this._getInlineFillerPosition()
                    } else if (this._needsInlineFillerAtSelection()) {
                        t = this.selection.getFirstPosition();
                        this.markedChildren.add(t.parent)
                    }
                } else if (this._inlineFiller && this._inlineFiller.parentNode) {
                    t = this.domConverter.domPositionToView(this._inlineFiller);
                    if (t && t.parent.is("$text")) {
                        t = rh._createBefore(t.parent)
                    }
                }
                for (const t of this.markedAttributes) {
                    this._updateAttrs(t)
                }
                for (const e of this.markedChildren) {
                    this._updateChildren(e, {inlineFillerPosition: t})
                }
                for (const e of this.markedTexts) {
                    if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
                        this._updateText(e, {inlineFillerPosition: t})
                    }
                }
                if (e) {
                    if (t) {
                        const e = this.domConverter.viewPositionToDom(t);
                        const n = e.parent.ownerDocument;
                        if (!Jh(e.parent)) {
                            this._inlineFiller = lf(n, e.parent, e.offset)
                        } else {
                            this._inlineFiller = e.parent
                        }
                    } else {
                        this._inlineFiller = null
                    }
                }
                this._updateFocus();
                this._updateSelection();
                this.markedTexts.clear();
                this.markedAttributes.clear();
                this.markedChildren.clear()
            }

            _updateChildrenMappings(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = Array.from(this.domConverter.mapViewToDom(t).childNodes);
                const i = Array.from(this.domConverter.viewChildrenToDom(t, {withChildren: false}));
                const o = this._diffNodeLists(n, i);
                const r = this._findReplaceActions(o, n, i);
                if (r.indexOf("replace") !== -1) {
                    const e = {equal: 0, insert: 0, delete: 0};
                    for (const o of r) {
                        if (o === "replace") {
                            const o = e.equal + e.insert;
                            const r = e.equal + e.delete;
                            const s = t.getChild(o);
                            if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                                this._updateElementMappings(s, n[r])
                            }
                            yl(i[o]);
                            e.equal++
                        } else {
                            e[o]++
                        }
                    }
                }
            }

            _updateElementMappings(t, e) {
                this.domConverter.unbindDomElement(e);
                this.domConverter.bindElements(e, t);
                this.markedChildren.add(t);
                this.markedAttributes.add(t)
            }

            _getInlineFillerPosition() {
                const t = this.selection.getFirstPosition();
                if (t.parent.is("$text")) {
                    return rh._createBefore(t.parent)
                } else {
                    return t
                }
            }

            _isSelectionInInlineFiller() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = this.domConverter.viewPositionToDom(t);
                if (e && nl(e.parent) && Jh(e.parent)) {
                    return true
                }
                return false
            }

            _removeInlineFiller() {
                const t = this._inlineFiller;
                if (!Jh(t)) {
                    throw new P("view-renderer-filler-was-lost", this)
                }
                if (Yh(t)) {
                    t.remove()
                } else {
                    t.data = t.data.substr(Kh)
                }
                this._inlineFiller = null
            }

            _needsInlineFillerAtSelection() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = t.parent;
                const n = t.offset;
                if (!this.domConverter.mapViewToDom(e.root)) {
                    return false
                }
                if (!e.is("element")) {
                    return false
                }
                if (!af(e)) {
                    return false
                }
                if (n === e.getFillerOffset()) {
                    return false
                }
                const i = t.nodeBefore;
                const o = t.nodeAfter;
                if (i instanceof Zc || o instanceof Zc) {
                    return false
                }
                if (r.isAndroid && (i || o)) {
                    return false
                }
                return true
            }

            _updateText(t, e) {
                const n = this.domConverter.findCorrespondingDomText(t);
                const i = this.domConverter.viewToDom(t);
                let o = i.data;
                const r = e.inlineFillerPosition;
                if (r && r.parent == t.parent && r.offset == t.index) {
                    o = Zh + o
                }
                mf(n, o)
            }

            _updateAttrs(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = Array.from(e.attributes).map((t => t.name));
                const i = t.getAttributeKeys();
                for (const n of i) {
                    this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t)
                }
                for (const i of n) {
                    if (!t.hasAttribute(i)) {
                        this.domConverter.removeDomElementAttribute(e, i)
                    }
                }
            }

            _updateChildren(t, e) {
                const n = this.domConverter.mapViewToDom(t);
                if (!n) {
                    return
                }
                if (r.isAndroid) {
                    let t = null;
                    for (const e of Array.from(n.childNodes)) {
                        if (t && nl(t) && nl(e)) {
                            n.normalize();
                            break
                        }
                        t = e
                    }
                }
                const i = e.inlineFillerPosition;
                const o = n.childNodes;
                const s = Array.from(this.domConverter.viewChildrenToDom(t, {bind: true}));
                if (i && i.parent === t) {
                    lf(n.ownerDocument, s, i.offset)
                }
                const a = this._diffNodeLists(o, s);
                const l = r.isAndroid ? this._findReplaceActions(a, o, s, {replaceText: true}) : a;
                let c = 0;
                const d = new Set;
                for (const t of l) {
                    if (t === "delete") {
                        d.add(o[c]);
                        yl(o[c])
                    } else if (t === "equal" || t === "replace") {
                        c++
                    }
                }
                c = 0;
                for (const t of l) {
                    if (t === "insert") {
                        gl(n, c, s[c]);
                        c++
                    } else if (t === "replace") {
                        mf(o[c], s[c].data);
                        c++
                    } else if (t === "equal") {
                        this._markDescendantTextToSync(this.domConverter.domToView(s[c]));
                        c++
                    }
                }
                for (const t of d) {
                    if (!t.parentNode) {
                        this.domConverter.unbindDomElement(t)
                    }
                }
            }

            _diffNodeLists(t, e) {
                t = ff(t, this._fakeSelectionContainer);
                return _(t, e, uf.bind(null, this.domConverter))
            }

            _findReplaceActions(t, e, n, i = {}) {
                if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
                    return t
                }
                let o = [];
                let r = [];
                let s = [];
                const a = {equal: 0, insert: 0, delete: 0};
                for (const l of t) {
                    if (l === "insert") {
                        s.push(n[a.equal + a.insert])
                    } else if (l === "delete") {
                        r.push(e[a.equal + a.delete])
                    } else {
                        o = o.concat(_(r, s, i.replaceText ? df : cf).map((t => t === "equal" ? "replace" : t)));
                        o.push("equal");
                        r = [];
                        s = []
                    }
                    a[l]++
                }
                return o.concat(_(r, s, i.replaceText ? df : cf).map((t => t === "equal" ? "replace" : t)))
            }

            _markDescendantTextToSync(t) {
                if (!t) {
                    return
                }
                if (t.is("$text")) {
                    this.markedTexts.add(t)
                } else if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._markDescendantTextToSync(e)
                    }
                }
            }

            _updateSelection() {
                if (r.isBlink && !r.isAndroid && this.isSelecting && !this.markedChildren.size) {
                    return
                }
                if (this._isFocusChanging) {
                    return
                }
                if (this.selection.rangeCount === 0) {
                    this._removeDomSelection();
                    this._removeFakeSelection();
                    return
                }
                const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                if (!this.isFocused || !t) {
                    return
                }
                if (this.selection.isFake) {
                    this._updateFakeSelection(t)
                } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
                    this._removeFakeSelection();
                    this._updateDomSelection(t)
                } else if (!(this.isComposing && r.isAndroid)) {
                    this._updateDomSelection(t)
                }
            }

            _updateFakeSelection(t) {
                const e = t.ownerDocument;
                if (!this._fakeSelectionContainer) {
                    this._fakeSelectionContainer = gf(e)
                }
                const n = this._fakeSelectionContainer;
                this.domConverter.bindFakeSelection(n, this.selection);
                if (!this._fakeSelectionNeedsUpdate(t)) {
                    return
                }
                if (!n.parentElement || n.parentElement != t) {
                    t.appendChild(n)
                }
                n.textContent = this.selection.fakeSelectionLabel || " ";
                const i = e.getSelection();
                const o = e.createRange();
                i.removeAllRanges();
                o.selectNodeContents(n);
                i.addRange(o)
            }

            _updateDomSelection(t) {
                const e = t.ownerDocument.defaultView.getSelection();
                if (!this._domSelectionNeedsUpdate(e)) {
                    return
                }
                const n = this.domConverter.viewPositionToDom(this.selection.anchor);
                const i = this.domConverter.viewPositionToDom(this.selection.focus);
                e.collapse(n.parent, n.offset);
                e.extend(i.parent, i.offset);
                if (r.isGecko) {
                    hf(i, e)
                }
            }

            _domSelectionNeedsUpdate(t) {
                if (!this.domConverter.isDomSelectionCorrect(t)) {
                    return true
                }
                const e = t && this.domConverter.domSelectionToView(t);
                if (e && this.selection.isEqual(e)) {
                    return false
                }
                if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
                    return false
                }
                return true
            }

            _fakeSelectionNeedsUpdate(t) {
                const e = this._fakeSelectionContainer;
                const n = t.ownerDocument.getSelection();
                if (!e || e.parentElement !== t) {
                    return true
                }
                if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
                    return true
                }
                return e.textContent !== this.selection.fakeSelectionLabel
            }

            _removeDomSelection() {
                for (const t of this.domDocuments) {
                    const e = t.getSelection();
                    if (e.rangeCount) {
                        const n = t.activeElement;
                        const i = this.domConverter.mapDomToView(n);
                        if (n && i) {
                            e.removeAllRanges()
                        }
                    }
                }
            }

            _removeFakeSelection() {
                const t = this._fakeSelectionContainer;
                if (t) {
                    t.remove()
                }
            }

            _updateFocus() {
                if (this.isFocused) {
                    const t = this.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t)
                    }
                }
            }
        }

        function af(t) {
            if (t.getAttribute("contenteditable") == "false") {
                return false
            }
            const e = t.findAncestor((t => t.hasAttribute("contenteditable")));
            return !e || e.getAttribute("contenteditable") == "true"
        }

        function lf(t, e, n) {
            const i = e instanceof Array ? e : e.childNodes;
            const o = i[n];
            if (nl(o)) {
                o.data = Zh + o.data;
                return o
            } else {
                const o = t.createTextNode(Zh);
                if (Array.isArray(e)) {
                    i.splice(n, 0, o)
                } else {
                    gl(e, n, o)
                }
                return o
            }
        }

        function cf(t, e) {
            return $a(t) && $a(e) && !nl(t) && !nl(e) && !ml(t) && !ml(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase()
        }

        function df(t, e) {
            return $a(t) && $a(e) && nl(t) && nl(e)
        }

        function uf(t, e, n) {
            if (e === n) {
                return true
            } else if (nl(e) && nl(n)) {
                return e.data === n.data
            } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
                return true
            }
            return false
        }

        function hf(t, e) {
            const n = t.parent;
            if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
                return
            }
            const i = n.childNodes[t.offset];
            if (i && i.tagName == "BR") {
                e.addRange(e.getRangeAt(0))
            }
        }

        function ff(t, e) {
            const n = Array.from(t);
            if (n.length == 0 || !e) {
                return n
            }
            const i = n[n.length - 1];
            if (i == e) {
                n.pop()
            }
            return n
        }

        function gf(t) {
            const e = t.createElement("div");
            e.className = "ck-fake-selection-container";
            Object.assign(e.style, {position: "fixed", top: 0, left: "-9999px", width: "42px"});
            e.textContent = " ";
            return e
        }

        function mf(t, e) {
            const n = t.data;
            if (n == e) {
                return
            }
            const i = g(n, e);
            for (const e of i) {
                if (e.type === "insert") {
                    t.insertData(e.index, e.values.join(""))
                } else {
                    t.deleteData(e.index, e.howMany)
                }
            }
        }

        const pf = Gh(Xa.document);
        const bf = $h(Xa.document);
        const kf = Uh(Xa.document);
        const wf = "data-ck-unsafe-attribute-";
        const _f = "data-ck-unsafe-element";

        class Af {
            constructor(t, e = {}) {
                this.document = t;
                this.renderingMode = e.renderingMode || "editing";
                this.blockFillerMode = e.blockFillerMode || (this.renderingMode === "editing" ? "br" : "nbsp");
                this.preElements = ["pre"];
                this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"];
                this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"];
                this.unsafeElements = ["script", "style"];
                this._domDocument = this.renderingMode === "editing" ? Xa.document : Xa.document.implementation.createHTMLDocument("");
                this._domToViewMapping = new WeakMap;
                this._viewToDomMapping = new WeakMap;
                this._fakeSelectionMapping = new WeakMap;
                this._rawContentElementMatcher = new Yc;
                this._encounteredRawContentDomNodes = new WeakSet
            }

            bindFakeSelection(t, e) {
                this._fakeSelectionMapping.set(t, new lh(e))
            }

            fakeSelectionToView(t) {
                return this._fakeSelectionMapping.get(t)
            }

            bindElements(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }

            unbindDomElement(t) {
                const e = this._domToViewMapping.get(t);
                if (e) {
                    this._domToViewMapping.delete(t);
                    this._viewToDomMapping.delete(e);
                    for (const e of Array.from(t.children)) {
                        this.unbindDomElement(e)
                    }
                }
            }

            bindDocumentFragments(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }

            shouldRenderAttribute(t, e, n) {
                if (this.renderingMode === "data") {
                    return true
                }
                t = t.toLowerCase();
                if (t.startsWith("on")) {
                    return false
                }
                if (t === "srcdoc" && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
                    return false
                }
                if (n === "img" && (t === "src" || t === "srcset")) {
                    return true
                }
                if (n === "source" && t === "srcset") {
                    return true
                }
                if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
                    return false
                }
                return true
            }

            setContentOf(t, e) {
                if (this.renderingMode === "data") {
                    t.innerHTML = e;
                    return
                }
                const n = (new DOMParser).parseFromString(e, "text/html");
                const i = n.createDocumentFragment();
                const o = n.body.childNodes;
                while (o.length > 0) {
                    i.appendChild(o[0])
                }
                const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT);
                const s = [];
                let a;
                while (a = r.nextNode()) {
                    s.push(a)
                }
                for (const t of s) {
                    for (const e of t.getAttributeNames()) {
                        this.setDomElementAttribute(t, e, t.getAttribute(e))
                    }
                    const e = t.tagName.toLowerCase();
                    if (this._shouldRenameElement(e)) {
                        Ef(e);
                        t.replaceWith(this._createReplacementDomElement(e, t))
                    }
                }
                while (t.firstChild) {
                    t.firstChild.remove()
                }
                t.append(i)
            }

            viewToDom(t, e = {}) {
                if (t.is("$text")) {
                    const e = this._processDataFromViewText(t);
                    return this._domDocument.createTextNode(e)
                } else {
                    if (this.mapViewToDom(t)) {
                        return this.mapViewToDom(t)
                    }
                    let n;
                    if (t.is("documentFragment")) {
                        n = this._domDocument.createDocumentFragment();
                        if (e.bind) {
                            this.bindDocumentFragments(n, t)
                        }
                    } else if (t.is("uiElement")) {
                        if (t.name === "$comment") {
                            n = this._domDocument.createComment(t.getCustomProperty("$rawContent"))
                        } else {
                            n = t.render(this._domDocument, this)
                        }
                        if (e.bind) {
                            this.bindElements(n, t)
                        }
                        return n
                    } else {
                        if (this._shouldRenameElement(t.name)) {
                            Ef(t.name);
                            n = this._createReplacementDomElement(t.name)
                        } else if (t.hasAttribute("xmlns")) {
                            n = this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name)
                        } else {
                            n = this._domDocument.createElement(t.name)
                        }
                        if (t.is("rawElement")) {
                            t.render(n, this)
                        }
                        if (e.bind) {
                            this.bindElements(n, t)
                        }
                        for (const e of t.getAttributeKeys()) {
                            this.setDomElementAttribute(n, e, t.getAttribute(e), t)
                        }
                    }
                    if (e.withChildren !== false) {
                        for (const i of this.viewChildrenToDom(t, e)) {
                            n.appendChild(i)
                        }
                    }
                    return n
                }
            }

            setDomElementAttribute(t, e, n, i) {
                const o = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(e);
                if (!o) {
                    I("domconverter-unsafe-attribute-detected", {domElement: t, key: e, value: n})
                }
                if (t.hasAttribute(e) && !o) {
                    t.removeAttribute(e)
                } else if (t.hasAttribute(wf + e) && o) {
                    t.removeAttribute(wf + e)
                }
                t.setAttribute(o ? e : wf + e, n)
            }

            removeDomElementAttribute(t, e) {
                if (e == _f) {
                    return
                }
                t.removeAttribute(e);
                t.removeAttribute(wf + e)
            }

            * viewChildrenToDom(t, e = {}) {
                const n = t.getFillerOffset && t.getFillerOffset();
                let i = 0;
                for (const o of t.getChildren()) {
                    if (n === i) {
                        yield this._getBlockFiller()
                    }
                    const t = o.is("element") && o.getCustomProperty("dataPipeline:transparentRendering");
                    if (t && this.renderingMode == "data") {
                        yield* this.viewChildrenToDom(o, e)
                    } else {
                        if (t) {
                            I("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {viewElement: o})
                        }
                        yield this.viewToDom(o, e)
                    }
                    i++
                }
                if (n === i) {
                    yield this._getBlockFiller()
                }
            }

            viewRangeToDom(t) {
                const e = this.viewPositionToDom(t.start);
                const n = this.viewPositionToDom(t.end);
                const i = this._domDocument.createRange();
                i.setStart(e.parent, e.offset);
                i.setEnd(n.parent, n.offset);
                return i
            }

            viewPositionToDom(t) {
                const e = t.parent;
                if (e.is("$text")) {
                    const n = this.findCorrespondingDomText(e);
                    if (!n) {
                        return null
                    }
                    let i = t.offset;
                    if (Jh(n)) {
                        i += Kh
                    }
                    return {parent: n, offset: i}
                } else {
                    let n, i, o;
                    if (t.offset === 0) {
                        n = this.mapViewToDom(e);
                        if (!n) {
                            return null
                        }
                        o = n.childNodes[0]
                    } else {
                        const e = t.nodeBefore;
                        i = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e);
                        if (!i) {
                            return null
                        }
                        n = i.parentNode;
                        o = i.nextSibling
                    }
                    if (nl(o) && Jh(o)) {
                        return {parent: o, offset: Kh}
                    }
                    const r = i ? fl(i) + 1 : 0;
                    return {parent: n, offset: r}
                }
            }

            domToView(t, e = {}) {
                if (this.isBlockFiller(t)) {
                    return null
                }
                const n = this.getHostViewElement(t);
                if (n) {
                    return n
                }
                if (ml(t) && e.skipComments) {
                    return null
                }
                if (nl(t)) {
                    if (Yh(t)) {
                        return null
                    } else {
                        const e = this._processDataFromDomText(t);
                        return e === "" ? null : new Zc(this.document, e)
                    }
                } else {
                    if (this.mapDomToView(t)) {
                        return this.mapDomToView(t)
                    }
                    let n;
                    if (this.isDocumentFragment(t)) {
                        n = new Ph(this.document);
                        if (e.bind) {
                            this.bindDocumentFragments(t, n)
                        }
                    } else {
                        n = this._createViewElement(t, e);
                        if (e.bind) {
                            this.bindElements(t, n)
                        }
                        const i = t.attributes;
                        if (i) {
                            for (let t = i.length, e = 0; e < t; e++) {
                                n._setAttribute(i[e].name, i[e].value)
                            }
                        }
                        if (this._isViewElementWithRawContent(n, e) || ml(t)) {
                            const e = ml(t) ? t.data : t.innerHTML;
                            n._setCustomProperty("$rawContent", e);
                            this._encounteredRawContentDomNodes.add(t);
                            return n
                        }
                    }
                    if (e.withChildren !== false) {
                        for (const i of this.domChildrenToView(t, e)) {
                            n._appendChild(i)
                        }
                    }
                    return n
                }
            }

            * domChildrenToView(t, e) {
                for (let n = 0; n < t.childNodes.length; n++) {
                    const i = t.childNodes[n];
                    const o = this.domToView(i, e);
                    if (o !== null) {
                        yield o
                    }
                }
            }

            domSelectionToView(t) {
                if (t.rangeCount === 1) {
                    let e = t.getRangeAt(0).startContainer;
                    if (nl(e)) {
                        e = e.parentNode
                    }
                    const n = this.fakeSelectionToView(e);
                    if (n) {
                        return n
                    }
                }
                const e = this.isDomSelectionBackward(t);
                const n = [];
                for (let e = 0; e < t.rangeCount; e++) {
                    const i = t.getRangeAt(e);
                    const o = this.domRangeToView(i);
                    if (o) {
                        n.push(o)
                    }
                }
                return new lh(n, {backward: e})
            }

            domRangeToView(t) {
                const e = this.domPositionToView(t.startContainer, t.startOffset);
                const n = this.domPositionToView(t.endContainer, t.endOffset);
                if (e && n) {
                    return new sh(e, n)
                }
                return null
            }

            domPositionToView(t, e = 0) {
                if (this.isBlockFiller(t)) {
                    return this.domPositionToView(t.parentNode, fl(t))
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return rh._createBefore(n)
                }
                if (nl(t)) {
                    if (Yh(t)) {
                        return this.domPositionToView(t.parentNode, fl(t))
                    }
                    const n = this.findCorrespondingViewText(t);
                    let i = e;
                    if (!n) {
                        return null
                    }
                    if (Jh(t)) {
                        i -= Kh;
                        i = i < 0 ? 0 : i
                    }
                    return new rh(n, i)
                } else {
                    if (e === 0) {
                        const e = this.mapDomToView(t);
                        if (e) {
                            return new rh(e, 0)
                        }
                    } else {
                        const n = t.childNodes[e - 1];
                        if (nl(n) && Yh(n)) {
                            return this.domPositionToView(n.parentNode, fl(n))
                        }
                        const i = nl(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                        if (i && i.parent) {
                            return new rh(i.parent, i.index + 1)
                        }
                    }
                    return null
                }
            }

            mapDomToView(t) {
                const e = this.getHostViewElement(t);
                return e || this._domToViewMapping.get(t)
            }

            findCorrespondingViewText(t) {
                if (Yh(t)) {
                    return null
                }
                const e = this.getHostViewElement(t);
                if (e) {
                    return e
                }
                const n = t.previousSibling;
                if (n) {
                    if (!this.isElement(n)) {
                        return null
                    }
                    const t = this.mapDomToView(n);
                    if (t) {
                        const e = t.nextSibling;
                        if (e instanceof Zc) {
                            return e
                        } else {
                            return null
                        }
                    }
                } else {
                    const e = this.mapDomToView(t.parentNode);
                    if (e) {
                        const t = e.getChild(0);
                        if (t instanceof Zc) {
                            return t
                        } else {
                            return null
                        }
                    }
                }
                return null
            }

            mapViewToDom(t) {
                return this._viewToDomMapping.get(t)
            }

            findCorrespondingDomText(t) {
                const e = t.previousSibling;
                if (e && this.mapViewToDom(e)) {
                    return this.mapViewToDom(e).nextSibling
                }
                if (!e && t.parent && this.mapViewToDom(t.parent)) {
                    return this.mapViewToDom(t.parent).childNodes[0]
                }
                return null
            }

            focus(t) {
                const e = this.mapViewToDom(t);
                if (e && e.ownerDocument.activeElement !== e) {
                    const {scrollX: t, scrollY: n} = Xa.window;
                    const i = [];
                    vf(e, (t => {
                        const {scrollLeft: e, scrollTop: n} = t;
                        i.push([e, n])
                    }));
                    e.focus();
                    vf(e, (t => {
                        const [e, n] = i.shift();
                        t.scrollLeft = e;
                        t.scrollTop = n
                    }));
                    Xa.window.scrollTo(t, n)
                }
            }

            isElement(t) {
                return t && t.nodeType == Node.ELEMENT_NODE
            }

            isDocumentFragment(t) {
                return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
            }

            isBlockFiller(t) {
                if (this.blockFillerMode == "br") {
                    return t.isEqualNode(pf)
                }
                if (t.tagName === "BR" && xf(t, this.blockElements) && t.parentNode.childNodes.length === 1) {
                    return true
                }
                return t.isEqualNode(kf) || yf(t, this.blockElements)
            }

            isDomSelectionBackward(t) {
                if (t.isCollapsed) {
                    return false
                }
                const e = this._domDocument.createRange();
                try {
                    e.setStart(t.anchorNode, t.anchorOffset);
                    e.setEnd(t.focusNode, t.focusOffset)
                } catch (t) {
                    return false
                }
                const n = e.collapsed;
                e.detach();
                return n
            }

            getHostViewElement(t) {
                const e = tl(t);
                e.pop();
                while (e.length) {
                    const t = e.pop();
                    const n = this._domToViewMapping.get(t);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) {
                        return n
                    }
                }
                return null
            }

            isDomSelectionCorrect(t) {
                return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            }

            registerRawContentMatcher(t) {
                this._rawContentElementMatcher.add(t)
            }

            _getBlockFiller() {
                switch (this.blockFillerMode) {
                    case"nbsp":
                        return $h(this._domDocument);
                    case"markedNbsp":
                        return Uh(this._domDocument);
                    case"br":
                        return Gh(this._domDocument)
                }
            }

            _isDomSelectionPositionCorrect(t, e) {
                if (nl(t) && Jh(t) && e < Kh) {
                    return false
                }
                if (this.isElement(t) && Jh(t.childNodes[e])) {
                    return false
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return false
                }
                return true
            }

            _processDataFromViewText(t) {
                let e = t.data;
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return e
                }
                if (e.charAt(0) == " ") {
                    const n = this._getTouchingInlineViewNode(t, false);
                    const i = n && n.is("$textProxy") && this._nodeEndsWithSpace(n);
                    if (i || !n) {
                        e = " " + e.substr(1)
                    }
                }
                if (e.charAt(e.length - 1) == " ") {
                    const n = this._getTouchingInlineViewNode(t, true);
                    const i = n && n.is("$textProxy") && n.data.charAt(0) == " ";
                    if (e.charAt(e.length - 2) == " " || !n || i) {
                        e = e.substr(0, e.length - 1) + " "
                    }
                }
                return e.replace(/ {2}/g, "  ")
            }

            _nodeEndsWithSpace(t) {
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return false
                }
                const e = this._processDataFromViewText(t);
                return e.charAt(e.length - 1) == " "
            }

            _processDataFromDomText(t) {
                let e = t.data;
                if (Cf(t, this.preElements)) {
                    return Qh(t)
                }
                e = e.replace(/[ \n\t\r]{1,}/g, " ");
                const n = this._getTouchingInlineDomNode(t, false);
                const i = this._getTouchingInlineDomNode(t, true);
                const o = this._checkShouldLeftTrimDomText(t, n);
                const r = this._checkShouldRightTrimDomText(t, i);
                if (o) {
                    e = e.replace(/^ /, "")
                }
                if (r) {
                    e = e.replace(/ $/, "")
                }
                e = Qh(new Text(e));
                e = e.replace(/ \u00A0/g, "  ");
                const s = i && this.isElement(i) && i.tagName != "BR";
                const a = i && nl(i) && i.data.charAt(0) == " ";
                if (/( |\u00A0)\u00A0$/.test(e) || !i || s || a) {
                    e = e.replace(/\u00A0$/, " ")
                }
                if (o || n && this.isElement(n) && n.tagName != "BR") {
                    e = e.replace(/^\u00A0/, " ")
                }
                return e
            }

            _checkShouldLeftTrimDomText(t, e) {
                if (!e) {
                    return true
                }
                if (this.isElement(e)) {
                    return e.tagName === "BR"
                }
                if (this._encounteredRawContentDomNodes.has(t.previousSibling)) {
                    return false
                }
                return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1))
            }

            _checkShouldRightTrimDomText(t, e) {
                if (e) {
                    return false
                }
                return !Jh(t)
            }

            _getTouchingInlineViewNode(t, e) {
                const n = new oh({
                    startPosition: e ? rh._createAfter(t) : rh._createBefore(t),
                    direction: e ? "forward" : "backward"
                });
                for (const t of n) {
                    if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) {
                        return t.item
                    } else if (t.item.is("containerElement")) {
                        return null
                    } else if (t.item.is("element", "br")) {
                        return null
                    } else if (t.item.is("$textProxy")) {
                        return t.item
                    }
                }
                return null
            }

            _getTouchingInlineDomNode(t, e) {
                if (!t.parentNode) {
                    return null
                }
                const n = e ? "firstChild" : "lastChild";
                const i = e ? "nextSibling" : "previousSibling";
                let o = true;
                let r = t;
                do {
                    if (!o && r[n]) {
                        r = r[n]
                    } else if (r[i]) {
                        r = r[i];
                        o = false
                    } else {
                        r = r.parentNode;
                        o = true
                    }
                    if (!r || this._isBlockElement(r)) {
                        return null
                    }
                } while (!(nl(r) || r.tagName == "BR" || this._isInlineObjectElement(r)));
                return r
            }

            _isBlockElement(t) {
                return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase())
            }

            _isInlineObjectElement(t) {
                return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase())
            }

            _createViewElement(t, e) {
                if (ml(t)) {
                    return new xh(this.document, "$comment")
                }
                const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                return new Zu(this.document, n)
            }

            _isViewElementWithRawContent(t, e) {
                return e.withChildren !== false && !!this._rawContentElementMatcher.match(t)
            }

            _shouldRenameElement(t) {
                const e = t.toLowerCase();
                return this.renderingMode === "editing" && this.unsafeElements.includes(e)
            }

            _createReplacementDomElement(t, e) {
                const n = this._domDocument.createElement("span");
                n.setAttribute(_f, t);
                if (e) {
                    while (e.firstChild) {
                        n.appendChild(e.firstChild)
                    }
                    for (const t of e.getAttributeNames()) {
                        n.setAttribute(t, e.getAttribute(t))
                    }
                }
                return n
            }
        }

        function Cf(t, e) {
            const n = tl(t);
            return n.some((t => t.tagName && e.includes(t.tagName.toLowerCase())))
        }

        function vf(t, e) {
            let n = t;
            while (n) {
                e(n);
                n = n.parentElement
            }
        }

        function yf(t, e) {
            const n = t.isEqualNode(bf);
            return n && xf(t, e) && t.parentNode.childNodes.length === 1
        }

        function xf(t, e) {
            const n = t.parentNode;
            return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
        }

        function Ef(t) {
            if (t === "script") {
                I("domconverter-unsafe-script-element-detected")
            }
            if (t === "style") {
                I("domconverter-unsafe-style-element-detected")
            }
        }

        class Sf extends (Ka()) {
            constructor(t) {
                super();
                this.view = t;
                this.document = t.document;
                this.isEnabled = false
            }

            enable() {
                this.isEnabled = true
            }

            disable() {
                this.isEnabled = false
            }

            destroy() {
                this.disable();
                this.stopListening()
            }

            checkShouldIgnoreEventFromTarget(t) {
                if (t && t.nodeType === 3) {
                    t = t.parentNode
                }
                if (!t || t.nodeType !== 1) {
                    return false
                }
                return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
            }
        }

        var Df = Lu((function (t, e) {
            gi(e, Qo(e), t)
        }));
        const Tf = Df;

        class Bf {
            constructor(t, e, n) {
                this.view = t;
                this.document = t.document;
                this.domEvent = e;
                this.domTarget = e.target;
                Tf(this, n)
            }

            get target() {
                return this.view.domConverter.mapDomToView(this.domTarget)
            }

            preventDefault() {
                this.domEvent.preventDefault()
            }

            stopPropagation() {
                this.domEvent.stopPropagation()
            }
        }

        class Pf extends Sf {
            constructor(t) {
                super(t);
                this.useCapture = false
            }

            observe(t) {
                const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
                e.forEach((e => {
                    this.listenTo(t, e, ((t, e) => {
                        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                            this.onDomEvent(e)
                        }
                    }), {useCapture: this.useCapture})
                }))
            }

            fire(t, e, n) {
                if (this.isEnabled) {
                    this.document.fire(t, new Bf(this.view, e, n))
                }
            }
        }

        class If extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["keydown", "keyup"]
            }

            onDomEvent(t) {
                const e = {
                    keyCode: t.keyCode,
                    altKey: t.altKey,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    metaKey: t.metaKey,
                    get keystroke() {
                        return Ml(this)
                    }
                };
                this.fire(t.type, t, e)
            }
        }

        var Rf = function () {
            return Tt.Date.now()
        };
        const zf = Rf;
        var Vf = /\s/;

        function Ff(t) {
            var e = t.length;
            while (e-- && Vf.test(t.charAt(e))) {
            }
            return e
        }

        const Lf = Ff;
        var Of = /^\s+/;

        function Nf(t) {
            return t ? t.slice(0, Lf(t) + 1).replace(Of, "") : t
        }

        const Mf = Nf;
        var Hf = 0 / 0;
        var Wf = /^[-+]0x[0-9a-f]+$/i;
        var qf = /^0b[01]+$/i;
        var jf = /^0o[0-7]+$/i;
        var $f = parseInt;

        function Uf(t) {
            if (typeof t == "number") {
                return t
            }
            if (cd(t)) {
                return Hf
            }
            if (it(t)) {
                var e = typeof t.valueOf == "function" ? t.valueOf() : t;
                t = it(e) ? e + "" : e
            }
            if (typeof t != "string") {
                return t === 0 ? t : +t
            }
            t = Mf(t);
            var n = qf.test(t);
            return n || jf.test(t) ? $f(t.slice(2), n ? 2 : 8) : Wf.test(t) ? Hf : +t
        }

        const Gf = Uf;
        var Kf = "Expected a function";
        var Zf = Math.max, Jf = Math.min;

        function Yf(t, e, n) {
            var i, o, r, s, a, l, c = 0, d = false, u = false, h = true;
            if (typeof t != "function") {
                throw new TypeError(Kf)
            }
            e = Gf(e) || 0;
            if (it(n)) {
                d = !!n.leading;
                u = "maxWait" in n;
                r = u ? Zf(Gf(n.maxWait) || 0, e) : r;
                h = "trailing" in n ? !!n.trailing : h
            }

            function f(e) {
                var n = i, r = o;
                i = o = undefined;
                c = e;
                s = t.apply(r, n);
                return s
            }

            function g(t) {
                c = t;
                a = setTimeout(b, e);
                return d ? f(t) : s
            }

            function m(t) {
                var n = t - l, i = t - c, o = e - n;
                return u ? Jf(o, r - i) : o
            }

            function p(t) {
                var n = t - l, i = t - c;
                return l === undefined || n >= e || n < 0 || u && i >= r
            }

            function b() {
                var t = zf();
                if (p(t)) {
                    return k(t)
                }
                a = setTimeout(b, m(t))
            }

            function k(t) {
                a = undefined;
                if (h && i) {
                    return f(t)
                }
                i = o = undefined;
                return s
            }

            function w() {
                if (a !== undefined) {
                    clearTimeout(a)
                }
                c = 0;
                i = l = o = a = undefined
            }

            function _() {
                return a === undefined ? s : k(zf())
            }

            function A() {
                var t = zf(), n = p(t);
                i = arguments;
                o = this;
                l = t;
                if (n) {
                    if (a === undefined) {
                        return g(l)
                    }
                    if (u) {
                        clearTimeout(a);
                        a = setTimeout(b, e);
                        return f(l)
                    }
                }
                if (a === undefined) {
                    a = setTimeout(b, e)
                }
                return s
            }

            A.cancel = w;
            A.flush = _;
            return A
        }

        const Qf = Yf;

        class Xf extends Sf {
            constructor(t) {
                super(t);
                this._fireSelectionChangeDoneDebounced = Qf((t => {
                    this.document.fire("selectionChangeDone", t)
                }), 200)
            }

            observe() {
                const t = this.document;
                t.on("arrowKey", ((e, n) => {
                    const i = t.selection;
                    if (i.isFake && this.isEnabled) {
                        n.preventDefault()
                    }
                }), {context: "$capture"});
                t.on("arrowKey", ((e, n) => {
                    const i = t.selection;
                    if (i.isFake && this.isEnabled) {
                        this._handleSelectionMove(n.keyCode)
                    }
                }), {priority: "lowest"})
            }

            destroy() {
                super.destroy();
                this._fireSelectionChangeDoneDebounced.cancel()
            }

            _handleSelectionMove(t) {
                const e = this.document.selection;
                const n = new lh(e.getRanges(), {backward: e.isBackward, fake: false});
                if (t == Ol.arrowleft || t == Ol.arrowup) {
                    n.setTo(n.getFirstPosition())
                }
                if (t == Ol.arrowright || t == Ol.arrowdown) {
                    n.setTo(n.getLastPosition())
                }
                const i = {oldSelection: e, newSelection: n, domSelection: null};
                this.document.fire("selectionChange", i);
                this._fireSelectionChangeDoneDebounced(i)
            }
        }

        var tg = "__lodash_hash_undefined__";

        function eg(t) {
            this.__data__.set(t, tg);
            return this
        }

        const ng = eg;

        function ig(t) {
            return this.__data__.has(t)
        }

        const og = ig;

        function rg(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.__data__ = new Yn;
            while (++e < n) {
                this.add(t[e])
            }
        }

        rg.prototype.add = rg.prototype.push = ng;
        rg.prototype.has = og;
        const sg = rg;

        function ag(t, e) {
            var n = -1, i = t == null ? 0 : t.length;
            while (++n < i) {
                if (e(t[n], n, t)) {
                    return true
                }
            }
            return false
        }

        const lg = ag;

        function cg(t, e) {
            return t.has(e)
        }

        const dg = cg;
        var ug = 1, hg = 2;

        function fg(t, e, n, i, o, r) {
            var s = n & ug, a = t.length, l = e.length;
            if (a != l && !(s && l > a)) {
                return false
            }
            var c = r.get(t);
            var d = r.get(e);
            if (c && d) {
                return c == e && d == t
            }
            var u = -1, h = true, f = n & hg ? new sg : undefined;
            r.set(t, e);
            r.set(e, t);
            while (++u < a) {
                var g = t[u], m = e[u];
                if (i) {
                    var p = s ? i(m, g, u, e, t, r) : i(g, m, u, t, e, r)
                }
                if (p !== undefined) {
                    if (p) {
                        continue
                    }
                    h = false;
                    break
                }
                if (f) {
                    if (!lg(e, (function (t, e) {
                        if (!dg(f, e) && (g === t || o(g, t, n, i, r))) {
                            return f.push(e)
                        }
                    }))) {
                        h = false;
                        break
                    }
                } else if (!(g === m || o(g, m, n, i, r))) {
                    h = false;
                    break
                }
            }
            r["delete"](t);
            r["delete"](e);
            return h
        }

        const gg = fg;

        function mg(t) {
            var e = -1, n = Array(t.size);
            t.forEach((function (t, i) {
                n[++e] = [i, t]
            }));
            return n
        }

        const pg = mg;

        function bg(t) {
            var e = -1, n = Array(t.size);
            t.forEach((function (t) {
                n[++e] = t
            }));
            return n
        }

        const kg = bg;
        var wg = 1, _g = 2;
        var Ag = "[object Boolean]", Cg = "[object Date]", vg = "[object Error]", yg = "[object Map]",
            xg = "[object Number]", Eg = "[object RegExp]", Sg = "[object Set]", Dg = "[object String]",
            Tg = "[object Symbol]";
        var Bg = "[object ArrayBuffer]", Pg = "[object DataView]";
        var Ig = Pt ? Pt.prototype : undefined, Rg = Ig ? Ig.valueOf : undefined;

        function zg(t, e, n, i, o, r, s) {
            switch (n) {
                case Pg:
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
                        return false
                    }
                    t = t.buffer;
                    e = e.buffer;
                case Bg:
                    if (t.byteLength != e.byteLength || !r(new ss(t), new ss(e))) {
                        return false
                    }
                    return true;
                case Ag:
                case Cg:
                case xg:
                    return pe(+t, +e);
                case vg:
                    return t.name == e.name && t.message == e.message;
                case Eg:
                case Dg:
                    return t == e + "";
                case yg:
                    var a = pg;
                case Sg:
                    var l = i & wg;
                    a || (a = kg);
                    if (t.size != e.size && !l) {
                        return false
                    }
                    var c = s.get(t);
                    if (c) {
                        return c == e
                    }
                    i |= _g;
                    s.set(t, e);
                    var d = gg(a(t), a(e), i, o, r, s);
                    s["delete"](t);
                    return d;
                case Tg:
                    if (Rg) {
                        return Rg.call(t) == Rg.call(e)
                    }
            }
            return false
        }

        const Vg = zg;
        var Fg = 1;
        var Lg = Object.prototype;
        var Og = Lg.hasOwnProperty;

        function Ng(t, e, n, i, o, r) {
            var s = n & Fg, a = Pr(t), l = a.length, c = Pr(e), d = c.length;
            if (l != d && !s) {
                return false
            }
            var u = l;
            while (u--) {
                var h = a[u];
                if (!(s ? h in e : Og.call(e, h))) {
                    return false
                }
            }
            var f = r.get(t);
            var g = r.get(e);
            if (f && g) {
                return f == e && g == t
            }
            var m = true;
            r.set(t, e);
            r.set(e, t);
            var p = s;
            while (++u < l) {
                h = a[u];
                var b = t[h], k = e[h];
                if (i) {
                    var w = s ? i(k, b, h, e, t, r) : i(b, k, h, t, e, r)
                }
                if (!(w === undefined ? b === k || o(b, k, n, i, r) : w)) {
                    m = false;
                    break
                }
                p || (p = h == "constructor")
            }
            if (m && !p) {
                var _ = t.constructor, A = e.constructor;
                if (_ != A && ("constructor" in t && "constructor" in e) && !(typeof _ == "function" && _ instanceof _ && typeof A == "function" && A instanceof A)) {
                    m = false
                }
            }
            r["delete"](t);
            r["delete"](e);
            return m
        }

        const Mg = Ng;
        var Hg = 1;
        var Wg = "[object Arguments]", qg = "[object Array]", jg = "[object Object]";
        var $g = Object.prototype;
        var Ug = $g.hasOwnProperty;

        function Gg(t, e, n, i, o, r) {
            var s = Kt(t), a = Kt(e), l = s ? qg : ts(t), c = a ? qg : ts(e);
            l = l == Wg ? jg : l;
            c = c == Wg ? jg : c;
            var d = l == jg, u = c == jg, h = l == c;
            if (h && Ri(t)) {
                if (!Ri(e)) {
                    return false
                }
                s = true;
                d = false
            }
            if (h && !d) {
                r || (r = new ni);
                return s || xo(t) ? gg(t, e, n, i, o, r) : Vg(t, e, l, n, i, o, r)
            }
            if (!(n & Hg)) {
                var f = d && Ug.call(t, "__wrapped__"), g = u && Ug.call(e, "__wrapped__");
                if (f || g) {
                    var m = f ? t.value() : t, p = g ? e.value() : e;
                    r || (r = new ni);
                    return o(m, p, n, i, r)
                }
            }
            if (!h) {
                return false
            }
            r || (r = new ni);
            return Mg(t, e, n, i, o, r)
        }

        const Kg = Gg;

        function Zg(t, e, n, i, o) {
            if (t === e) {
                return true
            }
            if (t == null || e == null || !Jt(t) && !Jt(e)) {
                return t !== t && e !== e
            }
            return Kg(t, e, n, i, Zg, o)
        }

        const Jg = Zg;

        function Yg(t, e, n) {
            n = typeof n == "function" ? n : undefined;
            var i = n ? n(t, e) : undefined;
            return i === undefined ? Jg(t, e, undefined, n) : !!i
        }

        const Qg = Yg;

        class Xg extends Sf {
            constructor(t) {
                super(t);
                this._config = {childList: true, characterData: true, subtree: true};
                this.domConverter = t.domConverter;
                this.renderer = t._renderer;
                this._domElements = [];
                this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
            }

            flush() {
                this._onMutations(this._mutationObserver.takeRecords())
            }

            observe(t) {
                this._domElements.push(t);
                if (this.isEnabled) {
                    this._mutationObserver.observe(t, this._config)
                }
            }

            enable() {
                super.enable();
                for (const t of this._domElements) {
                    this._mutationObserver.observe(t, this._config)
                }
            }

            disable() {
                super.disable();
                this._mutationObserver.disconnect()
            }

            destroy() {
                super.destroy();
                this._mutationObserver.disconnect()
            }

            _onMutations(t) {
                if (t.length === 0) {
                    return
                }
                const e = this.domConverter;
                const n = new Set;
                const i = new Set;
                for (const n of t) {
                    const t = e.mapDomToView(n.target);
                    if (!t) {
                        continue
                    }
                    if (t.is("uiElement") || t.is("rawElement")) {
                        continue
                    }
                    if (n.type === "childList" && !this._isBogusBrMutation(n)) {
                        i.add(t)
                    }
                }
                for (const o of t) {
                    const t = e.mapDomToView(o.target);
                    if (t && (t.is("uiElement") || t.is("rawElement"))) {
                        continue
                    }
                    if (o.type === "characterData") {
                        const t = e.findCorrespondingViewText(o.target);
                        if (t && !i.has(t.parent)) {
                            n.add(t)
                        } else if (!t && Jh(o.target)) {
                            i.add(e.mapDomToView(o.target.parentNode))
                        }
                    }
                }
                let o = false;
                for (const t of n) {
                    o = true;
                    this.renderer.markToSync("text", t)
                }
                for (const t of i) {
                    const n = e.mapViewToDom(t);
                    const i = Array.from(t.getChildren());
                    const r = Array.from(e.domChildrenToView(n, {withChildren: false}));
                    if (!Qg(i, r, tm)) {
                        o = true;
                        this.renderer.markToSync("children", t)
                    }
                }
                if (o) {
                    this.view.forceRender()
                }
            }

            _isBogusBrMutation(t) {
                let e = null;
                if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
                    e = this.domConverter.domToView(t.addedNodes[0], {withChildren: false})
                }
                return e && e.is("element", "br")
            }
        }

        function tm(t, e) {
            if (Array.isArray(t)) {
                return
            }
            if (t === e) {
                return true
            } else if (t.is("$text") && e.is("$text")) {
                return t.data === e.data
            }
            return false
        }

        class em extends Sf {
            constructor(t) {
                super(t);
                this.mutationObserver = t.getObserver(Xg);
                this.selection = this.document.selection;
                this.domConverter = t.domConverter;
                this._documents = new WeakSet;
                this._fireSelectionChangeDoneDebounced = Qf((t => {
                    this.document.fire("selectionChangeDone", t)
                }), 200);
                this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3);
                this._documentIsSelectingInactivityTimeoutDebounced = Qf((() => this.document.isSelecting = false), 5e3);
                this._loopbackCounter = 0
            }

            observe(t) {
                const e = t.ownerDocument;
                const n = () => {
                    this.document.isSelecting = true;
                    this._documentIsSelectingInactivityTimeoutDebounced()
                };
                const i = () => {
                    if (!this.document.isSelecting) {
                        return
                    }
                    this._handleSelectionChange(null, e);
                    this.document.isSelecting = false;
                    this._documentIsSelectingInactivityTimeoutDebounced.cancel()
                };
                this.listenTo(t, "selectstart", n, {priority: "highest"});
                this.listenTo(t, "keydown", i, {priority: "highest", useCapture: true});
                this.listenTo(t, "keyup", i, {priority: "highest", useCapture: true});
                if (this._documents.has(e)) {
                    return
                }
                this.listenTo(e, "mouseup", i, {priority: "highest", useCapture: true});
                this.listenTo(e, "selectionchange", ((t, n) => {
                    if (this.document.isComposing && !r.isAndroid) {
                        return
                    }
                    this._handleSelectionChange(n, e);
                    this._documentIsSelectingInactivityTimeoutDebounced()
                }));
                this._documents.add(e)
            }

            destroy() {
                super.destroy();
                clearInterval(this._clearInfiniteLoopInterval);
                this._fireSelectionChangeDoneDebounced.cancel();
                this._documentIsSelectingInactivityTimeoutDebounced.cancel()
            }

            _handleSelectionChange(t, e) {
                if (!this.isEnabled) {
                    return
                }
                const n = e.defaultView.getSelection();
                if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
                    return
                }
                this.mutationObserver.flush();
                const i = this.domConverter.domSelectionToView(n);
                if (i.rangeCount == 0) {
                    this.view.hasDomSelection = false;
                    return
                }
                this.view.hasDomSelection = true;
                if (this.selection.isEqual(i) && this.domConverter.isDomSelectionCorrect(n)) {
                    return
                }
                if (++this._loopbackCounter > 60) {
                    return
                }
                if (this.selection.isSimilar(i)) {
                    this.view.forceRender()
                } else {
                    const t = {oldSelection: this.selection, newSelection: i, domSelection: n};
                    this.document._isFocusChanging = false;
                    this.document.fire("selectionChange", t);
                    this._fireSelectionChangeDoneDebounced(t)
                }
            }

            _clearInfiniteLoop() {
                this._loopbackCounter = 0
            }
        }

        class nm extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["focus", "blur"];
                this.useCapture = true;
                const e = this.document;
                e.on("focus", (() => {
                    e.isFocused = true;
                    e._isFocusChanging = true;
                    this._renderTimeoutId = setTimeout((() => {
                        e._isFocusChanging = false;
                        t.change((() => {
                        }))
                    }), 50)
                }));
                e.on("blur", ((n, i) => {
                    const o = e.selection.editableElement;
                    if (o === null || o === i.target) {
                        e.isFocused = false;
                        t.change((() => {
                        }))
                    }
                }))
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }

            destroy() {
                if (this._renderTimeoutId) {
                    clearTimeout(this._renderTimeoutId)
                }
                super.destroy()
            }
        }

        class im extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                const e = this.document;
                e.on("compositionstart", (() => {
                    e.isComposing = true
                }), {priority: "low"});
                e.on("compositionend", (() => {
                    e.isComposing = false
                }), {priority: "low"})
            }

            onDomEvent(t) {
                this.fire(t.type, t, {data: t.data})
            }
        }

        class om {
            constructor(t) {
                this.files = rm(t);
                this._native = t
            }

            get types() {
                return this._native.types
            }

            getData(t) {
                return this._native.getData(t)
            }

            setData(t, e) {
                this._native.setData(t, e)
            }

            set effectAllowed(t) {
                this._native.effectAllowed = t
            }

            get effectAllowed() {
                return this._native.effectAllowed
            }

            set dropEffect(t) {
                this._native.dropEffect = t
            }

            get dropEffect() {
                return this._native.dropEffect
            }

            get isCanceled() {
                return this._native.dropEffect == "none" || !!this._native.mozUserCancelled
            }
        }

        function rm(t) {
            const e = Array.from(t.files || []);
            const n = Array.from(t.items || []);
            if (e.length) {
                return e
            }
            return n.filter((t => t.kind === "file")).map((t => t.getAsFile()))
        }

        class sm extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["beforeinput"]
            }

            onDomEvent(t) {
                const e = t.getTargetRanges();
                const n = this.view;
                const i = n.document;
                let o = null;
                let s = null;
                let a = [];
                if (t.dataTransfer) {
                    o = new om(t.dataTransfer)
                }
                if (t.data !== null) {
                    s = t.data
                } else if (o) {
                    s = o.getData("text/plain")
                }
                if (i.selection.isFake) {
                    a = Array.from(i.selection.getRanges())
                } else if (e.length) {
                    a = e.map((t => n.domConverter.domRangeToView(t)))
                } else if (r.isAndroid) {
                    const e = t.target.ownerDocument.defaultView.getSelection();
                    a = Array.from(n.domConverter.domSelectionToView(e).getRanges())
                }
                if (r.isAndroid && t.inputType == "insertCompositionText" && s && s.endsWith("\n")) {
                    this.fire(t.type, t, {inputType: "insertParagraph", targetRanges: [n.createRange(a[0].end)]});
                    return
                }
                if (t.inputType == "insertText" && s && s.includes("\n")) {
                    const e = s.split(/\n{1,2}/g);
                    let n = a;
                    for (let r = 0; r < e.length; r++) {
                        const s = e[r];
                        if (s != "") {
                            this.fire(t.type, t, {
                                data: s,
                                dataTransfer: o,
                                targetRanges: n,
                                inputType: t.inputType,
                                isComposing: t.isComposing
                            });
                            n = [i.selection.getFirstRange()]
                        }
                        if (r + 1 < e.length) {
                            this.fire(t.type, t, {inputType: "insertParagraph", targetRanges: n});
                            n = [i.selection.getFirstRange()]
                        }
                    }
                    return
                }
                this.fire(t.type, t, {
                    data: s,
                    dataTransfer: o,
                    targetRanges: a,
                    inputType: t.inputType,
                    isComposing: t.isComposing
                })
            }
        }

        class am extends Sf {
            constructor(t) {
                super(t);
                this.document.on("keydown", ((t, e) => {
                    if (this.isEnabled && ql(e.keyCode)) {
                        const n = new dh(this.document, "arrowKey", this.document.selection.getFirstRange());
                        this.document.fire(n, e);
                        if (n.stop.called) {
                            t.stop()
                        }
                    }
                }))
            }

            observe() {
            }
        }

        class lm extends Sf {
            constructor(t) {
                super(t);
                const e = this.document;
                e.on("keydown", ((t, n) => {
                    if (!this.isEnabled || n.keyCode != Ol.tab || n.ctrlKey) {
                        return
                    }
                    const i = new dh(e, "tab", e.selection.getFirstRange());
                    e.fire(i, n);
                    if (i.stop.called) {
                        t.stop()
                    }
                }))
            }

            observe() {
            }
        }

        class cm extends (dt()) {
            constructor(t) {
                super();
                this.document = new kh(t);
                this.domConverter = new Af(this.document);
                this.domRoots = new Map;
                this.set("isRenderingInProgress", false);
                this.set("hasDomSelection", false);
                this._renderer = new sf(this.domConverter, this.document.selection);
                this._renderer.bind("isFocused", "isSelecting", "isComposing", "_isFocusChanging").to(this.document, "isFocused", "isSelecting", "isComposing", "_isFocusChanging");
                this._initialDomRootAttributes = new WeakMap;
                this._observers = new Map;
                this._ongoingChange = false;
                this._postFixersInProgress = false;
                this._renderingDisabled = false;
                this._hasChangedSinceTheLastRendering = false;
                this._writer = new Rh(this.document);
                this.addObserver(Xg);
                this.addObserver(em);
                this.addObserver(nm);
                this.addObserver(If);
                this.addObserver(Xf);
                this.addObserver(im);
                this.addObserver(am);
                this.addObserver(sm);
                this.addObserver(lm);
                Xh(this);
                Eh(this);
                this.on("render", (() => {
                    this._render();
                    this.document.fire("layoutChanged");
                    this._hasChangedSinceTheLastRendering = false
                }));
                this.listenTo(this.document.selection, "change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }));
                this.listenTo(this.document, "change:isFocused", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }))
            }

            attachDomRoot(t, e = "main") {
                const n = this.document.getRoot(e);
                n._name = t.tagName.toLowerCase();
                const i = {};
                for (const {name: e, value: o} of Array.from(t.attributes)) {
                    i[e] = o;
                    if (e === "class") {
                        this._writer.addClass(o.split(" "), n)
                    } else {
                        this._writer.setAttribute(e, o, n)
                    }
                }
                this._initialDomRootAttributes.set(t, i);
                const o = () => {
                    this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n);
                    if (n.isReadOnly) {
                        this._writer.addClass("ck-read-only", n)
                    } else {
                        this._writer.removeClass("ck-read-only", n)
                    }
                };
                o();
                this.domRoots.set(e, t);
                this.domConverter.bindElements(t, n);
                this._renderer.markToSync("children", n);
                this._renderer.markToSync("attributes", n);
                this._renderer.domDocuments.add(t.ownerDocument);
                n.on("change:children", ((t, e) => this._renderer.markToSync("children", e)));
                n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e)));
                n.on("change:text", ((t, e) => this._renderer.markToSync("text", e)));
                n.on("change:isReadOnly", (() => this.change(o)));
                n.on("change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }));
                for (const n of this._observers.values()) {
                    n.observe(t, e)
                }
            }

            detachDomRoot(t) {
                const e = this.domRoots.get(t);
                Array.from(e.attributes).forEach((({name: t}) => e.removeAttribute(t)));
                const n = this._initialDomRootAttributes.get(e);
                for (const t in n) {
                    e.setAttribute(t, n[t])
                }
                this.domRoots.delete(t);
                this.domConverter.unbindDomElement(e)
            }

            getDomRoot(t = "main") {
                return this.domRoots.get(t)
            }

            addObserver(t) {
                let e = this._observers.get(t);
                if (e) {
                    return e
                }
                e = new t(this);
                this._observers.set(t, e);
                for (const [t, n] of this.domRoots) {
                    e.observe(n, t)
                }
                e.enable();
                return e
            }

            getObserver(t) {
                return this._observers.get(t)
            }

            disableObservers() {
                for (const t of this._observers.values()) {
                    t.disable()
                }
            }

            enableObservers() {
                for (const t of this._observers.values()) {
                    t.enable()
                }
            }

            scrollToTheSelection() {
                const t = this.document.selection.getFirstRange();
                if (t) {
                    xl({target: this.domConverter.viewRangeToDom(t), viewportOffset: 20})
                }
            }

            focus() {
                if (!this.document.isFocused) {
                    const t = this.document.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t);
                        this.forceRender()
                    } else {
                    }
                }
            }

            change(t) {
                if (this.isRenderingInProgress || this._postFixersInProgress) {
                    throw new P("cannot-change-view-tree", this)
                }
                try {
                    if (this._ongoingChange) {
                        return t(this._writer)
                    }
                    this._ongoingChange = true;
                    const e = t(this._writer);
                    this._ongoingChange = false;
                    if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
                        this._postFixersInProgress = true;
                        this.document._callPostFixers(this._writer);
                        this._postFixersInProgress = false;
                        this.fire("render")
                    }
                    return e
                } catch (t) {
                    P.rethrowUnexpectedError(t, this)
                }
            }

            forceRender() {
                this._hasChangedSinceTheLastRendering = true;
                this.document._isFocusChanging = false;
                this.change((() => {
                }))
            }

            destroy() {
                for (const t of this._observers.values()) {
                    t.destroy()
                }
                this.document.destroy();
                this.stopListening()
            }

            createPositionAt(t, e) {
                return rh._createAt(t, e)
            }

            createPositionAfter(t) {
                return rh._createAfter(t)
            }

            createPositionBefore(t) {
                return rh._createBefore(t)
            }

            createRange(...t) {
                return new sh(...t)
            }

            createRangeOn(t) {
                return sh._createOn(t)
            }

            createRangeIn(t) {
                return sh._createIn(t)
            }

            createSelection(...t) {
                return new lh(...t)
            }

            _disableRendering(t) {
                this._renderingDisabled = t;
                if (t == false) {
                    this.change((() => {
                    }))
                }
            }

            _render() {
                this.isRenderingInProgress = true;
                this.disableObservers();
                this._renderer.render();
                this.enableObservers();
                this.isRenderingInProgress = false
            }
        }

        class dm {
            is() {
                throw new Error("is() method is abstract")
            }
        }

        class um extends dm {
            constructor(t) {
                super();
                this.parent = null;
                this._attrs = dc(t)
            }

            get document() {
                return null
            }

            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) === null) {
                    throw new P("model-node-not-found-in-parent", this)
                }
                return t
            }

            get startOffset() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildStartOffset(this)) === null) {
                    throw new P("model-node-not-found-in-parent", this)
                }
                return t
            }

            get offsetSize() {
                return 1
            }

            get endOffset() {
                if (!this.parent) {
                    return null
                }
                return this.startOffset + this.offsetSize
            }

            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }

            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }

            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }

            isAttached() {
                return this.root.is("rootElement")
            }

            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.startOffset);
                    e = e.parent
                }
                return t
            }

            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const i = t.getAncestors(e);
                let o = 0;
                while (n[o] == i[o] && n[o]) {
                    o++
                }
                return o === 0 ? null : n[o - 1]
            }

            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const i = vt(e, n);
                switch (i) {
                    case"prefix":
                        return true;
                    case"extension":
                        return false;
                    default:
                        return e[i] < n[i]
                }
            }

            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }

            hasAttribute(t) {
                return this._attrs.has(t)
            }

            getAttribute(t) {
                return this._attrs.get(t)
            }

            getAttributes() {
                return this._attrs.entries()
            }

            getAttributeKeys() {
                return this._attrs.keys()
            }

            toJSON() {
                const t = {};
                if (this._attrs.size) {
                    t.attributes = Array.from(this._attrs).reduce(((t, e) => {
                        t[e[0]] = e[1];
                        return t
                    }), {})
                }
                return t
            }

            _clone(t) {
                return new um(this._attrs)
            }

            _remove() {
                this.parent._removeChildren(this.index)
            }

            _setAttribute(t, e) {
                this._attrs.set(t, e)
            }

            _setAttributesTo(t) {
                this._attrs = dc(t)
            }

            _removeAttribute(t) {
                return this._attrs.delete(t)
            }

            _clearAttributes() {
                this._attrs.clear()
            }
        }

        um.prototype.is = function (t) {
            return t === "node" || t === "model:node"
        };

        class hm {
            constructor(t) {
                this._nodes = [];
                if (t) {
                    this._insertNodes(0, t)
                }
            }

            [Symbol.iterator]() {
                return this._nodes[Symbol.iterator]()
            }

            get length() {
                return this._nodes.length
            }

            get maxOffset() {
                return this._nodes.reduce(((t, e) => t + e.offsetSize), 0)
            }

            getNode(t) {
                return this._nodes[t] || null
            }

            getNodeIndex(t) {
                const e = this._nodes.indexOf(t);
                return e == -1 ? null : e
            }

            getNodeStartOffset(t) {
                const e = this.getNodeIndex(t);
                return e === null ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0)
            }

            indexToOffset(t) {
                if (t == this._nodes.length) {
                    return this.maxOffset
                }
                const e = this._nodes[t];
                if (!e) {
                    throw new P("model-nodelist-index-out-of-bounds", this)
                }
                return this.getNodeStartOffset(e)
            }

            offsetToIndex(t) {
                let e = 0;
                for (const n of this._nodes) {
                    if (t >= e && t < e + n.offsetSize) {
                        return this.getNodeIndex(n)
                    }
                    e += n.offsetSize
                }
                if (e != t) {
                    throw new P("model-nodelist-offset-out-of-bounds", this, {offset: t, nodeList: this})
                }
                return this.length
            }

            _insertNodes(t, e) {
                for (const t of e) {
                    if (!(t instanceof um)) {
                        throw new P("model-nodelist-insertnodes-not-node", this)
                    }
                }
                this._nodes = hc(this._nodes, Array.from(e), t, 0)
            }

            _removeNodes(t, e = 1) {
                return this._nodes.splice(t, e)
            }

            toJSON() {
                return this._nodes.map((t => t.toJSON()))
            }
        }

        class fm extends um {
            constructor(t, e) {
                super(e);
                this._data = t || ""
            }

            get offsetSize() {
                return this.data.length
            }

            get data() {
                return this._data
            }

            toJSON() {
                const t = super.toJSON();
                t.data = this.data;
                return t
            }

            _clone() {
                return new fm(this.data, this.getAttributes())
            }

            static fromJSON(t) {
                return new fm(t.data, t.attributes)
            }
        }

        fm.prototype.is = function (t) {
            return t === "$text" || t === "model:$text" || t === "text" || t === "model:text" || t === "node" || t === "model:node"
        };

        class gm extends dm {
            constructor(t, e, n) {
                super();
                this.textNode = t;
                if (e < 0 || e > t.offsetSize) {
                    throw new P("model-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.offsetSize) {
                    throw new P("model-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }

            get startOffset() {
                return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
            }

            get offsetSize() {
                return this.data.length
            }

            get endOffset() {
                return this.startOffset !== null ? this.startOffset + this.offsetSize : null
            }

            get isPartial() {
                return this.offsetSize !== this.textNode.offsetSize
            }

            get parent() {
                return this.textNode.parent
            }

            get root() {
                return this.textNode.root
            }

            getPath() {
                const t = this.textNode.getPath();
                if (t.length > 0) {
                    t[t.length - 1] += this.offsetInText
                }
                return t
            }

            getAncestors(t = {}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            hasAttribute(t) {
                return this.textNode.hasAttribute(t)
            }

            getAttribute(t) {
                return this.textNode.getAttribute(t)
            }

            getAttributes() {
                return this.textNode.getAttributes()
            }

            getAttributeKeys() {
                return this.textNode.getAttributeKeys()
            }
        }

        gm.prototype.is = function (t) {
            return t === "$textProxy" || t === "model:$textProxy" || t === "textProxy" || t === "model:textProxy"
        };

        class mm extends um {
            constructor(t, e, n) {
                super(e);
                this.name = t;
                this._children = new hm;
                if (n) {
                    this._insertChild(0, n)
                }
            }

            get childCount() {
                return this._children.length
            }

            get maxOffset() {
                return this._children.maxOffset
            }

            get isEmpty() {
                return this.childCount === 0
            }

            getChild(t) {
                return this._children.getNode(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }

            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }

            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }

            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }

            findAncestor(t, e = {}) {
                let n = e.includeSelf ? this : this.parent;
                while (n) {
                    if (n.name === t) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }

            toJSON() {
                const t = super.toJSON();
                t.name = this.name;
                if (this._children.length > 0) {
                    t.children = [];
                    for (const e of this._children) {
                        t.children.push(e.toJSON())
                    }
                }
                return t
            }

            _clone(t = false) {
                const e = t ? Array.from(this._children).map((t => t._clone(true))) : undefined;
                return new mm(this.name, this.getAttributes(), e)
            }

            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                const n = pm(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }

            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }

            static fromJSON(t) {
                let e;
                if (t.children) {
                    e = [];
                    for (const n of t.children) {
                        if (n.name) {
                            e.push(mm.fromJSON(n))
                        } else {
                            e.push(fm.fromJSON(n))
                        }
                    }
                }
                return new mm(t.name, t.attributes, e)
            }
        }

        mm.prototype.is = function (t, e) {
            if (!e) {
                return t === "element" || t === "model:element" || t === "node" || t === "model:node"
            }
            return e === this.name && (t === "element" || t === "model:element")
        };

        function pm(t) {
            if (typeof t == "string") {
                return [new fm(t)]
            }
            if (!yt(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new fm(t)
                }
                if (t instanceof gm) {
                    return new fm(t.data, t.getAttributes())
                }
                return t
            }))
        }

        class bm {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new P("model-tree-walker-no-start-position", null)
                }
                const e = t.direction || "forward";
                if (e != "forward" && e != "backward") {
                    throw new P("model-tree-walker-unknown-direction", t, {direction: e})
                }
                this.direction = e;
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = t.startPosition.clone()
                } else {
                    this.position = wm._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"])
                }
                this.position.stickiness = "toNone";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
                this._visitedParent = this.position.parent
            }

            [Symbol.iterator]() {
                return this
            }

            skip(t) {
                let e, n, i, o;
                do {
                    i = this.position;
                    o = this._visitedParent;
                    ({done: e, value: n} = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = i;
                    this._visitedParent = o
                }
            }

            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }

            _next() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === n.maxOffset) {
                    return {done: true, value: undefined}
                }
                if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
                    return {done: true, value: undefined}
                }
                const i = _m(e, n);
                const o = i ? i : Am(e, n, i);
                if (o instanceof mm) {
                    if (!this.shallow) {
                        e.path.push(0);
                        this._visitedParent = o
                    } else {
                        e.offset++
                    }
                    this.position = e;
                    return km("elementStart", o, t, e, 1)
                } else if (o instanceof fm) {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        let t = o.endOffset;
                        if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                            t = this.boundaries.end.offset
                        }
                        i = t - e.offset
                    }
                    const r = e.offset - o.startOffset;
                    const s = new gm(o, r, i);
                    e.offset += i;
                    this.position = e;
                    return km("text", s, t, e, i)
                } else {
                    e.path.pop();
                    e.offset++;
                    this.position = e;
                    this._visitedParent = n.parent;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return km("elementEnd", n, t, e)
                    }
                }
            }

            _previous() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === 0) {
                    return {done: true, value: undefined}
                }
                if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
                    return {done: true, value: undefined}
                }
                const i = e.parent;
                const o = _m(e, i);
                const r = o ? o : Cm(e, i, o);
                if (r instanceof mm) {
                    e.offset--;
                    if (!this.shallow) {
                        e.path.push(r.maxOffset);
                        this.position = e;
                        this._visitedParent = r;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return km("elementEnd", r, t, e)
                        }
                    } else {
                        this.position = e;
                        return km("elementStart", r, t, e, 1)
                    }
                } else if (r instanceof fm) {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        let t = r.startOffset;
                        if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                            t = this.boundaries.start.offset
                        }
                        i = e.offset - t
                    }
                    const o = e.offset - r.startOffset;
                    const s = new gm(r, o - i, i);
                    e.offset -= i;
                    this.position = e;
                    return km("text", s, t, e, i)
                } else {
                    e.path.pop();
                    this.position = e;
                    this._visitedParent = n.parent;
                    return km("elementStart", n, t, e, 1)
                }
            }
        }

        function km(t, e, n, i, o) {
            return {done: false, value: {type: t, item: e, previousPosition: n, nextPosition: i, length: o}}
        }

        class wm extends dm {
            constructor(t, e, n = "toNone") {
                super();
                if (!t.is("element") && !t.is("documentFragment")) {
                    throw new P("model-position-root-invalid", t)
                }
                if (!(e instanceof Array) || e.length === 0) {
                    throw new P("model-position-path-incorrect-format", t, {path: e})
                }
                if (t.is("rootElement")) {
                    e = e.slice()
                } else {
                    e = [...t.getPath(), ...e];
                    t = t.root
                }
                this.root = t;
                this.path = e;
                this.stickiness = n
            }

            get offset() {
                return this.path[this.path.length - 1]
            }

            set offset(t) {
                this.path[this.path.length - 1] = t
            }

            get parent() {
                let t = this.root;
                for (let e = 0; e < this.path.length - 1; e++) {
                    t = t.getChild(t.offsetToIndex(this.path[e]));
                    if (!t) {
                        throw new P("model-position-path-incorrect", this, {position: this})
                    }
                }
                if (t.is("$text")) {
                    throw new P("model-position-path-incorrect", this, {position: this})
                }
                return t
            }

            get index() {
                return this.parent.offsetToIndex(this.offset)
            }

            get textNode() {
                return _m(this, this.parent)
            }

            get nodeAfter() {
                const t = this.parent;
                return Am(this, t, _m(this, t))
            }

            get nodeBefore() {
                const t = this.parent;
                return Cm(this, t, _m(this, t))
            }

            get isAtStart() {
                return this.offset === 0
            }

            get isAtEnd() {
                return this.offset == this.parent.maxOffset
            }

            compareWith(t) {
                if (this.root != t.root) {
                    return "different"
                }
                const e = vt(this.path, t.path);
                switch (e) {
                    case"same":
                        return "same";
                    case"prefix":
                        return "before";
                    case"extension":
                        return "after";
                    default:
                        return this.path[e] < t.path[e] ? "before" : "after"
                }
            }

            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new bm(e);
                n.skip(t);
                return n.position
            }

            getParentPath() {
                return this.path.slice(0, -1)
            }

            getAncestors() {
                const t = this.parent;
                if (t.is("documentFragment")) {
                    return [t]
                } else {
                    return t.getAncestors({includeSelf: true})
                }
            }

            findAncestor(t) {
                const e = this.parent;
                if (e.is("element")) {
                    return e.findAncestor(t, {includeSelf: true})
                }
                return null
            }

            getCommonPath(t) {
                if (this.root != t.root) {
                    return []
                }
                const e = vt(this.path, t.path);
                const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
                return this.path.slice(0, n)
            }

            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let i = 0;
                while (e[i] == n[i] && e[i]) {
                    i++
                }
                return i === 0 ? null : e[i - 1]
            }

            getShiftedBy(t) {
                const e = this.clone();
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }

            isAfter(t) {
                return this.compareWith(t) == "after"
            }

            isBefore(t) {
                return this.compareWith(t) == "before"
            }

            isEqual(t) {
                return this.compareWith(t) == "same"
            }

            isTouching(t) {
                if (this.root !== t.root) {
                    return false
                }
                const e = Math.min(this.path.length, t.path.length);
                for (let n = 0; n < e; n++) {
                    const e = this.path[n] - t.path[n];
                    if (e < -1 || e > 1) {
                        return false
                    } else if (e === 1) {
                        return vm(t, this, n)
                    } else if (e === -1) {
                        return vm(this, t, n)
                    }
                }
                if (this.path.length === t.path.length) {
                    return true
                } else if (this.path.length > t.path.length) {
                    return ym(this.path, e)
                } else {
                    return ym(t.path, e)
                }
            }

            hasSameParentAs(t) {
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getParentPath();
                const n = t.getParentPath();
                return vt(e, n) == "same"
            }

            getTransformedByOperation(t) {
                let e;
                switch (t.type) {
                    case"insert":
                        e = this._getTransformedByInsertOperation(t);
                        break;
                    case"move":
                    case"remove":
                    case"reinsert":
                        e = this._getTransformedByMoveOperation(t);
                        break;
                    case"split":
                        e = this._getTransformedBySplitOperation(t);
                        break;
                    case"merge":
                        e = this._getTransformedByMergeOperation(t);
                        break;
                    default:
                        e = wm._createAt(this);
                        break
                }
                return e
            }

            _getTransformedByInsertOperation(t) {
                return this._getTransformedByInsertion(t.position, t.howMany)
            }

            _getTransformedByMoveOperation(t) {
                return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
            }

            _getTransformedBySplitOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext";
                if (n) {
                    return this._getCombined(t.splitPosition, t.moveTargetPosition)
                } else {
                    if (t.graveyardPosition) {
                        return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
                    } else {
                        return this._getTransformedByInsertion(t.insertionPosition, 1)
                    }
                }
            }

            _getTransformedByMergeOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this);
                let i;
                if (n) {
                    i = this._getCombined(t.sourcePosition, t.targetPosition);
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        i = i._getTransformedByDeletion(t.deletionPosition, 1)
                    }
                } else if (this.isEqual(t.deletionPosition)) {
                    i = wm._createAt(t.deletionPosition)
                } else {
                    i = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
                }
                return i
            }

            _getTransformedByDeletion(t, e) {
                const n = wm._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (vt(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset) {
                        if (t.offset + e > this.offset) {
                            return null
                        } else {
                            n.offset -= e
                        }
                    }
                } else if (vt(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const i = t.path.length - 1;
                    if (t.offset <= this.path[i]) {
                        if (t.offset + e > this.path[i]) {
                            return null
                        } else {
                            n.path[i] -= e
                        }
                    }
                }
                return n
            }

            _getTransformedByInsertion(t, e) {
                const n = wm._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (vt(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") {
                        n.offset += e
                    }
                } else if (vt(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const i = t.path.length - 1;
                    if (t.offset <= this.path[i]) {
                        n.path[i] += e
                    }
                }
                return n
            }

            _getTransformedByMove(t, e, n) {
                e = e._getTransformedByDeletion(t, n);
                if (t.isEqual(e)) {
                    return wm._createAt(this)
                }
                const i = this._getTransformedByDeletion(t, n);
                const o = i === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious";
                if (o) {
                    return this._getCombined(t, e)
                } else {
                    return i._getTransformedByInsertion(e, n)
                }
            }

            _getCombined(t, e) {
                const n = t.path.length - 1;
                const i = wm._createAt(e);
                i.stickiness = this.stickiness;
                i.offset = i.offset + this.path[n] - t.offset;
                i.path = [...i.path, ...this.path.slice(n + 1)];
                return i
            }

            toJSON() {
                return {root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness}
            }

            clone() {
                return new this.constructor(this.root, this.path, this.stickiness)
            }

            static _createAt(t, e, n = "toNone") {
                if (t instanceof wm) {
                    return new wm(t.root, t.path, t.stickiness)
                } else {
                    const i = t;
                    if (e == "end") {
                        e = i.maxOffset
                    } else if (e == "before") {
                        return this._createBefore(i, n)
                    } else if (e == "after") {
                        return this._createAfter(i, n)
                    } else if (e !== 0 && !e) {
                        throw new P("model-createpositionat-offset-required", [this, t])
                    }
                    if (!i.is("element") && !i.is("documentFragment")) {
                        throw new P("model-position-parent-incorrect", [this, t])
                    }
                    const o = i.getPath();
                    o.push(e);
                    return new this(i.root, o, n)
                }
            }

            static _createAfter(t, e) {
                if (!t.parent) {
                    throw new P("model-position-after-root", [this, t], {root: t})
                }
                return this._createAt(t.parent, t.endOffset, e)
            }

            static _createBefore(t, e) {
                if (!t.parent) {
                    throw new P("model-position-before-root", t, {root: t})
                }
                return this._createAt(t.parent, t.startOffset, e)
            }

            static fromJSON(t, e) {
                if (t.root === "$graveyard") {
                    const n = new wm(e.graveyard, t.path);
                    n.stickiness = t.stickiness;
                    return n
                }
                if (!e.getRoot(t.root)) {
                    throw new P("model-position-fromjson-no-root", e, {rootName: t.root})
                }
                return new wm(e.getRoot(t.root), t.path, t.stickiness)
            }
        }

        wm.prototype.is = function (t) {
            return t === "position" || t === "model:position"
        };

        function _m(t, e) {
            const n = e.getChild(e.offsetToIndex(t.offset));
            if (n && n.is("$text") && n.startOffset < t.offset) {
                return n
            }
            return null
        }

        function Am(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset))
        }

        function Cm(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset) - 1)
        }

        function vm(t, e, n) {
            if (n + 1 === t.path.length) {
                return false
            }
            if (!ym(e.path, n + 1)) {
                return false
            }
            if (!xm(t, n + 1)) {
                return false
            }
            return true
        }

        function ym(t, e) {
            while (e < t.length) {
                if (t[e] !== 0) {
                    return false
                }
                e++
            }
            return true
        }

        function xm(t, e) {
            let n = t.parent;
            let i = t.path.length - 1;
            let o = 0;
            while (i >= e) {
                if (t.path[i] + o !== n.maxOffset) {
                    return false
                }
                o = 1;
                i--;
                n = n.parent
            }
            return true
        }

        class Em extends dm {
            constructor(t, e) {
                super();
                this.start = wm._createAt(t);
                this.end = e ? wm._createAt(e) : wm._createAt(t);
                this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
                this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
            }

            * [Symbol.iterator]() {
                yield* new bm({boundaries: this, ignoreElementEnd: true})
            }

            get isCollapsed() {
                return this.start.isEqual(this.end)
            }

            get isFlat() {
                const t = this.start.getParentPath();
                const e = this.end.getParentPath();
                return vt(t, e) == "same"
            }

            get root() {
                return this.start.root
            }

            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }

            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && i
            }

            containsItem(t) {
                const e = wm._createBefore(t);
                return this.containsPosition(e) || this.start.isEqual(e)
            }

            isEqual(t) {
                return this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }

            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }

            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new Em(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new Em(t.end, this.end))
                    }
                } else {
                    e.push(new Em(this.start, this.end))
                }
                return e
            }

            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new Em(e, n)
                }
                return null
            }

            getJoined(t, e = false) {
                let n = this.isIntersecting(t);
                if (!n) {
                    if (this.start.isBefore(t.start)) {
                        n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start)
                    } else {
                        n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)
                    }
                }
                if (!n) {
                    return null
                }
                let i = this.start;
                let o = this.end;
                if (t.start.isBefore(i)) {
                    i = t.start
                }
                if (t.end.isAfter(o)) {
                    o = t.end
                }
                return new Em(i, o)
            }

            getMinimalFlatRanges() {
                const t = [];
                const e = this.start.getCommonPath(this.end).length;
                const n = wm._createAt(this.start);
                let i = n.parent;
                while (n.path.length > e + 1) {
                    const e = i.maxOffset - n.offset;
                    if (e !== 0) {
                        t.push(new Em(n, n.getShiftedBy(e)))
                    }
                    n.path = n.path.slice(0, -1);
                    n.offset++;
                    i = i.parent
                }
                while (n.path.length <= this.end.path.length) {
                    const e = this.end.path[n.path.length - 1];
                    const i = e - n.offset;
                    if (i !== 0) {
                        t.push(new Em(n, n.getShiftedBy(i)))
                    }
                    n.offset = e;
                    n.path.push(0)
                }
                return t
            }

            getWalker(t = {}) {
                t.boundaries = this;
                return new bm(t)
            }

            * getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new bm(t);
                for (const t of e) {
                    yield t.item
                }
            }

            * getPositions(t = {}) {
                t.boundaries = this;
                const e = new bm(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }

            getTransformedByOperation(t) {
                switch (t.type) {
                    case"insert":
                        return this._getTransformedByInsertOperation(t);
                    case"move":
                    case"remove":
                    case"reinsert":
                        return this._getTransformedByMoveOperation(t);
                    case"split":
                        return [this._getTransformedBySplitOperation(t)];
                    case"merge":
                        return [this._getTransformedByMergeOperation(t)]
                }
                return [new Em(this.start, this.end)]
            }

            getTransformedByOperations(t) {
                const e = [new Em(this.start, this.end)];
                for (const n of t) {
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t].getTransformedByOperation(n);
                        e.splice(t, 1, ...i);
                        t += i.length - 1
                    }
                }
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    for (let i = t + 1; i < e.length; i++) {
                        const t = e[i];
                        if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                            e.splice(i, 1)
                        }
                    }
                }
                return e
            }

            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }

            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                const t = this.start.nodeAfter;
                const e = this.end.nodeBefore;
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }

            toJSON() {
                return {start: this.start.toJSON(), end: this.end.toJSON()}
            }

            clone() {
                return new this.constructor(this.start, this.end)
            }

            _getTransformedByInsertOperation(t, e = false) {
                return this._getTransformedByInsertion(t.position, t.howMany, e)
            }

            _getTransformedByMoveOperation(t, e = false) {
                const n = t.sourcePosition;
                const i = t.howMany;
                const o = t.targetPosition;
                return this._getTransformedByMove(n, o, i, e)
            }

            _getTransformedBySplitOperation(t) {
                const e = this.start._getTransformedBySplitOperation(t);
                let n = this.end._getTransformedBySplitOperation(t);
                if (this.end.isEqual(t.insertionPosition)) {
                    n = this.end.getShiftedBy(1)
                }
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                return new Em(e, n)
            }

            _getTransformedByMergeOperation(t) {
                if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
                    return new Em(this.start)
                }
                let e = this.start._getTransformedByMergeOperation(t);
                let n = this.end._getTransformedByMergeOperation(t);
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                if (e.isAfter(n)) {
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        e = wm._createAt(n);
                        e.offset = 0
                    } else {
                        if (!t.deletionPosition.isEqual(e)) {
                            n = t.deletionPosition
                        }
                        e = t.targetPosition
                    }
                    return new Em(e, n)
                }
                return new Em(e, n)
            }

            _getTransformedByInsertion(t, e, n = false) {
                if (n && this.containsPosition(t)) {
                    return [new Em(this.start, t), new Em(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))]
                } else {
                    const n = new Em(this.start, this.end);
                    n.start = n.start._getTransformedByInsertion(t, e);
                    n.end = n.end._getTransformedByInsertion(t, e);
                    return [n]
                }
            }

            _getTransformedByMove(t, e, n, i = false) {
                if (this.isCollapsed) {
                    const i = this.start._getTransformedByMove(t, e, n);
                    return [new Em(i)]
                }
                const o = Em._createFromPositionAndShift(t, n);
                const r = e._getTransformedByDeletion(t, n);
                if (this.containsPosition(e) && !i) {
                    if (o.containsPosition(this.start) || o.containsPosition(this.end)) {
                        const i = this.start._getTransformedByMove(t, e, n);
                        const o = this.end._getTransformedByMove(t, e, n);
                        return [new Em(i, o)]
                    }
                }
                let s;
                const a = this.getDifference(o);
                let l = null;
                const c = this.getIntersection(o);
                if (a.length == 1) {
                    l = new Em(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n))
                } else if (a.length == 2) {
                    l = new Em(this.start, this.end._getTransformedByDeletion(t, n))
                }
                if (l) {
                    s = l._getTransformedByInsertion(r, n, c !== null || i)
                } else {
                    s = []
                }
                if (c) {
                    const t = new Em(c.start._getCombined(o.start, r), c.end._getCombined(o.start, r));
                    if (s.length == 2) {
                        s.splice(1, 0, t)
                    } else {
                        s.push(t)
                    }
                }
                return s
            }

            _getTransformedByDeletion(t, e) {
                let n = this.start._getTransformedByDeletion(t, e);
                let i = this.end._getTransformedByDeletion(t, e);
                if (n == null && i == null) {
                    return null
                }
                if (n == null) {
                    n = t
                }
                if (i == null) {
                    i = t
                }
                return new Em(n, i)
            }

            static _createFromPositionAndShift(t, e) {
                const n = t;
                const i = t.getShiftedBy(e);
                return e > 0 ? new this(n, i) : new this(i, n)
            }

            static _createIn(t) {
                return new this(wm._createAt(t, 0), wm._createAt(t, t.maxOffset))
            }

            static _createOn(t) {
                return this._createFromPositionAndShift(wm._createBefore(t), t.offsetSize)
            }

            static _createFromRanges(t) {
                if (t.length === 0) {
                    throw new P("range-create-from-ranges-empty-array", null)
                } else if (t.length == 1) {
                    return t[0].clone()
                }
                const e = t[0];
                t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1));
                const n = t.indexOf(e);
                const i = new this(e.start, e.end);
                if (n > 0) {
                    for (let e = n - 1; true; e++) {
                        if (t[e].end.isEqual(i.start)) {
                            i.start = wm._createAt(t[e].start)
                        } else {
                            break
                        }
                    }
                }
                for (let e = n + 1; e < t.length; e++) {
                    if (t[e].start.isEqual(i.end)) {
                        i.end = wm._createAt(t[e].end)
                    } else {
                        break
                    }
                }
                return i
            }

            static fromJSON(t, e) {
                return new this(wm.fromJSON(t.start, e), wm.fromJSON(t.end, e))
            }
        }

        Em.prototype.is = function (t) {
            return t === "range" || t === "model:range"
        };

        class Sm extends (j()) {
            constructor() {
                super();
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._viewToModelLengthCallbacks = new Map;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._deferredBindingRemovals = new Map;
                this._unboundMarkerNames = new Set;
                this.on("modelToViewPosition", ((t, e) => {
                    if (e.viewPosition) {
                        return
                    }
                    const n = this._modelToViewMapping.get(e.modelPosition.parent);
                    if (!n) {
                        throw new P("mapping-model-position-view-parent-not-found", this, {modelPosition: e.modelPosition})
                    }
                    e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
                }), {priority: "low"});
                this.on("viewToModelPosition", ((t, e) => {
                    if (e.modelPosition) {
                        return
                    }
                    const n = this.findMappedViewAncestor(e.viewPosition);
                    const i = this._viewToModelMapping.get(n);
                    const o = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                    e.modelPosition = wm._createAt(i, o)
                }), {priority: "low"})
            }

            bindElements(t, e) {
                this._modelToViewMapping.set(t, e);
                this._viewToModelMapping.set(e, t)
            }

            unbindViewElement(t, e = {}) {
                const n = this.toModelElement(t);
                if (this._elementToMarkerNames.has(t)) {
                    for (const e of this._elementToMarkerNames.get(t)) {
                        this._unboundMarkerNames.add(e)
                    }
                }
                if (e.defer) {
                    this._deferredBindingRemovals.set(t, t.root)
                } else {
                    this._viewToModelMapping.delete(t);
                    if (this._modelToViewMapping.get(n) == t) {
                        this._modelToViewMapping.delete(n)
                    }
                }
            }

            unbindModelElement(t) {
                const e = this.toViewElement(t);
                this._modelToViewMapping.delete(t);
                if (this._viewToModelMapping.get(e) == t) {
                    this._viewToModelMapping.delete(e)
                }
            }

            bindElementToMarker(t, e) {
                const n = this._markerNameToElements.get(e) || new Set;
                n.add(t);
                const i = this._elementToMarkerNames.get(t) || new Set;
                i.add(e);
                this._markerNameToElements.set(e, n);
                this._elementToMarkerNames.set(t, i)
            }

            unbindElementFromMarkerName(t, e) {
                const n = this._markerNameToElements.get(e);
                if (n) {
                    n.delete(t);
                    if (n.size == 0) {
                        this._markerNameToElements.delete(e)
                    }
                }
                const i = this._elementToMarkerNames.get(t);
                if (i) {
                    i.delete(e);
                    if (i.size == 0) {
                        this._elementToMarkerNames.delete(t)
                    }
                }
            }

            flushUnboundMarkerNames() {
                const t = Array.from(this._unboundMarkerNames);
                this._unboundMarkerNames.clear();
                return t
            }

            flushDeferredBindings() {
                for (const [t, e] of this._deferredBindingRemovals) {
                    if (t.root == e) {
                        this.unbindViewElement(t)
                    }
                }
                this._deferredBindingRemovals = new Map
            }

            clearBindings() {
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._unboundMarkerNames = new Set;
                this._deferredBindingRemovals = new Map
            }

            toModelElement(t) {
                return this._viewToModelMapping.get(t)
            }

            toViewElement(t) {
                return this._modelToViewMapping.get(t)
            }

            toModelRange(t) {
                return new Em(this.toModelPosition(t.start), this.toModelPosition(t.end))
            }

            toViewRange(t) {
                return new sh(this.toViewPosition(t.start), this.toViewPosition(t.end))
            }

            toModelPosition(t) {
                const e = {viewPosition: t, mapper: this};
                this.fire("viewToModelPosition", e);
                return e.modelPosition
            }

            toViewPosition(t, e = {}) {
                const n = {modelPosition: t, mapper: this, isPhantom: e.isPhantom};
                this.fire("modelToViewPosition", n);
                return n.viewPosition
            }

            markerNameToElements(t) {
                const e = this._markerNameToElements.get(t);
                if (!e) {
                    return null
                }
                const n = new Set;
                for (const t of e) {
                    if (t.is("attributeElement")) {
                        for (const e of t.getElementsWithSameId()) {
                            n.add(e)
                        }
                    } else {
                        n.add(t)
                    }
                }
                return n
            }

            registerViewToModelLength(t, e) {
                this._viewToModelLengthCallbacks.set(t, e)
            }

            findMappedViewAncestor(t) {
                let e = t.parent;
                while (!this._viewToModelMapping.has(e)) {
                    e = e.parent
                }
                return e
            }

            _toModelOffset(t, e, n) {
                if (n != t) {
                    const i = this._toModelOffset(t.parent, t.index, n);
                    const o = this._toModelOffset(t, e, t);
                    return i + o
                }
                if (t.is("$text")) {
                    return e
                }
                let i = 0;
                for (let n = 0; n < e; n++) {
                    i += this.getModelLength(t.getChild(n))
                }
                return i
            }

            getModelLength(t) {
                if (this._viewToModelLengthCallbacks.get(t.name)) {
                    const e = this._viewToModelLengthCallbacks.get(t.name);
                    return e(t)
                } else if (this._viewToModelMapping.has(t)) {
                    return 1
                } else if (t.is("$text")) {
                    return t.data.length
                } else if (t.is("uiElement")) {
                    return 0
                } else {
                    let e = 0;
                    for (const n of t.getChildren()) {
                        e += this.getModelLength(n)
                    }
                    return e
                }
            }

            findPositionIn(t, e) {
                let n;
                let i = 0;
                let o = 0;
                let r = 0;
                if (t.is("$text")) {
                    return new rh(t, e)
                }
                while (o < e) {
                    n = t.getChild(r);
                    i = this.getModelLength(n);
                    o += i;
                    r++
                }
                if (o == e) {
                    return this._moveViewPositionToTextNode(new rh(t, r))
                } else {
                    return this.findPositionIn(n, e - (o - i))
                }
            }

            _moveViewPositionToTextNode(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (e instanceof Zc) {
                    return new rh(e, e.data.length)
                } else if (n instanceof Zc) {
                    return new rh(n, 0)
                }
                return t
            }
        }

        class Dm {
            constructor() {
                this._consumable = new Map;
                this._textProxyRegistry = new Map
            }

            add(t, e) {
                e = Tm(e);
                if (t instanceof gm) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (!this._consumable.has(t)) {
                    this._consumable.set(t, new Map)
                }
                this._consumable.get(t).set(e, true)
            }

            consume(t, e) {
                e = Tm(e);
                if (t instanceof gm) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (this.test(t, e)) {
                    this._consumable.get(t).set(e, false);
                    return true
                } else {
                    return false
                }
            }

            test(t, e) {
                e = Tm(e);
                if (t instanceof gm) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this._consumable.get(t);
                if (n === undefined) {
                    return null
                }
                const i = n.get(e);
                if (i === undefined) {
                    return null
                }
                return i
            }

            revert(t, e) {
                e = Tm(e);
                if (t instanceof gm) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this.test(t, e);
                if (n === false) {
                    this._consumable.get(t).set(e, true);
                    return true
                } else if (n === true) {
                    return false
                }
                return null
            }

            verifyAllConsumed(t) {
                const e = [];
                for (const [n, i] of this._consumable) {
                    for (const [o, r] of i) {
                        const i = o.split(":")[0];
                        if (r && t == i) {
                            e.push({event: o, item: n.name || n.description})
                        }
                    }
                }
                if (e.length) {
                    throw new P("conversion-model-consumable-not-consumed", null, {items: e})
                }
            }

            _getSymbolForTextProxy(t) {
                let e = null;
                const n = this._textProxyRegistry.get(t.startOffset);
                if (n) {
                    const i = n.get(t.endOffset);
                    if (i) {
                        e = i.get(t.parent)
                    }
                }
                if (!e) {
                    e = this._addSymbolForTextProxy(t)
                }
                return e
            }

            _addSymbolForTextProxy(t) {
                const e = t.startOffset;
                const n = t.endOffset;
                const i = t.parent;
                const o = Symbol("$textProxy:" + t.data);
                let r;
                let s;
                r = this._textProxyRegistry.get(e);
                if (!r) {
                    r = new Map;
                    this._textProxyRegistry.set(e, r)
                }
                s = r.get(n);
                if (!s) {
                    s = new Map;
                    r.set(n, s)
                }
                s.set(i, o);
                return o
            }
        }

        function Tm(t) {
            const e = t.split(":");
            if (e[0] == "insert") {
                return e[0]
            }
            if (e[0] == "addMarker" || e[0] == "removeMarker") {
                return t
            }
            return e.length > 1 ? e[0] + ":" + e[1] : e[0]
        }

        class Bm extends (j()) {
            constructor(t) {
                super();
                this._conversionApi = {dispatcher: this, ...t};
                this._firedEventsMap = new WeakMap
            }

            convertChanges(t, e, n) {
                const i = this._createConversionApi(n, t.getRefreshedItems());
                for (const e of t.getMarkersToRemove()) {
                    this._convertMarkerRemove(e.name, e.range, i)
                }
                const o = this._reduceChanges(t.getChanges());
                for (const t of o) {
                    if (t.type === "insert") {
                        this._convertInsert(Em._createFromPositionAndShift(t.position, t.length), i)
                    } else if (t.type === "reinsert") {
                        this._convertReinsert(Em._createFromPositionAndShift(t.position, t.length), i)
                    } else if (t.type === "remove") {
                        this._convertRemove(t.position, t.length, t.name, i)
                    } else {
                        this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, i)
                    }
                }
                for (const t of i.mapper.flushUnboundMarkerNames()) {
                    const n = e.get(t).getRange();
                    this._convertMarkerRemove(t, n, i);
                    this._convertMarkerAdd(t, n, i)
                }
                for (const e of t.getMarkersToAdd()) {
                    this._convertMarkerAdd(e.name, e.range, i)
                }
                i.mapper.flushDeferredBindings();
                i.consumable.verifyAllConsumed("insert")
            }

            convert(t, e, n, i = {}) {
                const o = this._createConversionApi(n, undefined, i);
                this._convertInsert(t, o);
                for (const [t, n] of e) {
                    this._convertMarkerAdd(t, n, o)
                }
                o.consumable.verifyAllConsumed("insert")
            }

            convertSelection(t, e, n) {
                const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
                const o = this._createConversionApi(n);
                this._addConsumablesForSelection(o.consumable, t, i);
                this.fire("selection", {selection: t}, o);
                if (!t.isCollapsed) {
                    return
                }
                for (const e of i) {
                    const n = e.getRange();
                    if (!Pm(t.getFirstPosition(), e, o.mapper)) {
                        continue
                    }
                    const i = {item: t, markerName: e.name, markerRange: n};
                    if (o.consumable.test(t, "addMarker:" + e.name)) {
                        this.fire(`addMarker:${e.name}`, i, o)
                    }
                }
                for (const e of t.getAttributeKeys()) {
                    const n = {
                        item: t,
                        range: t.getFirstRange(),
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: t.getAttribute(e)
                    };
                    if (o.consumable.test(t, "attribute:" + n.attributeKey)) {
                        this.fire(`attribute:${n.attributeKey}:$text`, n, o)
                    }
                }
            }

            _convertInsert(t, e, n = {}) {
                if (!n.doNotAddConsumables) {
                    this._addConsumablesForInsert(e.consumable, Array.from(t))
                }
                for (const n of Array.from(t.getWalker({shallow: true})).map(Rm)) {
                    this._testAndFire("insert", n, e)
                }
            }

            _convertRemove(t, e, n, i) {
                this.fire(`remove:${n}`, {position: t, length: e}, i)
            }

            _convertAttribute(t, e, n, i, o) {
                this._addConsumablesForRange(o.consumable, t, `attribute:${e}`);
                for (const r of t) {
                    const t = {
                        item: r.item,
                        range: Em._createFromPositionAndShift(r.previousPosition, r.length),
                        attributeKey: e,
                        attributeOldValue: n,
                        attributeNewValue: i
                    };
                    this._testAndFire(`attribute:${e}`, t, o)
                }
            }

            _convertReinsert(t, e) {
                const n = Array.from(t.getWalker({shallow: true}));
                this._addConsumablesForInsert(e.consumable, n);
                for (const t of n.map(Rm)) {
                    this._testAndFire("insert", {...t, reconversion: true}, e)
                }
            }

            _convertMarkerAdd(t, e, n) {
                if (e.root.rootName == "$graveyard") {
                    return
                }
                const i = `addMarker:${t}`;
                n.consumable.add(e, i);
                this.fire(i, {markerName: t, markerRange: e}, n);
                if (!n.consumable.consume(e, i)) {
                    return
                }
                this._addConsumablesForRange(n.consumable, e, i);
                for (const o of e.getItems()) {
                    if (!n.consumable.test(o, i)) {
                        continue
                    }
                    const r = {item: o, range: Em._createOn(o), markerName: t, markerRange: e};
                    this.fire(i, r, n)
                }
            }

            _convertMarkerRemove(t, e, n) {
                if (e.root.rootName == "$graveyard") {
                    return
                }
                this.fire(`removeMarker:${t}`, {markerName: t, markerRange: e}, n)
            }

            _reduceChanges(t) {
                const e = {changes: t};
                this.fire("reduceChanges", e);
                return e.changes
            }

            _addConsumablesForInsert(t, e) {
                for (const n of e) {
                    const e = n.item;
                    if (t.test(e, "insert") === null) {
                        t.add(e, "insert");
                        for (const n of e.getAttributeKeys()) {
                            t.add(e, "attribute:" + n)
                        }
                    }
                }
                return t
            }

            _addConsumablesForRange(t, e, n) {
                for (const i of e.getItems()) {
                    t.add(i, n)
                }
                return t
            }

            _addConsumablesForSelection(t, e, n) {
                t.add(e, "selection");
                for (const i of n) {
                    t.add(e, "addMarker:" + i.name)
                }
                for (const n of e.getAttributeKeys()) {
                    t.add(e, "attribute:" + n)
                }
                return t
            }

            _testAndFire(t, e, n) {
                const i = Im(t, e);
                const o = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item;
                const r = this._firedEventsMap.get(n);
                const s = r.get(o);
                if (!s) {
                    r.set(o, new Set([i]))
                } else if (!s.has(i)) {
                    s.add(i)
                } else {
                    return
                }
                this.fire(i, e, n)
            }

            _testAndFireAddAttributes(t, e) {
                const n = {item: t, range: Em._createOn(t)};
                for (const t of n.item.getAttributeKeys()) {
                    n.attributeKey = t;
                    n.attributeOldValue = null;
                    n.attributeNewValue = n.item.getAttribute(t);
                    this._testAndFire(`attribute:${t}`, n, e)
                }
            }

            _createConversionApi(t, e = new Set, n = {}) {
                const i = {
                    ...this._conversionApi,
                    consumable: new Dm,
                    writer: t,
                    options: n,
                    convertItem: t => this._convertInsert(Em._createOn(t), i),
                    convertChildren: t => this._convertInsert(Em._createIn(t), i, {doNotAddConsumables: true}),
                    convertAttributes: t => this._testAndFireAddAttributes(t, i),
                    canReuseView: t => !e.has(i.mapper.toModelElement(t))
                };
                this._firedEventsMap.set(i, new Map);
                return i
            }
        }

        function Pm(t, e, n) {
            const i = e.getRange();
            const o = Array.from(t.getAncestors());
            o.shift();
            o.reverse();
            const r = o.some((t => {
                if (i.containsItem(t)) {
                    const e = n.toViewElement(t);
                    return !!e.getCustomProperty("addHighlight")
                }
            }));
            return !r
        }

        function Im(t, e) {
            const n = e.item.is("element") ? e.item.name : "$text";
            return `${t}:${n}`
        }

        function Rm(t) {
            const e = t.item;
            const n = Em._createFromPositionAndShift(t.previousPosition, t.length);
            return {item: e, range: n}
        }

        class zm extends (j(dm)) {
            constructor(...t) {
                super();
                this._lastRangeBackward = false;
                this._ranges = [];
                this._attrs = new Map;
                if (t.length) {
                    this.setTo(...t)
                }
            }

            get anchor() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.end : t.start
                }
                return null
            }

            get focus() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.start : t.end
                }
                return null
            }

            get isCollapsed() {
                const t = this._ranges.length;
                if (t === 1) {
                    return this._ranges[0].isCollapsed
                } else {
                    return false
                }
            }

            get rangeCount() {
                return this._ranges.length
            }

            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }

            isEqual(t) {
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const i of t._ranges) {
                        if (e.isEqual(i)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            * getRanges() {
                for (const t of this._ranges) {
                    yield new Em(t.start, t.end)
                }
            }

            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? new Em(t.start, t.end) : null
            }

            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? new Em(t.start, t.end) : null
            }

            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }

            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }

            setTo(...t) {
                let [e, n, i] = t;
                if (typeof n == "object") {
                    i = n;
                    n = undefined
                }
                if (e === null) {
                    this._setRanges([])
                } else if (e instanceof zm) {
                    this._setRanges(e.getRanges(), e.isBackward)
                } else if (e && typeof e.getRanges == "function") {
                    this._setRanges(e.getRanges(), e.isBackward)
                } else if (e instanceof Em) {
                    this._setRanges([e], !!i && !!i.backward)
                } else if (e instanceof wm) {
                    this._setRanges([new Em(e)])
                } else if (e instanceof um) {
                    const t = !!i && !!i.backward;
                    let o;
                    if (n == "in") {
                        o = Em._createIn(e)
                    } else if (n == "on") {
                        o = Em._createOn(e)
                    } else if (n !== undefined) {
                        o = new Em(wm._createAt(e, n))
                    } else {
                        throw new P("model-selection-setto-required-second-parameter", [this, e])
                    }
                    this._setRanges([o], t)
                } else if (yt(e)) {
                    this._setRanges(e, i && !!i.backward)
                } else {
                    throw new P("model-selection-setto-not-selectable", [this, e])
                }
            }

            _setRanges(t, e = false) {
                const n = Array.from(t);
                const i = n.some((e => {
                    if (!(e instanceof Em)) {
                        throw new P("model-selection-set-ranges-not-range", [this, t])
                    }
                    return this._ranges.every((t => !t.isEqual(e)))
                }));
                if (n.length === this._ranges.length && !i) {
                    return
                }
                this._replaceAllRanges(n);
                this._lastRangeBackward = !!e;
                this.fire("change:range", {directChange: true})
            }

            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new P("model-selection-setfocus-no-ranges", [this, t])
                }
                const n = wm._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const i = this.anchor;
                if (this._ranges.length) {
                    this._popRange()
                }
                if (n.compareWith(i) == "before") {
                    this._pushRange(new Em(n, i));
                    this._lastRangeBackward = true
                } else {
                    this._pushRange(new Em(i, n));
                    this._lastRangeBackward = false
                }
                this.fire("change:range", {directChange: true})
            }

            getAttribute(t) {
                return this._attrs.get(t)
            }

            getAttributes() {
                return this._attrs.entries()
            }

            getAttributeKeys() {
                return this._attrs.keys()
            }

            hasAttribute(t) {
                return this._attrs.has(t)
            }

            removeAttribute(t) {
                if (this.hasAttribute(t)) {
                    this._attrs.delete(t);
                    this.fire("change:attribute", {attributeKeys: [t], directChange: true})
                }
            }

            setAttribute(t, e) {
                if (this.getAttribute(t) !== e) {
                    this._attrs.set(t, e);
                    this.fire("change:attribute", {attributeKeys: [t], directChange: true})
                }
            }

            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }

            * getSelectedBlocks() {
                const t = new WeakSet;
                for (const e of this.getRanges()) {
                    const n = Lm(e.start, t);
                    if (n && Om(n, e)) {
                        yield n
                    }
                    for (const n of e.getWalker()) {
                        const i = n.item;
                        if (n.type == "elementEnd" && Fm(i, t, e)) {
                            yield i
                        }
                    }
                    const i = Lm(e.end, t);
                    if (i && !e.end.isTouching(wm._createAt(i, 0)) && Om(i, e)) {
                        yield i
                    }
                }
            }

            containsEntireContent(t = this.anchor.root) {
                const e = wm._createAt(t, 0);
                const n = wm._createAt(t, "end");
                return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
            }

            _pushRange(t) {
                this._checkRange(t);
                this._ranges.push(new Em(t.start, t.end))
            }

            _checkRange(t) {
                for (let e = 0; e < this._ranges.length; e++) {
                    if (t.isIntersecting(this._ranges[e])) {
                        throw new P("model-selection-range-intersects", [this, t], {
                            addedRange: t,
                            intersectingRange: this._ranges[e]
                        })
                    }
                }
            }

            _replaceAllRanges(t) {
                this._removeAllRanges();
                for (const e of t) {
                    this._pushRange(e)
                }
            }

            _removeAllRanges() {
                while (this._ranges.length > 0) {
                    this._popRange()
                }
            }

            _popRange() {
                this._ranges.pop()
            }
        }

        zm.prototype.is = function (t) {
            return t === "selection" || t === "model:selection"
        };

        function Vm(t, e) {
            if (e.has(t)) {
                return false
            }
            e.add(t);
            return t.root.document.model.schema.isBlock(t) && !!t.parent
        }

        function Fm(t, e, n) {
            return Vm(t, e) && Om(t, n)
        }

        function Lm(t, e) {
            const n = t.parent;
            const i = n.root.document.model.schema;
            const o = t.parent.getAncestors({parentFirst: true, includeSelf: true});
            let r = false;
            const s = o.find((t => {
                if (r) {
                    return false
                }
                r = i.isLimit(t);
                return !r && Vm(t, e)
            }));
            o.forEach((t => e.add(t)));
            return s
        }

        function Om(t, e) {
            const n = Nm(t);
            if (!n) {
                return true
            }
            const i = e.containsRange(Em._createOn(n), true);
            return !i
        }

        function Nm(t) {
            const e = t.root.document.model.schema;
            let n = t.parent;
            while (n) {
                if (e.isBlock(n)) {
                    return n
                }
                n = n.parent
            }
        }

        class Mm extends (j(Em)) {
            constructor(t, e) {
                super(t, e);
                Hm.call(this)
            }

            detach() {
                this.stopListening()
            }

            toRange() {
                return new Em(this.start, this.end)
            }

            static fromRange(t) {
                return new Mm(t.start, t.end)
            }
        }

        Mm.prototype.is = function (t) {
            return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range"
        };

        function Hm() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                Wm.call(this, n)
            }), {priority: "low"})
        }

        function Wm(t) {
            const e = this.getTransformedByOperation(t);
            const n = Em._createFromRanges(e);
            const i = !n.isEqual(this);
            const o = qm(this, t);
            let r = null;
            if (i) {
                if (n.root.rootName == "$graveyard") {
                    if (t.type == "remove") {
                        r = t.sourcePosition
                    } else {
                        r = t.deletionPosition
                    }
                }
                const e = this.toRange();
                this.start = n.start;
                this.end = n.end;
                this.fire("change:range", e, {deletionPosition: r})
            } else if (o) {
                this.fire("change:content", this.toRange(), {deletionPosition: r})
            }
        }

        function qm(t, e) {
            switch (e.type) {
                case"insert":
                    return t.containsPosition(e.position);
                case"move":
                case"remove":
                case"reinsert":
                case"merge":
                    return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                case"split":
                    return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
            }
            return false
        }

        const jm = "selection:";

        class $m extends (j(dm)) {
            constructor(t) {
                super();
                this._selection = new Um(t);
                this._selection.delegate("change:range").to(this);
                this._selection.delegate("change:attribute").to(this);
                this._selection.delegate("change:marker").to(this)
            }

            get isCollapsed() {
                return this._selection.isCollapsed
            }

            get anchor() {
                return this._selection.anchor
            }

            get focus() {
                return this._selection.focus
            }

            get rangeCount() {
                return this._selection.rangeCount
            }

            get hasOwnRange() {
                return this._selection.hasOwnRange
            }

            get isBackward() {
                return this._selection.isBackward
            }

            get isGravityOverridden() {
                return this._selection.isGravityOverridden
            }

            get markers() {
                return this._selection.markers
            }

            get _ranges() {
                return this._selection._ranges
            }

            getRanges() {
                return this._selection.getRanges()
            }

            getFirstPosition() {
                return this._selection.getFirstPosition()
            }

            getLastPosition() {
                return this._selection.getLastPosition()
            }

            getFirstRange() {
                return this._selection.getFirstRange()
            }

            getLastRange() {
                return this._selection.getLastRange()
            }

            getSelectedBlocks() {
                return this._selection.getSelectedBlocks()
            }

            getSelectedElement() {
                return this._selection.getSelectedElement()
            }

            containsEntireContent(t) {
                return this._selection.containsEntireContent(t)
            }

            destroy() {
                this._selection.destroy()
            }

            getAttributeKeys() {
                return this._selection.getAttributeKeys()
            }

            getAttributes() {
                return this._selection.getAttributes()
            }

            getAttribute(t) {
                return this._selection.getAttribute(t)
            }

            hasAttribute(t) {
                return this._selection.hasAttribute(t)
            }

            refresh() {
                this._selection.updateMarkers();
                this._selection._updateAttributes(false)
            }

            observeMarkers(t) {
                this._selection.observeMarkers(t)
            }

            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }

            _setTo(...t) {
                this._selection.setTo(...t)
            }

            _setAttribute(t, e) {
                this._selection.setAttribute(t, e)
            }

            _removeAttribute(t) {
                this._selection.removeAttribute(t)
            }

            _getStoredAttributes() {
                return this._selection.getStoredAttributes()
            }

            _overrideGravity() {
                return this._selection.overrideGravity()
            }

            _restoreGravity(t) {
                this._selection.restoreGravity(t)
            }

            static _getStoreAttributeKey(t) {
                return jm + t
            }

            static _isStoreAttributeKey(t) {
                return t.startsWith(jm)
            }
        }

        $m.prototype.is = function (t) {
            return t === "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection"
        };

        class Um extends zm {
            constructor(t) {
                super();
                this.markers = new rc({idProperty: "name"});
                this._model = t.model;
                this._document = t;
                this._attributePriority = new Map;
                this._selectionRestorePosition = null;
                this._hasChangedRange = false;
                this._overriddenGravityRegister = new Set;
                this._observedMarkers = new Set;
                this.listenTo(this._model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") {
                        return
                    }
                    if (this._ranges.length == 0 && this._selectionRestorePosition) {
                        this._fixGraveyardSelection(this._selectionRestorePosition)
                    }
                    this._selectionRestorePosition = null;
                    if (this._hasChangedRange) {
                        this._hasChangedRange = false;
                        this.fire("change:range", {directChange: false})
                    }
                }), {priority: "lowest"});
                this.on("change:range", (() => {
                    this._validateSelectionRanges(this.getRanges())
                }));
                this.listenTo(this._model.markers, "update", ((t, e, n, i) => {
                    this._updateMarker(e, i)
                }));
                this.listenTo(this._document, "change", ((t, e) => {
                    Km(this._model, e)
                }))
            }

            get isCollapsed() {
                const t = this._ranges.length;
                return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
            }

            get anchor() {
                return super.anchor || this._document._getDefaultRange().start
            }

            get focus() {
                return super.focus || this._document._getDefaultRange().end
            }

            get rangeCount() {
                return this._ranges.length ? this._ranges.length : 1
            }

            get hasOwnRange() {
                return this._ranges.length > 0
            }

            get isGravityOverridden() {
                return !!this._overriddenGravityRegister.size
            }

            destroy() {
                for (let t = 0; t < this._ranges.length; t++) {
                    this._ranges[t].detach()
                }
                this.stopListening()
            }

            * getRanges() {
                if (this._ranges.length) {
                    yield* super.getRanges()
                } else {
                    yield this._document._getDefaultRange()
                }
            }

            getFirstRange() {
                return super.getFirstRange() || this._document._getDefaultRange()
            }

            getLastRange() {
                return super.getLastRange() || this._document._getDefaultRange()
            }

            setTo(...t) {
                super.setTo(...t);
                this._updateAttributes(true);
                this.updateMarkers()
            }

            setFocus(t, e) {
                super.setFocus(t, e);
                this._updateAttributes(true);
                this.updateMarkers()
            }

            setAttribute(t, e) {
                if (this._setAttribute(t, e)) {
                    const e = [t];
                    this.fire("change:attribute", {attributeKeys: e, directChange: true})
                }
            }

            removeAttribute(t) {
                if (this._removeAttribute(t)) {
                    const e = [t];
                    this.fire("change:attribute", {attributeKeys: e, directChange: true})
                }
            }

            overrideGravity() {
                const t = E();
                this._overriddenGravityRegister.add(t);
                if (this._overriddenGravityRegister.size === 1) {
                    this._updateAttributes(true)
                }
                return t
            }

            restoreGravity(t) {
                if (!this._overriddenGravityRegister.has(t)) {
                    throw new P("document-selection-gravity-wrong-restore", this, {uid: t})
                }
                this._overriddenGravityRegister.delete(t);
                if (!this.isGravityOverridden) {
                    this._updateAttributes(true)
                }
            }

            observeMarkers(t) {
                this._observedMarkers.add(t);
                this.updateMarkers()
            }

            _replaceAllRanges(t) {
                this._validateSelectionRanges(t);
                super._replaceAllRanges(t)
            }

            _popRange() {
                this._ranges.pop().detach()
            }

            _pushRange(t) {
                const e = this._prepareRange(t);
                if (e) {
                    this._ranges.push(e)
                }
            }

            _validateSelectionRanges(t) {
                for (const e of t) {
                    if (!this._document._validateSelectionRange(e)) {
                        throw new P("document-selection-wrong-position", this, {range: e})
                    }
                }
            }

            _prepareRange(t) {
                this._checkRange(t);
                if (t.root == this._document.graveyard) {
                    return
                }
                const e = Mm.fromRange(t);
                e.on("change:range", ((t, n, i) => {
                    this._hasChangedRange = true;
                    if (e.root == this._document.graveyard) {
                        this._selectionRestorePosition = i.deletionPosition;
                        const t = this._ranges.indexOf(e);
                        this._ranges.splice(t, 1);
                        e.detach()
                    }
                }));
                return e
            }

            updateMarkers() {
                if (!this._observedMarkers.size) {
                    return
                }
                const t = [];
                let e = false;
                for (const e of this._model.markers) {
                    const n = e.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(n)) {
                        continue
                    }
                    const i = e.getRange();
                    for (const n of this.getRanges()) {
                        if (i.containsRange(n, !n.isCollapsed)) {
                            t.push(e)
                        }
                    }
                }
                const n = Array.from(this.markers);
                for (const n of t) {
                    if (!this.markers.has(n)) {
                        this.markers.add(n);
                        e = true
                    }
                }
                for (const n of Array.from(this.markers)) {
                    if (!t.includes(n)) {
                        this.markers.remove(n);
                        e = true
                    }
                }
                if (e) {
                    this.fire("change:marker", {oldMarkers: n, directChange: false})
                }
            }

            _updateMarker(t, e) {
                const n = t.name.split(":", 1)[0];
                if (!this._observedMarkers.has(n)) {
                    return
                }
                let i = false;
                const o = Array.from(this.markers);
                const r = this.markers.has(t);
                if (!e) {
                    if (r) {
                        this.markers.remove(t);
                        i = true
                    }
                } else {
                    let n = false;
                    for (const t of this.getRanges()) {
                        if (e.containsRange(t, !t.isCollapsed)) {
                            n = true;
                            break
                        }
                    }
                    if (n && !r) {
                        this.markers.add(t);
                        i = true
                    } else if (!n && r) {
                        this.markers.remove(t);
                        i = true
                    }
                }
                if (i) {
                    this.fire("change:marker", {oldMarkers: o, directChange: false})
                }
            }

            _updateAttributes(t) {
                const e = dc(this._getSurroundingAttributes());
                const n = dc(this.getAttributes());
                if (t) {
                    this._attributePriority = new Map;
                    this._attrs = new Map
                } else {
                    for (const [t, e] of this._attributePriority) {
                        if (e == "low") {
                            this._attrs.delete(t);
                            this._attributePriority.delete(t)
                        }
                    }
                }
                this._setAttributesTo(e);
                const i = [];
                for (const [t, e] of this.getAttributes()) {
                    if (!n.has(t) || n.get(t) !== e) {
                        i.push(t)
                    }
                }
                for (const [t] of n) {
                    if (!this.hasAttribute(t)) {
                        i.push(t)
                    }
                }
                if (i.length > 0) {
                    this.fire("change:attribute", {attributeKeys: i, directChange: false})
                }
            }

            _setAttribute(t, e, n = true) {
                const i = n ? "normal" : "low";
                if (i == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                const o = super.getAttribute(t);
                if (o === e) {
                    return false
                }
                this._attrs.set(t, e);
                this._attributePriority.set(t, i);
                return true
            }

            _removeAttribute(t, e = true) {
                const n = e ? "normal" : "low";
                if (n == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                this._attributePriority.set(t, n);
                if (!super.hasAttribute(t)) {
                    return false
                }
                this._attrs.delete(t);
                return true
            }

            _setAttributesTo(t) {
                const e = new Set;
                for (const [e, n] of this.getAttributes()) {
                    if (t.get(e) === n) {
                        continue
                    }
                    this._removeAttribute(e, false)
                }
                for (const [n, i] of t) {
                    const t = this._setAttribute(n, i, false);
                    if (t) {
                        e.add(n)
                    }
                }
                return e
            }

            * getStoredAttributes() {
                const t = this.getFirstPosition().parent;
                if (this.isCollapsed && t.isEmpty) {
                    for (const e of t.getAttributeKeys()) {
                        if (e.startsWith(jm)) {
                            const n = e.substr(jm.length);
                            yield[n, t.getAttribute(e)]
                        }
                    }
                }
            }

            _getSurroundingAttributes() {
                const t = this.getFirstPosition();
                const e = this._model.schema;
                let n = null;
                if (!this.isCollapsed) {
                    const t = this.getFirstRange();
                    for (const i of t) {
                        if (i.item.is("element") && e.isObject(i.item)) {
                            break
                        }
                        if (i.type == "text") {
                            n = i.item.getAttributes();
                            break
                        }
                    }
                } else {
                    const i = t.textNode ? t.textNode : t.nodeBefore;
                    const o = t.textNode ? t.textNode : t.nodeAfter;
                    if (!this.isGravityOverridden) {
                        n = Gm(i)
                    }
                    if (!n) {
                        n = Gm(o)
                    }
                    if (!this.isGravityOverridden && !n) {
                        let t = i;
                        while (t && !e.isInline(t) && !n) {
                            t = t.previousSibling;
                            n = Gm(t)
                        }
                    }
                    if (!n) {
                        let t = o;
                        while (t && !e.isInline(t) && !n) {
                            t = t.nextSibling;
                            n = Gm(t)
                        }
                    }
                    if (!n) {
                        n = this.getStoredAttributes()
                    }
                }
                return n
            }

            _fixGraveyardSelection(t) {
                const e = this._model.schema.getNearestSelectionRange(t);
                if (e) {
                    this._pushRange(e)
                }
            }
        }

        function Gm(t) {
            if (t instanceof gm || t instanceof fm) {
                return t.getAttributes()
            }
            return null
        }

        function Km(t, e) {
            const n = t.document.differ;
            for (const i of n.getChanges()) {
                if (i.type != "insert") {
                    continue
                }
                const n = i.position.parent;
                const o = i.length === n.maxOffset;
                if (o) {
                    t.enqueueChange(e, (t => {
                        const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(jm)));
                        for (const i of e) {
                            t.removeAttribute(i, n)
                        }
                    }))
                }
            }
        }

        class Zm {
            constructor(t) {
                this._dispatchers = t
            }

            add(t) {
                for (const e of this._dispatchers) {
                    t(e)
                }
                return this
            }
        }

        var Jm = 1, Ym = 4;

        function Qm(t) {
            return Va(t, Jm | Ym)
        }

        const Xm = Qm;

        class tp extends Zm {
            elementToElement(t) {
                return this.add(Cp(t))
            }

            elementToStructure(t) {
                return this.add(vp(t))
            }

            attributeToElement(t) {
                return this.add(yp(t))
            }

            attributeToAttribute(t) {
                return this.add(xp(t))
            }

            markerToElement(t) {
                return this.add(Ep(t))
            }

            markerToHighlight(t) {
                return this.add(Dp(t))
            }

            markerToData(t) {
                return this.add(Sp(t))
            }
        }

        function ep() {
            return (t, e, n) => {
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const i = n.writer;
                const o = n.mapper.toViewPosition(e.range.start);
                const r = i.createText(e.item.data);
                i.insert(o, r)
            }
        }

        function np() {
            return (t, e, n) => {
                n.convertAttributes(e.item);
                if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) {
                    n.convertChildren(e.item)
                }
            }
        }

        function ip() {
            return (t, e, n) => {
                const i = n.mapper.toViewPosition(e.position);
                const o = e.position.getShiftedBy(e.length);
                const r = n.mapper.toViewPosition(o, {isPhantom: true});
                const s = n.writer.createRange(i, r);
                const a = n.writer.remove(s.getTrimmed());
                for (const t of n.writer.createRangeIn(a).getItems()) {
                    n.mapper.unbindViewElement(t, {defer: true})
                }
            }
        }

        function op(t, e) {
            const n = t.createAttributeElement("span", e.attributes);
            if (e.classes) {
                n._addClass(e.classes)
            }
            if (typeof e.priority === "number") {
                n._priority = e.priority
            }
            n._id = e.id;
            return n
        }

        function rp() {
            return (t, e, n) => {
                const i = e.selection;
                if (i.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(i, "selection")) {
                    return
                }
                const o = [];
                for (const t of i.getRanges()) {
                    o.push(n.mapper.toViewRange(t))
                }
                n.writer.setSelection(o, {backward: i.isBackward})
            }
        }

        function sp() {
            return (t, e, n) => {
                const i = e.selection;
                if (!i.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(i, "selection")) {
                    return
                }
                const o = n.writer;
                const r = i.getFirstPosition();
                const s = n.mapper.toViewPosition(r);
                const a = o.breakAttributes(s);
                o.setSelection(a)
            }
        }

        function ap() {
            return (t, e, n) => {
                const i = n.writer;
                const o = i.document.selection;
                for (const t of o.getRanges()) {
                    if (t.isCollapsed) {
                        if (t.end.parent.isAttached()) {
                            n.writer.mergeAttributes(t.start)
                        }
                    }
                }
                i.setSelection(null)
            }
        }

        function lp(t) {
            return (e, n, i) => {
                if (!i.consumable.test(n.item, e.name)) {
                    return
                }
                const o = t(n.attributeOldValue, i, n);
                const r = t(n.attributeNewValue, i, n);
                if (!o && !r) {
                    return
                }
                i.consumable.consume(n.item, e.name);
                const s = i.writer;
                const a = s.document.selection;
                if (n.item instanceof zm || n.item instanceof $m) {
                    s.wrap(a.getFirstRange(), r)
                } else {
                    let t = i.mapper.toViewRange(n.range);
                    if (n.attributeOldValue !== null && o) {
                        t = s.unwrap(t, o)
                    }
                    if (n.attributeNewValue !== null && r) {
                        s.wrap(t, r)
                    }
                }
            }
        }

        function cp(t, e = qp) {
            return (n, i, o) => {
                if (!e(i.item, o.consumable, {preflight: true})) {
                    return
                }
                const r = t(i.item, o, i);
                if (!r) {
                    return
                }
                e(i.item, o.consumable);
                const s = o.mapper.toViewPosition(i.range.start);
                o.mapper.bindElements(i.item, r);
                o.writer.insert(s, r);
                o.convertAttributes(i.item);
                Hp(r, i.item.getChildren(), o, {reconversion: i.reconversion})
            }
        }

        function dp(t, e) {
            return (n, i, o) => {
                if (!e(i.item, o.consumable, {preflight: true})) {
                    return
                }
                const r = new Map;
                o.writer._registerSlotFactory(Op(i.item, r, o));
                const s = t(i.item, o, i);
                o.writer._clearSlotFactory();
                if (!s) {
                    return
                }
                Np(i.item, r, o);
                e(i.item, o.consumable);
                const a = o.mapper.toViewPosition(i.range.start);
                o.mapper.bindElements(i.item, s);
                o.writer.insert(a, s);
                o.convertAttributes(i.item);
                Mp(s, r, o, {reconversion: i.reconversion})
            }
        }

        function up(t) {
            return (e, n, i) => {
                n.isOpening = true;
                const o = t(n, i);
                n.isOpening = false;
                const r = t(n, i);
                if (!o || !r) {
                    return
                }
                const s = n.markerRange;
                if (s.isCollapsed && !i.consumable.consume(s, e.name)) {
                    return
                }
                for (const t of s) {
                    if (!i.consumable.consume(t.item, e.name)) {
                        return
                    }
                }
                const a = i.mapper;
                const l = i.writer;
                l.insert(a.toViewPosition(s.start), o);
                i.mapper.bindElementToMarker(o, n.markerName);
                if (!s.isCollapsed) {
                    l.insert(a.toViewPosition(s.end), r);
                    i.mapper.bindElementToMarker(r, n.markerName)
                }
                e.stop()
            }
        }

        function hp() {
            return (t, e, n) => {
                const i = n.mapper.markerNameToElements(e.markerName);
                if (!i) {
                    return
                }
                for (const t of i) {
                    n.mapper.unbindElementFromMarkerName(t, e.markerName);
                    n.writer.clear(n.writer.createRangeOn(t), t)
                }
                n.writer.clearClonedElementsGroup(e.markerName);
                t.stop()
            }
        }

        function fp(t) {
            return (e, n, i) => {
                const o = t(n.markerName, i);
                if (!o) {
                    return
                }
                const r = n.markerRange;
                if (!i.consumable.consume(r, e.name)) {
                    return
                }
                gp(r, false, i, n, o);
                gp(r, true, i, n, o);
                e.stop()
            }
        }

        function gp(t, e, n, i, o) {
            const r = e ? t.start : t.end;
            const s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null;
            const a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
            if (s || a) {
                let t;
                let r;
                if (e && s || !e && !a) {
                    t = s;
                    r = true
                } else {
                    t = a;
                    r = false
                }
                const l = n.mapper.toViewElement(t);
                if (l) {
                    mp(l, e, r, n, i, o);
                    return
                }
            }
            const l = n.mapper.toViewPosition(r);
            pp(l, e, n, i, o)
        }

        function mp(t, e, n, i, o, r) {
            const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`;
            const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
            a.unshift(r.name);
            i.writer.setAttribute(s, a.join(","), t);
            i.mapper.bindElementToMarker(t, o.markerName)
        }

        function pp(t, e, n, i, o) {
            const r = `${o.group}-${e ? "start" : "end"}`;
            const s = o.name ? {name: o.name} : null;
            const a = n.writer.createUIElement(r, s);
            n.writer.insert(t, a);
            n.mapper.bindElementToMarker(a, i.markerName)
        }

        function bp(t) {
            return (e, n, i) => {
                const o = t(n.markerName, i);
                if (!o) {
                    return
                }
                const r = i.mapper.markerNameToElements(n.markerName);
                if (!r) {
                    return
                }
                for (const t of r) {
                    i.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("containerElement")) {
                        s(`data-${o.group}-start-before`, t);
                        s(`data-${o.group}-start-after`, t);
                        s(`data-${o.group}-end-before`, t);
                        s(`data-${o.group}-end-after`, t)
                    } else {
                        i.writer.clear(i.writer.createRangeOn(t), t)
                    }
                }
                i.writer.clearClonedElementsGroup(n.markerName);
                e.stop();

                function s(t, e) {
                    if (e.hasAttribute(t)) {
                        const n = new Set(e.getAttribute(t).split(","));
                        n.delete(o.name);
                        if (n.size == 0) {
                            i.writer.removeAttribute(t, e)
                        } else {
                            i.writer.setAttribute(t, Array.from(n).join(","), e)
                        }
                    }
                }
            }
        }

        function kp(t) {
            return (e, n, i) => {
                if (!i.consumable.test(n.item, e.name)) {
                    return
                }
                const o = t(n.attributeOldValue, i, n);
                const r = t(n.attributeNewValue, i, n);
                if (!o && !r) {
                    return
                }
                i.consumable.consume(n.item, e.name);
                const s = i.mapper.toViewElement(n.item);
                const a = i.writer;
                if (!s) {
                    throw new P("conversion-attribute-to-attribute-on-text", i.dispatcher, n)
                }
                if (n.attributeOldValue !== null && o) {
                    if (o.key == "class") {
                        const t = Zl(o.value);
                        for (const e of t) {
                            a.removeClass(e, s)
                        }
                    } else if (o.key == "style") {
                        const t = Object.keys(o.value);
                        for (const e of t) {
                            a.removeStyle(e, s)
                        }
                    } else {
                        a.removeAttribute(o.key, s)
                    }
                }
                if (n.attributeNewValue !== null && r) {
                    if (r.key == "class") {
                        const t = Zl(r.value);
                        for (const e of t) {
                            a.addClass(e, s)
                        }
                    } else if (r.key == "style") {
                        const t = Object.keys(r.value);
                        for (const e of t) {
                            a.setStyle(e, r.value[e], s)
                        }
                    } else {
                        a.setAttribute(r.key, r.value, s)
                    }
                }
            }
        }

        function wp(t) {
            return (e, n, i) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof zm || n.item instanceof $m) && !n.item.is("$textProxy")) {
                    return
                }
                const o = zp(t, n, i);
                if (!o) {
                    return
                }
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const r = i.writer;
                const s = op(r, o);
                const a = r.document.selection;
                if (n.item instanceof zm || n.item instanceof $m) {
                    r.wrap(a.getFirstRange(), s)
                } else {
                    const t = i.mapper.toViewRange(n.range);
                    const e = r.wrap(t, s);
                    for (const t of e.getItems()) {
                        if (t.is("attributeElement") && t.isSimilar(s)) {
                            i.mapper.bindElementToMarker(t, n.markerName);
                            break
                        }
                    }
                }
            }
        }

        function _p(t) {
            return (e, n, i) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof mm)) {
                    return
                }
                const o = zp(t, n, i);
                if (!o) {
                    return
                }
                if (!i.consumable.test(n.item, e.name)) {
                    return
                }
                const r = i.mapper.toViewElement(n.item);
                if (r && r.getCustomProperty("addHighlight")) {
                    i.consumable.consume(n.item, e.name);
                    for (const t of Em._createIn(n.item)) {
                        i.consumable.consume(t.item, e.name)
                    }
                    const t = r.getCustomProperty("addHighlight");
                    t(r, o, i.writer);
                    i.mapper.bindElementToMarker(r, n.markerName)
                }
            }
        }

        function Ap(t) {
            return (e, n, i) => {
                if (n.markerRange.isCollapsed) {
                    return
                }
                const o = zp(t, n, i);
                if (!o) {
                    return
                }
                const r = op(i.writer, o);
                const s = i.mapper.markerNameToElements(n.markerName);
                if (!s) {
                    return
                }
                for (const t of s) {
                    i.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("attributeElement")) {
                        i.writer.unwrap(i.writer.createRangeOn(t), r)
                    } else {
                        const e = t.getCustomProperty("removeHighlight");
                        e(t, o.id, i.writer)
                    }
                }
                i.writer.clearClonedElementsGroup(n.markerName);
                e.stop()
            }
        }

        function Cp(t) {
            const e = Tp(t.model);
            const n = Bp(t.view, "container");
            if (e.attributes.length) {
                e.children = true
            }
            return i => {
                i.on(`insert:${e.name}`, cp(n, Lp(e)), {priority: t.converterPriority || "normal"});
                if (e.children || e.attributes.length) {
                    i.on("reduceChanges", Fp(e), {priority: "low"})
                }
            }
        }

        function vp(t) {
            const e = Tp(t.model);
            const n = Bp(t.view, "container");
            e.children = true;
            return i => {
                if (i._conversionApi.schema.checkChild(e.name, "$text")) {
                    throw new P("conversion-element-to-structure-disallowed-text", i, {elementName: e.name})
                }
                i.on(`insert:${e.name}`, dp(n, Lp(e)), {priority: t.converterPriority || "normal"});
                i.on("reduceChanges", Fp(e), {priority: "low"})
            }
        }

        function yp(t) {
            t = Xm(t);
            let e = t.model;
            if (typeof e == "string") {
                e = {key: e}
            }
            let n = `attribute:${e.key}`;
            if (e.name) {
                n += ":" + e.name
            }
            if (e.values) {
                for (const n of e.values) {
                    t.view[n] = Bp(t.view[n], "attribute")
                }
            } else {
                t.view = Bp(t.view, "attribute")
            }
            const i = Ip(t);
            return e => {
                e.on(n, lp(i), {priority: t.converterPriority || "normal"})
            }
        }

        function xp(t) {
            t = Xm(t);
            let e = t.model;
            if (typeof e == "string") {
                e = {key: e}
            }
            let n = `attribute:${e.key}`;
            if (e.name) {
                n += ":" + e.name
            }
            if (e.values) {
                for (const n of e.values) {
                    t.view[n] = Rp(t.view[n])
                }
            } else {
                t.view = Rp(t.view)
            }
            const i = Ip(t);
            return e => {
                e.on(n, kp(i), {priority: t.converterPriority || "normal"})
            }
        }

        function Ep(t) {
            const e = Bp(t.view, "ui");
            return n => {
                n.on(`addMarker:${t.model}`, up(e), {priority: t.converterPriority || "normal"});
                n.on(`removeMarker:${t.model}`, hp(), {priority: t.converterPriority || "normal"})
            }
        }

        function Sp(t) {
            t = Xm(t);
            const e = t.model;
            let n = t.view;
            if (!n) {
                n = n => ({group: e, name: n.substr(t.model.length + 1)})
            }
            return i => {
                i.on(`addMarker:${e}`, fp(n), {priority: t.converterPriority || "normal"});
                i.on(`removeMarker:${e}`, bp(n), {priority: t.converterPriority || "normal"})
            }
        }

        function Dp(t) {
            return e => {
                e.on(`addMarker:${t.model}`, wp(t.view), {priority: t.converterPriority || "normal"});
                e.on(`addMarker:${t.model}`, _p(t.view), {priority: t.converterPriority || "normal"});
                e.on(`removeMarker:${t.model}`, Ap(t.view), {priority: t.converterPriority || "normal"})
            }
        }

        function Tp(t) {
            if (typeof t == "string") {
                t = {name: t}
            }
            if (!t.attributes) {
                t.attributes = []
            } else if (!Array.isArray(t.attributes)) {
                t.attributes = [t.attributes]
            }
            t.children = !!t.children;
            return t
        }

        function Bp(t, e) {
            if (typeof t == "function") {
                return t
            }
            return (n, i) => Pp(t, i, e)
        }

        function Pp(t, e, n) {
            if (typeof t == "string") {
                t = {name: t}
            }
            let i;
            const o = e.writer;
            const r = Object.assign({}, t.attributes);
            if (n == "container") {
                i = o.createContainerElement(t.name, r)
            } else if (n == "attribute") {
                const e = {priority: t.priority || _h.DEFAULT_PRIORITY};
                i = o.createAttributeElement(t.name, r, e)
            } else {
                i = o.createUIElement(t.name, r)
            }
            if (t.styles) {
                const e = Object.keys(t.styles);
                for (const n of e) {
                    o.setStyle(n, t.styles[n], i)
                }
            }
            if (t.classes) {
                const e = t.classes;
                if (typeof e == "string") {
                    o.addClass(e, i)
                } else {
                    for (const t of e) {
                        o.addClass(t, i)
                    }
                }
            }
            return i
        }

        function Ip(t) {
            if (t.model.values) {
                return (e, n, i) => {
                    const o = t.view[e];
                    if (o) {
                        return o(e, n, i)
                    }
                    return null
                }
            } else {
                return t.view
            }
        }

        function Rp(t) {
            if (typeof t == "string") {
                return e => ({key: t, value: e})
            } else if (typeof t == "object") {
                if (t.value) {
                    return () => t
                } else {
                    return e => ({key: t.key, value: e})
                }
            } else {
                return t
            }
        }

        function zp(t, e, n) {
            const i = typeof t == "function" ? t(e, n) : t;
            if (!i) {
                return null
            }
            if (!i.priority) {
                i.priority = 10
            }
            if (!i.id) {
                i.id = e.markerName
            }
            return i
        }

        function Vp(t) {
            return (e, n) => {
                if (!e.is("element", t.name)) {
                    return false
                }
                if (n.type == "attribute") {
                    if (t.attributes.includes(n.attributeKey)) {
                        return true
                    }
                } else {
                    if (t.children) {
                        return true
                    }
                }
                return false
            }
        }

        function Fp(t) {
            const e = Vp(t);
            return (t, n) => {
                const i = [];
                if (!n.reconvertedElements) {
                    n.reconvertedElements = new Set
                }
                for (const t of n.changes) {
                    const o = t.type == "attribute" ? t.range.start.nodeAfter : t.position.parent;
                    if (!o || !e(o, t)) {
                        i.push(t);
                        continue
                    }
                    if (!n.reconvertedElements.has(o)) {
                        n.reconvertedElements.add(o);
                        const t = wm._createBefore(o);
                        i.push({type: "remove", name: o.name, position: t, length: 1}, {
                            type: "reinsert",
                            name: o.name,
                            position: t,
                            length: 1
                        })
                    }
                }
                n.changes = i
            }
        }

        function Lp(t) {
            return (e, n, i = {}) => {
                const o = ["insert"];
                for (const n of t.attributes) {
                    if (e.hasAttribute(n)) {
                        o.push(`attribute:${n}`)
                    }
                }
                if (!o.every((t => n.test(e, t)))) {
                    return false
                }
                if (!i.preflight) {
                    o.forEach((t => n.consume(e, t)))
                }
                return true
            }
        }

        function Op(t, e, n) {
            return (i, o = "children") => {
                const r = i.createContainerElement("$slot");
                let s = null;
                if (o === "children") {
                    s = Array.from(t.getChildren())
                } else if (typeof o == "function") {
                    s = Array.from(t.getChildren()).filter((t => o(t)))
                } else {
                    throw new P("conversion-slot-mode-unknown", n.dispatcher, {modeOrFilter: o})
                }
                e.set(r, s);
                return r
            }
        }

        function Np(t, e, n) {
            const i = Array.from(e.values()).flat();
            const o = new Set(i);
            if (o.size != i.length) {
                throw new P("conversion-slot-filter-overlap", n.dispatcher, {element: t})
            }
            if (o.size != t.childCount) {
                throw new P("conversion-slot-filter-incomplete", n.dispatcher, {element: t})
            }
        }

        function Mp(t, e, n, i) {
            n.mapper.on("modelToViewPosition", s, {priority: "highest"});
            let o = null;
            let r = null;
            for ([o, r] of e) {
                Hp(t, r, n, i);
                n.writer.move(n.writer.createRangeIn(o), n.writer.createPositionBefore(o));
                n.writer.remove(o)
            }
            n.mapper.off("modelToViewPosition", s);

            function s(t, e) {
                const n = e.modelPosition.nodeAfter;
                const i = r.indexOf(n);
                if (i < 0) {
                    return
                }
                e.viewPosition = e.mapper.findPositionIn(o, i)
            }
        }

        function Hp(t, e, n, i) {
            for (const o of e) {
                if (!Wp(t.root, o, n, i)) {
                    n.convertItem(o)
                }
            }
        }

        function Wp(t, e, n, i) {
            const {writer: o, mapper: r} = n;
            if (!i.reconversion) {
                return false
            }
            const s = r.toViewElement(e);
            if (!s || s.root == t) {
                return false
            }
            if (!n.canReuseView(s)) {
                return false
            }
            o.move(o.createRangeOn(s), r.toViewPosition(wm._createBefore(e)));
            return true
        }

        function qp(t, e, {preflight: n} = {}) {
            if (n) {
                return e.test(t, "insert")
            } else {
                return e.consume(t, "insert")
            }
        }

        function jp(t) {
            const {schema: e, document: n} = t.model;
            for (const i of n.getRootNames()) {
                const o = n.getRoot(i);
                if (o.isEmpty && !e.checkChild(o, "$text")) {
                    if (e.checkChild(o, "paragraph")) {
                        t.insertElement("paragraph", o);
                        return true
                    }
                }
            }
            return false
        }

        function $p(t, e, n) {
            const i = n.createContext(t);
            if (!n.checkChild(i, "paragraph")) {
                return false
            }
            if (!n.checkChild(i.push("paragraph"), e)) {
                return false
            }
            return true
        }

        function Up(t, e) {
            const n = e.createElement("paragraph");
            e.insert(n, t);
            return e.createPositionAt(n, 0)
        }

        class Gp extends Zm {
            elementToElement(t) {
                return this.add(Yp(t))
            }

            elementToAttribute(t) {
                return this.add(Qp(t))
            }

            attributeToAttribute(t) {
                return this.add(Xp(t))
            }

            elementToMarker(t) {
                return this.add(tb(t))
            }

            dataToMarker(t) {
                return this.add(eb(t))
            }
        }

        function Kp() {
            return (t, e, n) => {
                if (!e.modelRange && n.consumable.consume(e.viewItem, {name: true})) {
                    const {modelRange: t, modelCursor: i} = n.convertChildren(e.viewItem, e.modelCursor);
                    e.modelRange = t;
                    e.modelCursor = i
                }
            }
        }

        function Zp() {
            return (t, e, {schema: n, consumable: i, writer: o}) => {
                let r = e.modelCursor;
                if (!i.test(e.viewItem)) {
                    return
                }
                if (!n.checkChild(r, "$text")) {
                    if (!$p(r, "$text", n)) {
                        return
                    }
                    if (e.viewItem.data.trim().length == 0) {
                        return
                    }
                    r = Up(r, o)
                }
                i.consume(e.viewItem);
                const s = o.createText(e.viewItem.data);
                o.insert(s, r);
                e.modelRange = o.createRange(r, r.getShiftedBy(s.offsetSize));
                e.modelCursor = e.modelRange.end
            }
        }

        function Jp(t, e) {
            return (n, i) => {
                const o = i.newSelection;
                const r = [];
                for (const t of o.getRanges()) {
                    r.push(e.toModelRange(t))
                }
                const s = t.createSelection(r, {backward: o.isBackward});
                if (!s.isEqual(t.document.selection)) {
                    t.change((t => {
                        t.setSelection(s)
                    }))
                }
            }
        }

        function Yp(t) {
            t = Xm(t);
            const e = ob(t);
            const n = ib(t.view);
            const i = n ? `element:${n}` : "element";
            return n => {
                n.on(i, e, {priority: t.converterPriority || "normal"})
            }
        }

        function Qp(t) {
            t = Xm(t);
            ab(t);
            const e = lb(t, false);
            const n = ib(t.view);
            const i = n ? `element:${n}` : "element";
            return n => {
                n.on(i, e, {priority: t.converterPriority || "low"})
            }
        }

        function Xp(t) {
            t = Xm(t);
            let e = null;
            if (typeof t.view == "string" || t.view.key) {
                e = sb(t)
            }
            ab(t, e);
            const n = lb(t, true);
            return e => {
                e.on("element", n, {priority: t.converterPriority || "low"})
            }
        }

        function tb(t) {
            const e = ub(t.model);
            return Yp({...t, model: e})
        }

        function eb(t) {
            t = Xm(t);
            if (!t.model) {
                t.model = e => e ? t.view + ":" + e : t.view
            }
            const e = {view: t.view, model: t.model};
            const n = ob(hb(e, "start"));
            const i = ob(hb(e, "end"));
            return o => {
                o.on(`element:${t.view}-start`, n, {priority: t.converterPriority || "normal"});
                o.on(`element:${t.view}-end`, i, {priority: t.converterPriority || "normal"});
                const r = D.get("low");
                const s = D.get("highest");
                const a = D.get(t.converterPriority) / s;
                o.on("element", nb(e), {priority: r + a})
            }
        }

        function nb(t) {
            return (e, n, i) => {
                const o = `data-${t.view}`;
                if (!i.consumable.test(n.viewItem, {attributes: o + "-end-after"}) && !i.consumable.test(n.viewItem, {attributes: o + "-start-after"}) && !i.consumable.test(n.viewItem, {attributes: o + "-end-before"}) && !i.consumable.test(n.viewItem, {attributes: o + "-start-before"})) {
                    return
                }
                if (!n.modelRange) {
                    Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-end-after"})) {
                    r(n.modelRange.end, n.viewItem.getAttribute(o + "-end-after").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-start-after"})) {
                    r(n.modelRange.end, n.viewItem.getAttribute(o + "-start-after").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-end-before"})) {
                    r(n.modelRange.start, n.viewItem.getAttribute(o + "-end-before").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-start-before"})) {
                    r(n.modelRange.start, n.viewItem.getAttribute(o + "-start-before").split(","))
                }

                function r(e, o) {
                    for (const r of o) {
                        const o = t.model(r, i);
                        const s = i.writer.createElement("$marker", {"data-name": o});
                        i.writer.insert(s, e);
                        if (n.modelCursor.isEqual(e)) {
                            n.modelCursor = n.modelCursor.getShiftedBy(1)
                        } else {
                            n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)
                        }
                        n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
                    }
                }
            }
        }

        function ib(t) {
            if (typeof t == "string") {
                return t
            }
            if (typeof t == "object" && typeof t.name == "string") {
                return t.name
            }
            return null
        }

        function ob(t) {
            const e = new Yc(t.view);
            return (n, i, o) => {
                const r = e.match(i.viewItem);
                if (!r) {
                    return
                }
                const s = r.match;
                s.name = true;
                if (!o.consumable.test(i.viewItem, s)) {
                    return
                }
                const a = rb(t.model, i.viewItem, o);
                if (!a) {
                    return
                }
                if (!o.safeInsert(a, i.modelCursor)) {
                    return
                }
                o.consumable.consume(i.viewItem, s);
                o.convertChildren(i.viewItem, a);
                o.updateConversionResult(a, i)
            }
        }

        function rb(t, e, n) {
            if (t instanceof Function) {
                return t(e, n)
            } else {
                return n.writer.createElement(t)
            }
        }

        function sb(t) {
            if (typeof t.view == "string") {
                t.view = {key: t.view}
            }
            const e = t.view.key;
            let n;
            if (e == "class" || e == "style") {
                const i = e == "class" ? "classes" : "styles";
                n = {[i]: t.view.value}
            } else {
                const i = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
                n = {attributes: {[e]: i}}
            }
            if (t.view.name) {
                n.name = t.view.name
            }
            t.view = n;
            return e
        }

        function ab(t, e = null) {
            const n = e === null ? true : t => t.getAttribute(e);
            const i = typeof t.model != "object" ? t.model : t.model.key;
            const o = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value;
            t.model = {key: i, value: o}
        }

        function lb(t, e) {
            const n = new Yc(t.view);
            return (i, o, r) => {
                if (!o.modelRange && e) {
                    return
                }
                const s = n.match(o.viewItem);
                if (!s) {
                    return
                }
                if (cb(t.view, o.viewItem)) {
                    s.match.name = true
                } else {
                    delete s.match.name
                }
                if (!r.consumable.test(o.viewItem, s.match)) {
                    return
                }
                const a = t.model.key;
                const l = typeof t.model.value == "function" ? t.model.value(o.viewItem, r) : t.model.value;
                if (l === null) {
                    return
                }
                if (!o.modelRange) {
                    Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor))
                }
                const c = db(o.modelRange, {key: a, value: l}, e, r);
                if (c) {
                    if (r.consumable.test(o.viewItem, {name: true})) {
                        s.match.name = true
                    }
                    r.consumable.consume(o.viewItem, s.match)
                }
            }
        }

        function cb(t, e) {
            const n = typeof t == "function" ? t(e) : t;
            if (typeof n == "object" && !ib(n)) {
                return false
            }
            return !n.classes && !n.attributes && !n.styles
        }

        function db(t, e, n, i) {
            let o = false;
            for (const r of Array.from(t.getItems({shallow: n}))) {
                if (!i.schema.checkAttribute(r, e.key)) {
                    continue
                }
                o = true;
                if (r.hasAttribute(e.key)) {
                    continue
                }
                i.writer.setAttribute(e.key, e.value, r)
            }
            return o
        }

        function ub(t) {
            return (e, n) => {
                const i = typeof t == "string" ? t : t(e, n);
                return n.writer.createElement("$marker", {"data-name": i})
            }
        }

        function hb(t, e) {
            const n = (e, n) => {
                const i = e.getAttribute("name");
                const o = t.model(i, n);
                return n.writer.createElement("$marker", {"data-name": o})
            };
            return {view: `${t.view}-${e}`, model: n}
        }

        class fb extends (dt()) {
            constructor(t, e) {
                super();
                this.model = t;
                this.view = new cm(e);
                this.mapper = new Sm;
                this.downcastDispatcher = new Bm({mapper: this.mapper, schema: t.schema});
                const n = this.model.document;
                const i = n.selection;
                const o = this.model.markers;
                this.listenTo(this.model, "_beforeChanges", (() => {
                    this.view._disableRendering(true)
                }), {priority: "highest"});
                this.listenTo(this.model, "_afterChanges", (() => {
                    this.view._disableRendering(false)
                }), {priority: "lowest"});
                this.listenTo(n, "change", (() => {
                    this.view.change((t => {
                        this.downcastDispatcher.convertChanges(n.differ, o, t);
                        this.downcastDispatcher.convertSelection(i, o, t)
                    }))
                }), {priority: "low"});
                this.listenTo(this.view.document, "selectionChange", Jp(this.model, this.mapper));
                this.downcastDispatcher.on("insert:$text", ep(), {priority: "lowest"});
                this.downcastDispatcher.on("insert", np(), {priority: "lowest"});
                this.downcastDispatcher.on("remove", ip(), {priority: "low"});
                this.downcastDispatcher.on("selection", ap(), {priority: "high"});
                this.downcastDispatcher.on("selection", rp(), {priority: "low"});
                this.downcastDispatcher.on("selection", sp(), {priority: "low"});
                this.view.document.roots.bindTo(this.model.document.roots).using((t => {
                    if (t.rootName == "$graveyard") {
                        return null
                    }
                    const e = new ih(this.view.document, t.name);
                    e.rootName = t.rootName;
                    this.mapper.bindElements(t, e);
                    return e
                }))
            }

            destroy() {
                this.view.destroy();
                this.stopListening()
            }

            reconvertMarker(t) {
                const e = typeof t == "string" ? t : t.name;
                const n = this.model.markers.get(e);
                if (!n) {
                    throw new P("editingcontroller-reconvertmarker-marker-not-exist", this, {markerName: e})
                }
                this.model.change((() => {
                    this.model.markers._refresh(n)
                }))
            }

            reconvertItem(t) {
                this.model.change((() => {
                    this.model.document.differ._refreshItem(t)
                }))
            }
        }

        class gb {
            constructor() {
                this._consumables = new Map
            }

            add(t, e) {
                let n;
                if (t.is("$text") || t.is("documentFragment")) {
                    this._consumables.set(t, true);
                    return
                }
                if (!this._consumables.has(t)) {
                    n = new pb(t);
                    this._consumables.set(t, n)
                } else {
                    n = this._consumables.get(t)
                }
                n.add(e)
            }

            test(t, e) {
                const n = this._consumables.get(t);
                if (n === undefined) {
                    return null
                }
                if (t.is("$text") || t.is("documentFragment")) {
                    return n
                }
                return n.test(e)
            }

            consume(t, e) {
                if (this.test(t, e)) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, false)
                    } else {
                        this._consumables.get(t).consume(e)
                    }
                    return true
                }
                return false
            }

            revert(t, e) {
                const n = this._consumables.get(t);
                if (n !== undefined) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, true)
                    } else {
                        n.revert(e)
                    }
                }
            }

            static consumablesFromElement(t) {
                const e = {element: t, name: true, attributes: [], classes: [], styles: []};
                const n = t.getAttributeKeys();
                for (const t of n) {
                    if (t == "style" || t == "class") {
                        continue
                    }
                    e.attributes.push(t)
                }
                const i = t.getClassNames();
                for (const t of i) {
                    e.classes.push(t)
                }
                const o = t.getStyleNames();
                for (const t of o) {
                    e.styles.push(t)
                }
                return e
            }

            static createFrom(t, e) {
                if (!e) {
                    e = new gb
                }
                if (t.is("$text")) {
                    e.add(t);
                    return e
                }
                if (t.is("element")) {
                    e.add(t, gb.consumablesFromElement(t))
                }
                if (t.is("documentFragment")) {
                    e.add(t)
                }
                for (const n of t.getChildren()) {
                    e = gb.createFrom(n, e)
                }
                return e
            }
        }

        const mb = ["attributes", "classes", "styles"];

        class pb {
            constructor(t) {
                this.element = t;
                this._canConsumeName = null;
                this._consumables = {attributes: new Map, styles: new Map, classes: new Map}
            }

            add(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e of mb) {
                    if (e in t) {
                        this._add(e, t[e])
                    }
                }
            }

            test(t) {
                if (t.name && !this._canConsumeName) {
                    return this._canConsumeName
                }
                for (const e of mb) {
                    if (e in t) {
                        const n = this._test(e, t[e]);
                        if (n !== true) {
                            return n
                        }
                    }
                }
                return true
            }

            consume(t) {
                if (t.name) {
                    this._canConsumeName = false
                }
                for (const e of mb) {
                    if (e in t) {
                        this._consume(e, t[e])
                    }
                }
            }

            revert(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e of mb) {
                    if (e in t) {
                        this._revert(e, t[e])
                    }
                }
            }

            _add(t, e) {
                const n = Kt(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        throw new P("viewconsumable-invalid-attribute", this)
                    }
                    i.set(e, true);
                    if (t === "styles") {
                        for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                            i.set(t, true)
                        }
                    }
                }
            }

            _test(t, e) {
                const n = Kt(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        const n = this._test(t, [...this._consumables[t].keys()]);
                        if (n !== true) {
                            return n
                        }
                    } else {
                        const t = i.get(e);
                        if (t === undefined) {
                            return null
                        }
                        if (!t) {
                            return false
                        }
                    }
                }
                return true
            }

            _consume(t, e) {
                const n = Kt(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._consume(t, [...this._consumables[t].keys()])
                    } else {
                        i.set(e, false);
                        if (t == "styles") {
                            for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                                i.set(t, false)
                            }
                        }
                    }
                }
            }

            _revert(t, e) {
                const n = Kt(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._revert(t, [...this._consumables[t].keys()])
                    } else {
                        const t = i.get(e);
                        if (t === false) {
                            i.set(e, true)
                        }
                    }
                }
            }
        }

        class bb extends (dt()) {
            constructor() {
                super();
                this._sourceDefinitions = {};
                this._attributeProperties = {};
                this.decorate("checkChild");
                this.decorate("checkAttribute");
                this.on("checkAttribute", ((t, e) => {
                    e[0] = new kb(e[0])
                }), {priority: "highest"});
                this.on("checkChild", ((t, e) => {
                    e[0] = new kb(e[0]);
                    e[1] = this.getDefinition(e[1])
                }), {priority: "highest"})
            }

            register(t, e) {
                if (this._sourceDefinitions[t]) {
                    throw new P("schema-cannot-register-item-twice", this, {itemName: t})
                }
                this._sourceDefinitions[t] = [Object.assign({}, e)];
                this._clearCache()
            }

            extend(t, e) {
                if (!this._sourceDefinitions[t]) {
                    throw new P("schema-cannot-extend-missing-item", this, {itemName: t})
                }
                this._sourceDefinitions[t].push(Object.assign({}, e));
                this._clearCache()
            }

            getDefinitions() {
                if (!this._compiledDefinitions) {
                    this._compile()
                }
                return this._compiledDefinitions
            }

            getDefinition(t) {
                let e;
                if (typeof t == "string") {
                    e = t
                } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) {
                    e = "$text"
                } else {
                    e = t.name
                }
                return this.getDefinitions()[e]
            }

            isRegistered(t) {
                return !!this.getDefinition(t)
            }

            isBlock(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isBlock)
            }

            isLimit(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isLimit || e.isObject)
            }

            isObject(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isObject || e.isLimit && e.isSelectable && e.isContent)
            }

            isInline(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isInline)
            }

            isSelectable(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isSelectable || e.isObject)
            }

            isContent(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isContent || e.isObject)
            }

            checkChild(t, e) {
                if (!e) {
                    return false
                }
                return this._checkContextMatch(e, t)
            }

            checkAttribute(t, e) {
                const n = this.getDefinition(t.last);
                if (!n) {
                    return false
                }
                return n.allowAttributes.includes(e)
            }

            checkMerge(t, e) {
                if (t instanceof wm) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    if (!(e instanceof mm)) {
                        throw new P("schema-check-merge-no-element-before", this)
                    }
                    if (!(n instanceof mm)) {
                        throw new P("schema-check-merge-no-element-after", this)
                    }
                    return this.checkMerge(e, n)
                }
                for (const n of e.getChildren()) {
                    if (!this.checkChild(t, n)) {
                        return false
                    }
                }
                return true
            }

            addChildCheck(t) {
                this.on("checkChild", ((e, [n, i]) => {
                    if (!i) {
                        return
                    }
                    const o = t(n, i);
                    if (typeof o == "boolean") {
                        e.stop();
                        e.return = o
                    }
                }), {priority: "high"})
            }

            addAttributeCheck(t) {
                this.on("checkAttribute", ((e, [n, i]) => {
                    const o = t(n, i);
                    if (typeof o == "boolean") {
                        e.stop();
                        e.return = o
                    }
                }), {priority: "high"})
            }

            setAttributeProperties(t, e) {
                this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
            }

            getAttributeProperties(t) {
                return this._attributeProperties[t] || {}
            }

            getLimitElement(t) {
                let e;
                if (t instanceof wm) {
                    e = t.parent
                } else {
                    const n = t instanceof Em ? [t] : Array.from(t.getRanges());
                    e = n.reduce(((t, e) => {
                        const n = e.getCommonAncestor();
                        if (!t) {
                            return n
                        }
                        return t.getCommonAncestor(n, {includeSelf: true})
                    }), null)
                }
                while (!this.isLimit(e)) {
                    if (e.parent) {
                        e = e.parent
                    } else {
                        break
                    }
                }
                return e
            }

            checkAttributeInSelection(t, e) {
                if (t.isCollapsed) {
                    const n = t.getFirstPosition();
                    const i = [...n.getAncestors(), new fm("", t.getAttributes())];
                    return this.checkAttribute(i, e)
                } else {
                    const n = t.getRanges();
                    for (const t of n) {
                        for (const n of t) {
                            if (this.checkAttribute(n.item, e)) {
                                return true
                            }
                        }
                    }
                }
                return false
            }

            * getValidRanges(t, e) {
                t = Vb(t);
                for (const n of t) {
                    yield* this._getValidRangesForRange(n, e)
                }
            }

            getNearestSelectionRange(t, e = "both") {
                if (this.checkChild(t, "$text")) {
                    return new Em(t)
                }
                let n, i;
                const o = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root;
                if (e == "both" || e == "backward") {
                    n = new bm({boundaries: Em._createIn(o), startPosition: t, direction: "backward"})
                }
                if (e == "both" || e == "forward") {
                    i = new bm({boundaries: Em._createIn(o), startPosition: t})
                }
                for (const t of zb(n, i)) {
                    const e = t.walker == n ? "elementEnd" : "elementStart";
                    const i = t.value;
                    if (i.type == e && this.isObject(i.item)) {
                        return Em._createOn(i.item)
                    }
                    if (this.checkChild(i.nextPosition, "$text")) {
                        return new Em(i.nextPosition)
                    }
                }
                return null
            }

            findAllowedParent(t, e) {
                let n = t.parent;
                while (n) {
                    if (this.checkChild(n, e)) {
                        return n
                    }
                    if (this.isLimit(n)) {
                        return null
                    }
                    n = n.parent
                }
                return null
            }

            setAllowedAttributes(t, e, n) {
                const i = n.model;
                for (const [o, r] of Object.entries(e)) {
                    if (i.schema.checkAttribute(t, o)) {
                        n.setAttribute(o, r, t)
                    }
                }
            }

            removeDisallowedAttributes(t, e) {
                for (const n of t) {
                    if (n.is("$text")) {
                        Fb(this, n, e)
                    } else {
                        const t = Em._createIn(n);
                        const i = t.getPositions();
                        for (const t of i) {
                            const n = t.nodeBefore || t.parent;
                            Fb(this, n, e)
                        }
                    }
                }
            }

            getAttributesWithProperty(t, e, n) {
                const i = {};
                for (const [o, r] of t.getAttributes()) {
                    const t = this.getAttributeProperties(o);
                    if (t[e] === undefined) {
                        continue
                    }
                    if (n === undefined || n === t[e]) {
                        i[o] = r
                    }
                }
                return i
            }

            createContext(t) {
                return new kb(t)
            }

            _clearCache() {
                this._compiledDefinitions = null
            }

            _compile() {
                const t = {};
                const e = this._sourceDefinitions;
                const n = Object.keys(e);
                for (const i of n) {
                    t[i] = wb(e[i], i)
                }
                for (const e of n) {
                    _b(t, e)
                }
                for (const e of n) {
                    Ab(t, e)
                }
                for (const e of n) {
                    Cb(t, e)
                }
                for (const e of n) {
                    vb(t, e);
                    yb(t, e)
                }
                for (const e of n) {
                    xb(t, e);
                    Eb(t, e);
                    Sb(t, e)
                }
                this._compiledDefinitions = t
            }

            _checkContextMatch(t, e, n = e.length - 1) {
                const i = e.getItem(n);
                if (t.allowIn.includes(i.name)) {
                    if (n == 0) {
                        return true
                    } else {
                        const t = this.getDefinition(i);
                        return this._checkContextMatch(t, e, n - 1)
                    }
                } else {
                    return false
                }
            }

            * _getValidRangesForRange(t, e) {
                let n = t.start;
                let i = t.start;
                for (const o of t.getItems({shallow: true})) {
                    if (o.is("element")) {
                        yield* this._getValidRangesForRange(Em._createIn(o), e)
                    }
                    if (!this.checkAttribute(o, e)) {
                        if (!n.isEqual(i)) {
                            yield new Em(n, i)
                        }
                        n = wm._createAfter(o)
                    }
                    i = wm._createAfter(o)
                }
                if (!n.isEqual(i)) {
                    yield new Em(n, i)
                }
            }
        }

        class kb {
            constructor(t) {
                if (t instanceof kb) {
                    return t
                }
                let e;
                if (typeof t == "string") {
                    e = [t]
                } else if (!Array.isArray(t)) {
                    e = t.getAncestors({includeSelf: true})
                } else {
                    e = t
                }
                this._items = e.map(Rb)
            }

            get length() {
                return this._items.length
            }

            get last() {
                return this._items[this._items.length - 1]
            }

            [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }

            push(t) {
                const e = new kb([t]);
                e._items = [...this._items, ...e._items];
                return e
            }

            getItem(t) {
                return this._items[t]
            }

            * getNames() {
                yield* this._items.map((t => t.name))
            }

            endsWith(t) {
                return Array.from(this.getNames()).join(" ").endsWith(t)
            }

            startsWith(t) {
                return Array.from(this.getNames()).join(" ").startsWith(t)
            }
        }

        function wb(t, e) {
            const n = {
                name: e,
                allowIn: [],
                allowContentOf: [],
                allowWhere: [],
                allowAttributes: [],
                allowAttributesOf: [],
                allowChildren: [],
                inheritTypesFrom: []
            };
            Db(t, n);
            Tb(t, n, "allowIn");
            Tb(t, n, "allowContentOf");
            Tb(t, n, "allowWhere");
            Tb(t, n, "allowAttributes");
            Tb(t, n, "allowAttributesOf");
            Tb(t, n, "allowChildren");
            Tb(t, n, "inheritTypesFrom");
            Bb(t, n);
            return n
        }

        function _b(t, e) {
            const n = t[e];
            for (const i of n.allowChildren) {
                const n = t[i];
                if (!n) {
                    continue
                }
                n.allowIn.push(e)
            }
            n.allowChildren.length = 0
        }

        function Ab(t, e) {
            for (const n of t[e].allowContentOf) {
                if (t[n]) {
                    const i = Pb(t, n);
                    i.forEach((t => {
                        t.allowIn.push(e)
                    }))
                }
            }
            delete t[e].allowContentOf
        }

        function Cb(t, e) {
            for (const n of t[e].allowWhere) {
                const i = t[n];
                if (i) {
                    const n = i.allowIn;
                    t[e].allowIn.push(...n)
                }
            }
            delete t[e].allowWhere
        }

        function vb(t, e) {
            for (const n of t[e].allowAttributesOf) {
                const i = t[n];
                if (i) {
                    const n = i.allowAttributes;
                    t[e].allowAttributes.push(...n)
                }
            }
            delete t[e].allowAttributesOf
        }

        function yb(t, e) {
            const n = t[e];
            for (const e of n.inheritTypesFrom) {
                const i = t[e];
                if (i) {
                    const t = Object.keys(i).filter((t => t.startsWith("is")));
                    for (const e of t) {
                        if (!(e in n)) {
                            n[e] = i[e]
                        }
                    }
                }
            }
            delete n.inheritTypesFrom
        }

        function xb(t, e) {
            const n = t[e];
            const i = n.allowIn.filter((e => t[e]));
            n.allowIn = Array.from(new Set(i))
        }

        function Eb(t, e) {
            const n = t[e];
            for (const i of n.allowIn) {
                const n = t[i];
                n.allowChildren.push(e)
            }
        }

        function Sb(t, e) {
            const n = t[e];
            n.allowAttributes = Array.from(new Set(n.allowAttributes))
        }

        function Db(t, e) {
            for (const n of t) {
                const t = Object.keys(n).filter((t => t.startsWith("is")));
                for (const i of t) {
                    e[i] = !!n[i]
                }
            }
        }

        function Tb(t, e, n) {
            for (const i of t) {
                const t = i[n];
                if (typeof t == "string") {
                    e[n].push(t)
                } else if (Array.isArray(t)) {
                    e[n].push(...t)
                }
            }
        }

        function Bb(t, e) {
            for (const n of t) {
                const t = n.inheritAllFrom;
                if (t) {
                    e.allowContentOf.push(t);
                    e.allowWhere.push(t);
                    e.allowAttributesOf.push(t);
                    e.inheritTypesFrom.push(t)
                }
            }
        }

        function Pb(t, e) {
            const n = t[e];
            return Ib(t).filter((t => t.allowIn.includes(n.name)))
        }

        function Ib(t) {
            return Object.keys(t).map((e => t[e]))
        }

        function Rb(t) {
            if (typeof t == "string" || t.is("documentFragment")) {
                return {
                    name: typeof t == "string" ? t : "$documentFragment", * getAttributeKeys() {
                    }, getAttribute() {
                    }
                }
            } else {
                return {
                    name: t.is("element") ? t.name : "$text", * getAttributeKeys() {
                        yield* t.getAttributeKeys()
                    }, getAttribute(e) {
                        return t.getAttribute(e)
                    }
                }
            }
        }

        function* zb(t, e) {
            let n = false;
            while (!n) {
                n = true;
                if (t) {
                    const e = t.next();
                    if (!e.done) {
                        n = false;
                        yield{walker: t, value: e.value}
                    }
                }
                if (e) {
                    const t = e.next();
                    if (!t.done) {
                        n = false;
                        yield{walker: e, value: t.value}
                    }
                }
            }
        }

        function* Vb(t) {
            for (const e of t) {
                yield* e.getMinimalFlatRanges()
            }
        }

        function Fb(t, e, n) {
            for (const i of e.getAttributeKeys()) {
                if (!t.checkAttribute(e, i)) {
                    n.removeAttribute(i, e)
                }
            }
        }

        class Lb extends (j()) {
            constructor(t) {
                super();
                this._splitParts = new Map;
                this._cursorParents = new Map;
                this._modelCursor = null;
                this._emptyElementsToKeep = new Set;
                this.conversionApi = {
                    ...t,
                    consumable: null,
                    writer: null,
                    store: null,
                    convertItem: (t, e) => this._convertItem(t, e),
                    convertChildren: (t, e) => this._convertChildren(t, e),
                    safeInsert: (t, e) => this._safeInsert(t, e),
                    updateConversionResult: (t, e) => this._updateConversionResult(t, e),
                    splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
                    getSplitParts: t => this._getSplitParts(t),
                    keepEmptyElement: t => this._keepEmptyElement(t)
                }
            }

            convert(t, e, n = ["$root"]) {
                this.fire("viewCleanup", t);
                this._modelCursor = Nb(n, e);
                this.conversionApi.writer = e;
                this.conversionApi.consumable = gb.createFrom(t);
                this.conversionApi.store = {};
                const {modelRange: i} = this._convertItem(t, this._modelCursor);
                const o = e.createDocumentFragment();
                if (i) {
                    this._removeEmptyElements();
                    for (const t of Array.from(this._modelCursor.parent.getChildren())) {
                        e.append(t, o)
                    }
                    o.markers = Ob(o, e)
                }
                this._modelCursor = null;
                this._splitParts.clear();
                this._cursorParents.clear();
                this._emptyElementsToKeep.clear();
                this.conversionApi.writer = null;
                this.conversionApi.store = null;
                return o
            }

            _convertItem(t, e) {
                const n = {viewItem: t, modelCursor: e, modelRange: null};
                if (t.is("element")) {
                    this.fire(`element:${t.name}`, n, this.conversionApi)
                } else if (t.is("$text")) {
                    this.fire("text", n, this.conversionApi)
                } else {
                    this.fire("documentFragment", n, this.conversionApi)
                }
                if (n.modelRange && !(n.modelRange instanceof Em)) {
                    throw new P("view-conversion-dispatcher-incorrect-result", this)
                }
                return {modelRange: n.modelRange, modelCursor: n.modelCursor}
            }

            _convertChildren(t, e) {
                let n = e.is("position") ? e : wm._createAt(e, 0);
                const i = new Em(n);
                for (const e of Array.from(t.getChildren())) {
                    const t = this._convertItem(e, n);
                    if (t.modelRange instanceof Em) {
                        i.end = t.modelRange.end;
                        n = t.modelCursor
                    }
                }
                return {modelRange: i, modelCursor: n}
            }

            _safeInsert(t, e) {
                const n = this._splitToAllowedParent(t, e);
                if (!n) {
                    return false
                }
                this.conversionApi.writer.insert(t, n.position);
                return true
            }

            _updateConversionResult(t, e) {
                const n = this._getSplitParts(t);
                const i = this.conversionApi.writer;
                if (!e.modelRange) {
                    e.modelRange = i.createRange(i.createPositionBefore(t), i.createPositionAfter(n[n.length - 1]))
                }
                const o = this._cursorParents.get(t);
                if (o) {
                    e.modelCursor = i.createPositionAt(o, 0)
                } else {
                    e.modelCursor = e.modelRange.end
                }
            }

            _splitToAllowedParent(t, e) {
                const {schema: n, writer: i} = this.conversionApi;
                let o = n.findAllowedParent(e, t);
                if (o) {
                    if (o === e.parent) {
                        return {position: e}
                    }
                    if (this._modelCursor.parent.getAncestors().includes(o)) {
                        o = null
                    }
                }
                if (!o) {
                    if (!$p(e, t, n)) {
                        return null
                    }
                    return {position: Up(e, i)}
                }
                const r = this.conversionApi.writer.split(e, o);
                const s = [];
                for (const t of r.range.getWalker()) {
                    if (t.type == "elementEnd") {
                        s.push(t.item)
                    } else {
                        const e = s.pop();
                        const n = t.item;
                        this._registerSplitPair(e, n)
                    }
                }
                const a = r.range.end.parent;
                this._cursorParents.set(t, a);
                return {position: r.position, cursorParent: a}
            }

            _registerSplitPair(t, e) {
                if (!this._splitParts.has(t)) {
                    this._splitParts.set(t, [t])
                }
                const n = this._splitParts.get(t);
                this._splitParts.set(e, n);
                n.push(e)
            }

            _getSplitParts(t) {
                let e;
                if (!this._splitParts.has(t)) {
                    e = [t]
                } else {
                    e = this._splitParts.get(t)
                }
                return e
            }

            _keepEmptyElement(t) {
                this._emptyElementsToKeep.add(t)
            }

            _removeEmptyElements() {
                let t = false;
                for (const e of this._splitParts.keys()) {
                    if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
                        this.conversionApi.writer.remove(e);
                        this._splitParts.delete(e);
                        t = true
                    }
                }
                if (t) {
                    this._removeEmptyElements()
                }
            }
        }

        function Ob(t, e) {
            const n = new Set;
            const i = new Map;
            const o = Em._createIn(t).getItems();
            for (const t of o) {
                if (t.is("element", "$marker")) {
                    n.add(t)
                }
            }
            for (const t of n) {
                const n = t.getAttribute("data-name");
                const o = e.createPositionBefore(t);
                if (!i.has(n)) {
                    i.set(n, new Em(o.clone()))
                } else {
                    i.get(n).end = o.clone()
                }
                e.remove(t)
            }
            return i
        }

        function Nb(t, e) {
            let n;
            for (const i of new kb(t)) {
                const t = {};
                for (const e of i.getAttributeKeys()) {
                    t[e] = i.getAttribute(e)
                }
                const o = e.createElement(i.name, t);
                if (n) {
                    e.insert(o, n)
                }
                n = wm._createAt(o, 0)
            }
            return n
        }

        class Mb {
            getHtml(t) {
                const e = document.implementation.createHTMLDocument("");
                const n = e.createElement("div");
                n.appendChild(t);
                return n.innerHTML
            }
        }

        class Hb {
            constructor(t) {
                this.skipComments = true;
                this.domParser = new DOMParser;
                this.domConverter = new Af(t, {renderingMode: "data"});
                this.htmlWriter = new Mb
            }

            toData(t) {
                const e = this.domConverter.viewToDom(t);
                return this.htmlWriter.getHtml(e)
            }

            toView(t) {
                const e = this._toDom(t);
                return this.domConverter.domToView(e, {skipComments: this.skipComments})
            }

            registerRawContentMatcher(t) {
                this.domConverter.registerRawContentMatcher(t)
            }

            useFillerType(t) {
                this.domConverter.blockFillerMode = t == "marked" ? "markedNbsp" : "nbsp"
            }

            _toDom(t) {
                if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
                    t = `<body>${t}</body>`
                }
                const e = this.domParser.parseFromString(t, "text/html");
                const n = e.createDocumentFragment();
                const i = e.body.childNodes;
                while (i.length > 0) {
                    n.appendChild(i[0])
                }
                return n
            }
        }

        class Wb extends (j()) {
            constructor(t, e) {
                super();
                this.model = t;
                this.mapper = new Sm;
                this.downcastDispatcher = new Bm({mapper: this.mapper, schema: t.schema});
                this.downcastDispatcher.on("insert:$text", ep(), {priority: "lowest"});
                this.downcastDispatcher.on("insert", np(), {priority: "lowest"});
                this.upcastDispatcher = new Lb({schema: t.schema});
                this.viewDocument = new kh(e);
                this.stylesProcessor = e;
                this.htmlProcessor = new Hb(this.viewDocument);
                this.processor = this.htmlProcessor;
                this._viewWriter = new Rh(this.viewDocument);
                this.upcastDispatcher.on("text", Zp(), {priority: "lowest"});
                this.upcastDispatcher.on("element", Kp(), {priority: "lowest"});
                this.upcastDispatcher.on("documentFragment", Kp(), {priority: "lowest"});
                dt().prototype.decorate.call(this, "init");
                dt().prototype.decorate.call(this, "set");
                dt().prototype.decorate.call(this, "get");
                this.on("init", (() => {
                    this.fire("ready")
                }), {priority: "lowest"});
                this.on("ready", (() => {
                    this.model.enqueueChange({isUndoable: false}, jp)
                }), {priority: "lowest"})
            }

            get(t = {}) {
                const {rootName: e = "main", trim: n = "empty"} = t;
                if (!this._checkIfRootsExists([e])) {
                    throw new P("datacontroller-get-non-existent-root", this)
                }
                const i = this.model.document.getRoot(e);
                if (n === "empty" && !this.model.hasContent(i, {ignoreWhitespaces: true})) {
                    return ""
                }
                return this.stringify(i, t)
            }

            stringify(t, e = {}) {
                const n = this.toView(t, e);
                return this.processor.toData(n)
            }

            toView(t, e = {}) {
                const n = this.viewDocument;
                const i = this._viewWriter;
                this.mapper.clearBindings();
                const o = Em._createIn(t);
                const r = new Ph(n);
                this.mapper.bindElements(t, r);
                const s = t.is("documentFragment") ? t.markers : qb(t);
                this.downcastDispatcher.convert(o, s, i, e);
                return r
            }

            init(t) {
                if (this.model.document.version) {
                    throw new P("datacontroller-init-document-not-empty", this)
                }
                let e = {};
                if (typeof t === "string") {
                    e.main = t
                } else {
                    e = t
                }
                if (!this._checkIfRootsExists(Object.keys(e))) {
                    throw new P("datacontroller-init-non-existent-root", this)
                }
                this.model.enqueueChange({isUndoable: false}, (t => {
                    for (const n of Object.keys(e)) {
                        const i = this.model.document.getRoot(n);
                        t.insert(this.parse(e[n], i), i, 0)
                    }
                }));
                return Promise.resolve()
            }

            set(t, e = {}) {
                let n = {};
                if (typeof t === "string") {
                    n.main = t
                } else {
                    n = t
                }
                if (!this._checkIfRootsExists(Object.keys(n))) {
                    throw new P("datacontroller-set-non-existent-root", this)
                }
                this.model.enqueueChange(e.batchType || {}, (t => {
                    t.setSelection(null);
                    t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                    for (const e of Object.keys(n)) {
                        const i = this.model.document.getRoot(e);
                        t.remove(t.createRangeIn(i));
                        t.insert(this.parse(n[e], i), i, 0)
                    }
                }))
            }

            parse(t, e = "$root") {
                const n = this.processor.toView(t);
                return this.toModel(n, e)
            }

            toModel(t, e = "$root") {
                return this.model.change((n => this.upcastDispatcher.convert(t, n, e)))
            }

            addStyleProcessorRules(t) {
                t(this.stylesProcessor)
            }

            registerRawContentMatcher(t) {
                if (this.processor && this.processor !== this.htmlProcessor) {
                    this.processor.registerRawContentMatcher(t)
                }
                this.htmlProcessor.registerRawContentMatcher(t)
            }

            destroy() {
                this.stopListening()
            }

            _checkIfRootsExists(t) {
                for (const e of t) {
                    if (!this.model.document.getRootNames().includes(e)) {
                        return false
                    }
                }
                return true
            }
        }

        function qb(t) {
            const e = [];
            const n = t.root.document;
            if (!n) {
                return new Map
            }
            const i = Em._createIn(t);
            for (const t of n.model.markers) {
                const n = t.getRange();
                const o = n.isCollapsed;
                const r = n.start.isEqual(i.start) || n.end.isEqual(i.end);
                if (o && r) {
                    e.push([t.name, n])
                } else {
                    const o = i.getIntersection(n);
                    if (o) {
                        e.push([t.name, o])
                    }
                }
            }
            e.sort((([t, e], [n, i]) => {
                if (e.end.compareWith(i.start) !== "after") {
                    return 1
                } else if (e.start.compareWith(i.end) !== "before") {
                    return -1
                } else {
                    switch (e.start.compareWith(i.start)) {
                        case"before":
                            return 1;
                        case"after":
                            return -1;
                        default:
                            switch (e.end.compareWith(i.end)) {
                                case"before":
                                    return 1;
                                case"after":
                                    return -1;
                                default:
                                    return n.localeCompare(t)
                            }
                    }
                }
            }));
            return new Map(e)
        }

        class jb {
            constructor(t, e) {
                this._helpers = new Map;
                this._downcast = Zl(t);
                this._createConversionHelpers({name: "downcast", dispatchers: this._downcast, isDowncast: true});
                this._upcast = Zl(e);
                this._createConversionHelpers({name: "upcast", dispatchers: this._upcast, isDowncast: false})
            }

            addAlias(t, e) {
                const n = this._downcast.includes(e);
                const i = this._upcast.includes(e);
                if (!i && !n) {
                    throw new P("conversion-add-alias-dispatcher-not-registered", this)
                }
                this._createConversionHelpers({name: t, dispatchers: [e], isDowncast: n})
            }

            for(t) {
                if (!this._helpers.has(t)) {
                    throw new P("conversion-for-unknown-group", this)
                }
                return this._helpers.get(t)
            }

            elementToElement(t) {
                this.for("downcast").elementToElement(t);
                for (const {model: e, view: n} of $b(t)) {
                    this.for("upcast").elementToElement({model: e, view: n, converterPriority: t.converterPriority})
                }
            }

            attributeToElement(t) {
                this.for("downcast").attributeToElement(t);
                for (const {model: e, view: n} of $b(t)) {
                    this.for("upcast").elementToAttribute({view: n, model: e, converterPriority: t.converterPriority})
                }
            }

            attributeToAttribute(t) {
                this.for("downcast").attributeToAttribute(t);
                for (const {model: e, view: n} of $b(t)) {
                    this.for("upcast").attributeToAttribute({view: n, model: e})
                }
            }

            _createConversionHelpers({name: t, dispatchers: e, isDowncast: n}) {
                if (this._helpers.has(t)) {
                    throw new P("conversion-group-exists", this)
                }
                const i = n ? new tp(e) : new Gp(e);
                this._helpers.set(t, i)
            }
        }

        function* $b(t) {
            if (t.model.values) {
                for (const e of t.model.values) {
                    const n = {key: t.model.key, value: e};
                    const i = t.view[e];
                    const o = t.upcastAlso ? t.upcastAlso[e] : undefined;
                    yield* Ub(n, i, o)
                }
            } else {
                yield* Ub(t.model, t.view, t.upcastAlso)
            }
        }

        function* Ub(t, e, n) {
            yield{model: t, view: e};
            if (n) {
                for (const e of Zl(n)) {
                    yield{model: t, view: e}
                }
            }
        }

        class Gb {
            constructor(t) {
                this.baseVersion = t;
                this.isDocumentOperation = this.baseVersion !== null;
                this.batch = null
            }

            _validate() {
            }

            toJSON() {
                const t = Object.assign({}, this);
                t.__className = this.constructor.className;
                delete t.batch;
                delete t.isDocumentOperation;
                return t
            }

            static get className() {
                return "Operation"
            }

            static fromJSON(t, e) {
                return new this(t.baseVersion)
            }
        }

        function Kb(t, e) {
            const n = Qb(e);
            const i = n.reduce(((t, e) => t + e.offsetSize), 0);
            const o = t.parent;
            tk(t);
            const r = t.index;
            o._insertChild(r, n);
            Xb(o, r + n.length);
            Xb(o, r);
            return new Em(t, t.getShiftedBy(i))
        }

        function Zb(t) {
            if (!t.isFlat) {
                throw new P("operation-utils-remove-range-not-flat", this)
            }
            const e = t.start.parent;
            tk(t.start);
            tk(t.end);
            const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
            Xb(e, t.start.index);
            return n
        }

        function Jb(t, e) {
            if (!t.isFlat) {
                throw new P("operation-utils-move-range-not-flat", this)
            }
            const n = Zb(t);
            e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
            return Kb(e, n)
        }

        function Yb(t, e, n) {
            tk(t.start);
            tk(t.end);
            for (const i of t.getItems({shallow: true})) {
                const t = i.is("$textProxy") ? i.textNode : i;
                if (n !== null) {
                    t._setAttribute(e, n)
                } else {
                    t._removeAttribute(e)
                }
                Xb(t.parent, t.index)
            }
            Xb(t.end.parent, t.end.index)
        }

        function Qb(t) {
            const e = [];

            function n(t) {
                if (typeof t == "string") {
                    e.push(new fm(t))
                } else if (t instanceof gm) {
                    e.push(new fm(t.data, t.getAttributes()))
                } else if (t instanceof um) {
                    e.push(t)
                } else if (yt(t)) {
                    for (const e of t) {
                        n(e)
                    }
                }
            }

            n(t);
            for (let t = 1; t < e.length; t++) {
                const n = e[t];
                const i = e[t - 1];
                if (n instanceof fm && i instanceof fm && ek(n, i)) {
                    e.splice(t - 1, 2, new fm(i.data + n.data, i.getAttributes()));
                    t--
                }
            }
            return e
        }

        function Xb(t, e) {
            const n = t.getChild(e - 1);
            const i = t.getChild(e);
            if (n && i && n.is("$text") && i.is("$text") && ek(n, i)) {
                const o = new fm(n.data + i.data, n.getAttributes());
                t._removeChildren(e - 1, 2);
                t._insertChild(e - 1, o)
            }
        }

        function tk(t) {
            const e = t.textNode;
            const n = t.parent;
            if (e) {
                const i = t.offset - e.startOffset;
                const o = e.index;
                n._removeChildren(o, 1);
                const r = new fm(e.data.substr(0, i), e.getAttributes());
                const s = new fm(e.data.substr(i), e.getAttributes());
                n._insertChild(o, [r, s])
            }
        }

        function ek(t, e) {
            const n = t.getAttributes();
            const i = e.getAttributes();
            for (const t of n) {
                if (t[1] !== e.getAttribute(t[0])) {
                    return false
                }
                i.next()
            }
            return i.next().done
        }

        class nk extends Gb {
            constructor(t, e, n, i) {
                super(i);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toNext";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNone"
            }

            get type() {
                if (this.targetPosition.root.rootName == "$graveyard") {
                    return "remove"
                } else if (this.sourcePosition.root.rootName == "$graveyard") {
                    return "reinsert"
                }
                return "move"
            }

            clone() {
                return new nk(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
            }

            getMovedRangeStart() {
                return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
            }

            getReversed() {
                const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                return new nk(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
            }

            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                const n = this.sourcePosition.offset;
                const i = this.targetPosition.offset;
                if (n + this.howMany > t.maxOffset) {
                    throw new P("move-operation-nodes-do-not-exist", this)
                } else if (t === e && n < i && i < n + this.howMany) {
                    throw new P("move-operation-range-into-itself", this)
                } else if (this.sourcePosition.root == this.targetPosition.root) {
                    if (vt(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                        const t = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) {
                            throw new P("move-operation-node-into-itself", this)
                        }
                    }
                }
            }

            _execute() {
                Jb(Em._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                t.targetPosition = this.targetPosition.toJSON();
                return t
            }

            static get className() {
                return "MoveOperation"
            }

            static fromJSON(t, e) {
                const n = wm.fromJSON(t.sourcePosition, e);
                const i = wm.fromJSON(t.targetPosition, e);
                return new this(n, t.howMany, i, t.baseVersion)
            }
        }

        class ik extends Gb {
            constructor(t, e, n) {
                super(n);
                this.position = t.clone();
                this.position.stickiness = "toNone";
                this.nodes = new hm(Qb(e));
                this.shouldReceiveAttributes = false
            }

            get type() {
                return "insert"
            }

            get howMany() {
                return this.nodes.maxOffset
            }

            clone() {
                const t = new hm([...this.nodes].map((t => t._clone(true))));
                const e = new ik(this.position, t, this.baseVersion);
                e.shouldReceiveAttributes = this.shouldReceiveAttributes;
                return e
            }

            getReversed() {
                const t = this.position.root.document.graveyard;
                const e = new wm(t, [0]);
                return new nk(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
            }

            _validate() {
                const t = this.position.parent;
                if (!t || t.maxOffset < this.position.offset) {
                    throw new P("insert-operation-position-invalid", this)
                }
            }

            _execute() {
                const t = this.nodes;
                this.nodes = new hm([...t].map((t => t._clone(true))));
                Kb(this.position, t)
            }

            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                t.nodes = this.nodes.toJSON();
                return t
            }

            static get className() {
                return "InsertOperation"
            }

            static fromJSON(t, e) {
                const n = [];
                for (const e of t.nodes) {
                    if (e.name) {
                        n.push(mm.fromJSON(e))
                    } else {
                        n.push(fm.fromJSON(e))
                    }
                }
                const i = new ik(wm.fromJSON(t.position, e), n, t.baseVersion);
                i.shouldReceiveAttributes = t.shouldReceiveAttributes;
                return i
            }
        }

        class ok extends Gb {
            constructor(t, e, n, i, o, r) {
                super(r);
                this.name = t;
                this.oldRange = e ? e.clone() : null;
                this.newRange = n ? n.clone() : null;
                this.affectsData = o;
                this._markers = i
            }

            get type() {
                return "marker"
            }

            clone() {
                return new ok(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
            }

            getReversed() {
                return new ok(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
            }

            _execute() {
                if (this.newRange) {
                    this._markers._set(this.name, this.newRange, true, this.affectsData)
                } else {
                    this._markers._remove(this.name)
                }
            }

            toJSON() {
                const t = super.toJSON();
                if (this.oldRange) {
                    t.oldRange = this.oldRange.toJSON()
                }
                if (this.newRange) {
                    t.newRange = this.newRange.toJSON()
                }
                delete t._markers;
                return t
            }

            static get className() {
                return "MarkerOperation"
            }

            static fromJSON(t, e) {
                return new ok(t.name, t.oldRange ? Em.fromJSON(t.oldRange, e) : null, t.newRange ? Em.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
            }
        }

        function rk(t, e) {
            return Jg(t, e)
        }

        const sk = rk;

        class ak extends Gb {
            constructor(t, e, n, i, o) {
                super(o);
                this.range = t.clone();
                this.key = e;
                this.oldValue = n === undefined ? null : n;
                this.newValue = i === undefined ? null : i
            }

            get type() {
                if (this.oldValue === null) {
                    return "addAttribute"
                } else if (this.newValue === null) {
                    return "removeAttribute"
                } else {
                    return "changeAttribute"
                }
            }

            clone() {
                return new ak(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
            }

            getReversed() {
                return new ak(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }

            toJSON() {
                const t = super.toJSON();
                t.range = this.range.toJSON();
                return t
            }

            _validate() {
                if (!this.range.isFlat) {
                    throw new P("attribute-operation-range-not-flat", this)
                }
                for (const t of this.range.getItems({shallow: true})) {
                    if (this.oldValue !== null && !sk(t.getAttribute(this.key), this.oldValue)) {
                        throw new P("attribute-operation-wrong-old-value", this, {
                            item: t,
                            key: this.key,
                            value: this.oldValue
                        })
                    }
                    if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
                        throw new P("attribute-operation-attribute-exists", this, {node: t, key: this.key})
                    }
                }
            }

            _execute() {
                if (!sk(this.oldValue, this.newValue)) {
                    Yb(this.range, this.key, this.newValue)
                }
            }

            static get className() {
                return "AttributeOperation"
            }

            static fromJSON(t, e) {
                return new ak(Em.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }

        class lk extends Gb {
            get type() {
                return "noop"
            }

            clone() {
                return new lk(this.baseVersion)
            }

            getReversed() {
                return new lk(this.baseVersion + 1)
            }

            _execute() {
            }

            static get className() {
                return "NoOperation"
            }
        }

        class ck extends Gb {
            constructor(t, e, n, i) {
                super(i);
                this.position = t;
                this.position.stickiness = "toNext";
                this.oldName = e;
                this.newName = n
            }

            get type() {
                return "rename"
            }

            clone() {
                return new ck(this.position.clone(), this.oldName, this.newName, this.baseVersion)
            }

            getReversed() {
                return new ck(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
            }

            _validate() {
                const t = this.position.nodeAfter;
                if (!(t instanceof mm)) {
                    throw new P("rename-operation-wrong-position", this)
                } else if (t.name !== this.oldName) {
                    throw new P("rename-operation-wrong-name", this)
                }
            }

            _execute() {
                const t = this.position.nodeAfter;
                t.name = this.newName
            }

            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                return t
            }

            static get className() {
                return "RenameOperation"
            }

            static fromJSON(t, e) {
                return new ck(wm.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
            }
        }

        class dk extends Gb {
            constructor(t, e, n, i, o) {
                super(o);
                this.root = t;
                this.key = e;
                this.oldValue = n;
                this.newValue = i
            }

            get type() {
                if (this.oldValue === null) {
                    return "addRootAttribute"
                } else if (this.newValue === null) {
                    return "removeRootAttribute"
                } else {
                    return "changeRootAttribute"
                }
            }

            clone() {
                return new dk(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
            }

            getReversed() {
                return new dk(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }

            _validate() {
                if (this.root != this.root.root || this.root.is("documentFragment")) {
                    throw new P("rootattribute-operation-not-a-root", this, {root: this.root, key: this.key})
                }
                if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
                    throw new P("rootattribute-operation-wrong-old-value", this, {root: this.root, key: this.key})
                }
                if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
                    throw new P("rootattribute-operation-attribute-exists", this, {root: this.root, key: this.key})
                }
            }

            _execute() {
                if (this.newValue !== null) {
                    this.root._setAttribute(this.key, this.newValue)
                } else {
                    this.root._removeAttribute(this.key)
                }
            }

            toJSON() {
                const t = super.toJSON();
                t.root = this.root.toJSON();
                return t
            }

            static get className() {
                return "RootAttributeOperation"
            }

            static fromJSON(t, e) {
                if (!e.getRoot(t.root)) {
                    throw new P("rootattribute-operation-fromjson-no-root", this, {rootName: t.root})
                }
                return new dk(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }

        class uk extends Gb {
            constructor(t, e, n, i, o) {
                super(o);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toPrevious";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNext";
                this.graveyardPosition = i.clone()
            }

            get type() {
                return "merge"
            }

            get deletionPosition() {
                return new wm(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
            }

            get movedRange() {
                const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new Em(this.sourcePosition, t)
            }

            clone() {
                return new uk(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
            }

            getReversed() {
                const t = this.targetPosition._getTransformedByMergeOperation(this);
                const e = this.sourcePosition.path.slice(0, -1);
                const n = new wm(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                return new hk(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
            }

            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                if (!t.parent) {
                    throw new P("merge-operation-source-position-invalid", this)
                } else if (!e.parent) {
                    throw new P("merge-operation-target-position-invalid", this)
                } else if (this.howMany != t.maxOffset) {
                    throw new P("merge-operation-how-many-invalid", this)
                }
            }

            _execute() {
                const t = this.sourcePosition.parent;
                const e = Em._createIn(t);
                Jb(e, this.targetPosition);
                Jb(Em._createOn(t), this.graveyardPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = t.sourcePosition.toJSON();
                t.targetPosition = t.targetPosition.toJSON();
                t.graveyardPosition = t.graveyardPosition.toJSON();
                return t
            }

            static get className() {
                return "MergeOperation"
            }

            static fromJSON(t, e) {
                const n = wm.fromJSON(t.sourcePosition, e);
                const i = wm.fromJSON(t.targetPosition, e);
                const o = wm.fromJSON(t.graveyardPosition, e);
                return new this(n, t.howMany, i, o, t.baseVersion)
            }
        }

        class hk extends Gb {
            constructor(t, e, n, i, o) {
                super(o);
                this.splitPosition = t.clone();
                this.splitPosition.stickiness = "toNext";
                this.howMany = e;
                this.insertionPosition = n;
                this.graveyardPosition = i ? i.clone() : null;
                if (this.graveyardPosition) {
                    this.graveyardPosition.stickiness = "toNext"
                }
            }

            get type() {
                return "split"
            }

            get moveTargetPosition() {
                const t = this.insertionPosition.path.slice();
                t.push(0);
                return new wm(this.insertionPosition.root, t)
            }

            get movedRange() {
                const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new Em(this.splitPosition, t)
            }

            clone() {
                return new hk(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion)
            }

            getReversed() {
                const t = this.splitPosition.root.document.graveyard;
                const e = new wm(t, [0]);
                return new uk(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
            }

            _validate() {
                const t = this.splitPosition.parent;
                const e = this.splitPosition.offset;
                if (!t || t.maxOffset < e) {
                    throw new P("split-operation-position-invalid", this)
                } else if (!t.parent) {
                    throw new P("split-operation-split-in-root", this)
                } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
                    throw new P("split-operation-how-many-invalid", this)
                } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
                    throw new P("split-operation-graveyard-position-invalid", this)
                }
            }

            _execute() {
                const t = this.splitPosition.parent;
                if (this.graveyardPosition) {
                    Jb(Em._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
                } else {
                    const e = t._clone();
                    Kb(this.insertionPosition, e)
                }
                const e = new Em(wm._createAt(t, this.splitPosition.offset), wm._createAt(t, t.maxOffset));
                Jb(e, this.moveTargetPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.splitPosition = this.splitPosition.toJSON();
                t.insertionPosition = this.insertionPosition.toJSON();
                if (this.graveyardPosition) {
                    t.graveyardPosition = this.graveyardPosition.toJSON()
                }
                return t
            }

            static get className() {
                return "SplitOperation"
            }

            static getInsertionPosition(t) {
                const e = t.path.slice(0, -1);
                e[e.length - 1]++;
                return new wm(t.root, e, "toPrevious")
            }

            static fromJSON(t, e) {
                const n = wm.fromJSON(t.splitPosition, e);
                const i = wm.fromJSON(t.insertionPosition, e);
                const o = t.graveyardPosition ? wm.fromJSON(t.graveyardPosition, e) : null;
                return new this(n, t.howMany, i, o, t.baseVersion)
            }
        }

        const fk = {};
        fk[ak.className] = ak;
        fk[ik.className] = ik;
        fk[ok.className] = ok;
        fk[nk.className] = nk;
        fk[lk.className] = lk;
        fk[Gb.className] = Gb;
        fk[ck.className] = ck;
        fk[dk.className] = dk;
        fk[hk.className] = hk;
        fk[uk.className] = uk;

        class gk {
            static fromJSON(t, e) {
                return fk[t.__className].fromJSON(t, e)
            }
        }

        const mk = new Map;

        function pk(t, e, n) {
            let i = mk.get(t);
            if (!i) {
                i = new Map;
                mk.set(t, i)
            }
            i.set(e, n)
        }

        function bk(t, e) {
            const n = mk.get(t);
            if (n && n.has(e)) {
                return n.get(e)
            }
            return kk
        }

        function kk(t) {
            return [t]
        }

        function wk(t, e, n = {}) {
            const i = bk(t.constructor, e.constructor);
            try {
                t = t.clone();
                return i(t, e, n)
            } catch (t) {
                throw t
            }
        }

        function _k(t, e, n) {
            t = t.slice();
            e = e.slice();
            const i = new Ak(n.document, n.useRelations, n.forceWeakRemove);
            i.setOriginalOperations(t);
            i.setOriginalOperations(e);
            const o = i.originalOperations;
            if (t.length == 0 || e.length == 0) {
                return {operationsA: t, operationsB: e, originalOperations: o}
            }
            const r = new WeakMap;
            for (const e of t) {
                r.set(e, 0)
            }
            const s = {
                nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                originalOperationsACount: t.length,
                originalOperationsBCount: e.length
            };
            let a = 0;
            while (a < t.length) {
                const n = t[a];
                const o = r.get(n);
                if (o == e.length) {
                    a++;
                    continue
                }
                const s = e[o];
                const l = wk(n, s, i.getContext(n, s, true));
                const c = wk(s, n, i.getContext(s, n, false));
                i.updateRelation(n, s);
                i.setOriginalOperations(l, n);
                i.setOriginalOperations(c, s);
                for (const t of l) {
                    r.set(t, o + c.length)
                }
                t.splice(a, 1, ...l);
                e.splice(o, 1, ...c)
            }
            if (n.padWithNoOps) {
                const n = t.length - s.originalOperationsACount;
                const i = e.length - s.originalOperationsBCount;
                vk(t, i - n);
                vk(e, n - i)
            }
            Ck(t, s.nextBaseVersionB);
            Ck(e, s.nextBaseVersionA);
            return {operationsA: t, operationsB: e, originalOperations: o}
        }

        class Ak {
            constructor(t, e, n = false) {
                this.originalOperations = new Map;
                this._history = t.history;
                this._useRelations = e;
                this._forceWeakRemove = !!n;
                this._relations = new Map
            }

            setOriginalOperations(t, e = null) {
                const n = e ? this.originalOperations.get(e) : null;
                for (const e of t) {
                    this.originalOperations.set(e, n || e)
                }
            }

            updateRelation(t, e) {
                if (t instanceof nk) {
                    if (e instanceof uk) {
                        if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) {
                            this._setRelation(t, e, "insertAtSource")
                        } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                            this._setRelation(t, e, "insertBetween")
                        } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                            this._setRelation(t, e, "moveTargetAfter")
                        }
                    } else if (e instanceof nk) {
                        if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) {
                            this._setRelation(t, e, "insertBefore")
                        } else {
                            this._setRelation(t, e, "insertAfter")
                        }
                    }
                } else if (t instanceof hk) {
                    if (e instanceof uk) {
                        if (t.splitPosition.isBefore(e.sourcePosition)) {
                            this._setRelation(t, e, "splitBefore")
                        }
                    } else if (e instanceof nk) {
                        if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) {
                            this._setRelation(t, e, "splitBefore")
                        } else {
                            const n = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
                            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) {
                                const i = n.end.offset - t.splitPosition.offset;
                                const o = t.splitPosition.offset - n.start.offset;
                                this._setRelation(t, e, {howMany: i, offset: o})
                            }
                        }
                    }
                } else if (t instanceof uk) {
                    if (e instanceof uk) {
                        if (!t.targetPosition.isEqual(e.sourcePosition)) {
                            this._setRelation(t, e, "mergeTargetNotMoved")
                        }
                        if (t.sourcePosition.isEqual(e.targetPosition)) {
                            this._setRelation(t, e, "mergeSourceNotMoved")
                        }
                        if (t.sourcePosition.isEqual(e.sourcePosition)) {
                            this._setRelation(t, e, "mergeSameElement")
                        }
                    } else if (e instanceof hk) {
                        if (t.sourcePosition.isEqual(e.splitPosition)) {
                            this._setRelation(t, e, "splitAtSource")
                        }
                    }
                } else if (t instanceof ok) {
                    const n = t.newRange;
                    if (!n) {
                        return
                    }
                    if (e instanceof nk) {
                        const i = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
                        const o = i.containsPosition(n.start) || i.start.isEqual(n.start);
                        const r = i.containsPosition(n.end) || i.end.isEqual(n.end);
                        if ((o || r) && !i.containsRange(n)) {
                            this._setRelation(t, e, {
                                side: o ? "left" : "right",
                                path: o ? n.start.path.slice() : n.end.path.slice()
                            })
                        }
                    } else if (e instanceof uk) {
                        const i = n.start.isEqual(e.targetPosition);
                        const o = n.start.isEqual(e.deletionPosition);
                        const r = n.end.isEqual(e.deletionPosition);
                        const s = n.end.isEqual(e.sourcePosition);
                        if (i || o || r || s) {
                            this._setRelation(t, e, {
                                wasInLeftElement: i,
                                wasStartBeforeMergedElement: o,
                                wasEndBeforeMergedElement: r,
                                wasInRightElement: s
                            })
                        }
                    }
                }
            }

            getContext(t, e, n) {
                return {
                    aIsStrong: n,
                    aWasUndone: this._wasUndone(t),
                    bWasUndone: this._wasUndone(e),
                    abRelation: this._useRelations ? this._getRelation(t, e) : null,
                    baRelation: this._useRelations ? this._getRelation(e, t) : null,
                    forceWeakRemove: this._forceWeakRemove
                }
            }

            _wasUndone(t) {
                const e = this.originalOperations.get(t);
                return e.wasUndone || this._history.isUndoneOperation(e)
            }

            _getRelation(t, e) {
                const n = this.originalOperations.get(e);
                const i = this._history.getUndoneOperation(n);
                if (!i) {
                    return null
                }
                const o = this.originalOperations.get(t);
                const r = this._relations.get(o);
                if (r) {
                    return r.get(i) || null
                }
                return null
            }

            _setRelation(t, e, n) {
                const i = this.originalOperations.get(t);
                const o = this.originalOperations.get(e);
                let r = this._relations.get(i);
                if (!r) {
                    r = new Map;
                    this._relations.set(i, r)
                }
                r.set(o, n)
            }
        }

        function Ck(t, e) {
            for (const n of t) {
                n.baseVersion = e++
            }
        }

        function vk(t, e) {
            for (let n = 0; n < e; n++) {
                t.push(new lk(0))
            }
        }

        pk(ak, ak, ((t, e, n) => {
            if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
                const i = t.range.getDifference(e.range).map((e => new ak(e, t.key, t.oldValue, t.newValue, 0)));
                const o = t.range.getIntersection(e.range);
                if (o) {
                    if (n.aIsStrong) {
                        i.push(new ak(o, e.key, e.newValue, t.newValue, 0))
                    }
                }
                if (i.length == 0) {
                    return [new lk(0)]
                }
                return i
            } else {
                return [t]
            }
        }));
        pk(ak, ik, ((t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes);
                const i = n.map((e => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)));
                if (e.shouldReceiveAttributes) {
                    const n = yk(e, t.key, t.oldValue);
                    if (n) {
                        i.unshift(n)
                    }
                }
                return i
            }
            t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0];
            return [t]
        }));

        function yk(t, e, n) {
            const i = t.nodes;
            const o = i.getNode(0).getAttribute(e);
            if (o == n) {
                return null
            }
            const r = new Em(t.position, t.position.getShiftedBy(t.howMany));
            return new ak(r, e, o, n, 0)
        }

        pk(ak, uk, ((t, e) => {
            const n = [];
            if (t.range.start.hasSameParentAs(e.deletionPosition)) {
                if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) {
                    n.push(Em._createFromPositionAndShift(e.graveyardPosition, 1))
                }
            }
            const i = t.range._getTransformedByMergeOperation(e);
            if (!i.isCollapsed) {
                n.push(i)
            }
            return n.map((e => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));
        pk(ak, nk, ((t, e) => {
            const n = xk(t.range, e);
            return n.map((e => new ak(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));

        function xk(t, e) {
            const n = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let i = null;
            let o = [];
            if (n.containsRange(t, true)) {
                i = t
            } else if (t.start.hasSameParentAs(n.start)) {
                o = t.getDifference(n);
                i = t.getIntersection(n)
            } else {
                o = [t]
            }
            const r = [];
            for (let t of o) {
                t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = e.getMovedRangeStart();
                const i = t.start.hasSameParentAs(n);
                const o = t._getTransformedByInsertion(n, e.howMany, i);
                r.push(...o)
            }
            if (i) {
                r.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
            }
            return r
        }

        pk(ak, hk, ((t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.range.end.offset++
                }
                return [t]
            }
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                const n = t.clone();
                n.range = new Em(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition));
                t.range.end = e.splitPosition.clone();
                t.range.end.stickiness = "toPrevious";
                return [t, n]
            }
            t.range = t.range._getTransformedBySplitOperation(e);
            return [t]
        }));
        pk(ik, ak, ((t, e) => {
            const n = [t];
            if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                const i = yk(t, e.key, e.newValue);
                if (i) {
                    n.push(i)
                }
            }
            return n
        }));
        pk(ik, ik, ((t, e, n) => {
            if (t.position.isEqual(e.position) && n.aIsStrong) {
                return [t]
            }
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        pk(ik, nk, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        pk(ik, hk, ((t, e) => {
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        pk(ik, uk, ((t, e) => {
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        pk(ok, ik, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
            }
            return [t]
        }));
        pk(ok, ok, ((t, e, n) => {
            if (t.name == e.name) {
                if (n.aIsStrong) {
                    t.oldRange = e.newRange ? e.newRange.clone() : null
                } else {
                    return [new lk(0)]
                }
            }
            return [t]
        }));
        pk(ok, uk, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        pk(ok, nk, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = Em._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const i = Em._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                    if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
                        t.newRange.end = i.end;
                        t.newRange.start.path = n.abRelation.path;
                        return [t]
                    } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
                        t.newRange.start = i.start;
                        t.newRange.end.path = n.abRelation.path;
                        return [t]
                    }
                }
                t.newRange = Em._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            }
            return [t]
        }));
        pk(ok, hk, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const i = t.newRange._getTransformedBySplitOperation(e);
                    if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) {
                        t.newRange.start = wm._createAt(e.insertionPosition)
                    } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) {
                        t.newRange.start = wm._createAt(e.moveTargetPosition)
                    }
                    if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
                        t.newRange.end = wm._createAt(e.moveTargetPosition)
                    } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) {
                        t.newRange.end = wm._createAt(e.insertionPosition)
                    } else {
                        t.newRange.end = i.end
                    }
                    return [t]
                }
                t.newRange = t.newRange._getTransformedBySplitOperation(e)
            }
            return [t]
        }));
        pk(uk, ik, ((t, e) => {
            if (t.sourcePosition.hasSameParentAs(e.position)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
            return [t]
        }));
        pk(uk, uk, ((t, e, n) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                if (!n.bWasUndone) {
                    return [new lk(0)]
                } else {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    t.sourcePosition = new wm(e.graveyardPosition.root, n);
                    t.howMany = 0;
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") {
                const i = t.targetPosition.root.rootName == "$graveyard";
                const o = e.targetPosition.root.rootName == "$graveyard";
                const r = i && !o;
                const s = o && !i;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = e.targetPosition._getTransformedByMergeOperation(e);
                    const i = t.targetPosition._getTransformedByMergeOperation(e);
                    return [new nk(n, t.howMany, i, 0)]
                } else {
                    return [new lk(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        pk(uk, nk, ((t, e, n) => {
            const i = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.sourcePosition)) {
                    return [new lk(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
                t.howMany -= e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
            if (!t.graveyardPosition.isEqual(e.targetPosition)) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            return [t]
        }));
        pk(uk, hk, ((t, e, n) => {
            if (e.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1);
                if (t.deletionPosition.isEqual(e.graveyardPosition)) {
                    t.howMany = e.howMany
                }
            }
            if (t.targetPosition.isEqual(e.splitPosition)) {
                const i = e.howMany != 0;
                const o = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                if (i || o || n.abRelation == "mergeTargetNotMoved") {
                    t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
                if (n.abRelation == "mergeSourceNotMoved") {
                    t.howMany = 0;
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
                if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
                    t.sourcePosition = e.moveTargetPosition.clone();
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
                t.howMany = e.splitPosition.offset
            }
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
            return [t]
        }));
        pk(nk, ik, ((t, e) => {
            const n = Em._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const i = n._getTransformedByInsertOperation(e, false)[0];
            t.sourcePosition = i.start;
            t.howMany = i.end.offset - i.start.offset;
            if (!t.targetPosition.isEqual(e.position)) {
                t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
            }
            return [t]
        }));
        pk(nk, nk, ((t, e, n) => {
            const i = Em._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const o = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r = n.aIsStrong;
            let s = !n.aIsStrong;
            if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
                s = true
            } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
                s = false
            }
            let a;
            if (t.targetPosition.isEqual(e.targetPosition) && s) {
                a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
            } else {
                a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
            }
            if (Ek(t, e) && Ek(e, t)) {
                return [e.getReversed()]
            }
            const l = i.containsPosition(e.targetPosition);
            if (l && i.containsRange(o, true)) {
                i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return Sk([i], a)
            }
            const c = o.containsPosition(t.targetPosition);
            if (c && o.containsRange(i, true)) {
                i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                return Sk([i], a)
            }
            const d = vt(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if (d == "prefix" || d == "extension") {
                i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return Sk([i], a)
            }
            if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
                r = true
            } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                r = false
            }
            const u = [];
            const h = i.getDifference(o);
            for (const t of h) {
                t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = vt(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same";
                const i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                u.push(...i)
            }
            const f = i.getIntersection(o);
            if (f !== null && r) {
                f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                if (u.length === 0) {
                    u.push(f)
                } else if (u.length == 1) {
                    if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) {
                        u.unshift(f)
                    } else {
                        u.push(f)
                    }
                } else {
                    u.splice(1, 0, f)
                }
            }
            if (u.length === 0) {
                return [new lk(t.baseVersion)]
            }
            return Sk(u, a)
        }));
        pk(nk, hk, ((t, e, n) => {
            let i = t.targetPosition.clone();
            if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") {
                i = t.targetPosition._getTransformedBySplitOperation(e)
            }
            const o = Em._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (o.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.howMany++
                }
                t.targetPosition = i;
                return [t]
            }
            if (o.start.hasSameParentAs(e.splitPosition) && o.containsPosition(e.splitPosition)) {
                let t = new Em(e.splitPosition, o.end);
                t = t._getTransformedBySplitOperation(e);
                const n = [new Em(o.start, e.splitPosition), t];
                return Sk(n, i)
            }
            if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
                i = e.moveTargetPosition
            }
            if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
                i = t.targetPosition
            }
            const r = o._getTransformedBySplitOperation(e);
            const s = [r];
            if (e.graveyardPosition) {
                const i = o.start.isEqual(e.graveyardPosition) || o.containsPosition(e.graveyardPosition);
                if (t.howMany > 1 && i && !n.aWasUndone) {
                    s.push(Em._createFromPositionAndShift(e.insertionPosition, 1))
                }
            }
            return Sk(s, i)
        }));
        pk(nk, uk, ((t, e, n) => {
            const i = Em._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition)) {
                if (t.type == "remove" && !n.forceWeakRemove) {
                    if (!n.aWasUndone) {
                        const n = [];
                        let i = e.graveyardPosition.clone();
                        let o = e.targetPosition._getTransformedByMergeOperation(e);
                        if (t.howMany > 1) {
                            n.push(new nk(t.sourcePosition, t.howMany - 1, t.targetPosition, 0));
                            i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
                            o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                        }
                        const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition);
                        const s = new nk(i, 1, r, 0);
                        const a = s.getMovedRangeStart().path.slice();
                        a.push(0);
                        const l = new wm(s.targetPosition.root, a);
                        o = o._getTransformedByMove(i, r, 1);
                        const c = new nk(o, e.howMany, l, 0);
                        n.push(s);
                        n.push(c);
                        return n
                    }
                } else {
                    if (t.howMany == 1) {
                        if (!n.bWasUndone) {
                            return [new lk(0)]
                        } else {
                            t.sourcePosition = e.graveyardPosition.clone();
                            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                            return [t]
                        }
                    }
                }
            }
            const o = Em._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const r = o._getTransformedByMergeOperation(e);
            t.sourcePosition = r.start;
            t.howMany = r.end.offset - r.start.offset;
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            return [t]
        }));
        pk(ck, ik, ((t, e) => {
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        pk(ck, uk, ((t, e) => {
            if (t.position.isEqual(e.deletionPosition)) {
                t.position = e.graveyardPosition.clone();
                t.position.stickiness = "toNext";
                return [t]
            }
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        pk(ck, nk, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        pk(ck, ck, ((t, e, n) => {
            if (t.position.isEqual(e.position)) {
                if (n.aIsStrong) {
                    t.oldName = e.newName
                } else {
                    return [new lk(0)]
                }
            }
            return [t]
        }));
        pk(ck, hk, ((t, e) => {
            const n = t.position.path;
            const i = e.splitPosition.getParentPath();
            if (vt(n, i) == "same" && !e.graveyardPosition) {
                const e = new ck(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                return [t, e]
            }
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        pk(dk, dk, ((t, e, n) => {
            if (t.root === e.root && t.key === e.key) {
                if (!n.aIsStrong || t.newValue === e.newValue) {
                    return [new lk(0)]
                } else {
                    t.oldValue = e.newValue
                }
            }
            return [t]
        }));
        pk(hk, ik, ((t, e) => {
            if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
            t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e);
            return [t]
        }));
        pk(hk, uk, ((t, e, n) => {
            if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                const n = e.graveyardPosition.path.slice();
                n.push(0);
                const i = new wm(e.graveyardPosition.root, n);
                const o = hk.getInsertionPosition(new wm(e.graveyardPosition.root, n));
                const r = new hk(i, 0, o, null, 0);
                t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
                t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
                t.graveyardPosition = r.insertionPosition.clone();
                t.graveyardPosition.stickiness = "toNext";
                return [r, t]
            }
            if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) {
                t.howMany--
            }
            if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
            t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        pk(hk, nk, ((t, e, n) => {
            const i = Em._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
                const o = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition);
                if (!n.bWasUndone && o) {
                    const n = t.splitPosition._getTransformedByMoveOperation(e);
                    const i = t.graveyardPosition._getTransformedByMoveOperation(e);
                    const o = i.path.slice();
                    o.push(0);
                    const r = new wm(i.root, o);
                    const s = new nk(n, t.howMany, r, 0);
                    return [s]
                }
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            const o = t.splitPosition.isEqual(e.targetPosition);
            if (o && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
                t.howMany += e.howMany;
                t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
                return [t]
            }
            if (o && n.abRelation && n.abRelation.howMany) {
                const {howMany: e, offset: i} = n.abRelation;
                t.howMany += e;
                t.splitPosition = t.splitPosition.getShiftedBy(i);
                return [t]
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) {
                const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                t.howMany -= n;
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
                t.splitPosition = e.sourcePosition.clone();
                t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
                return [t]
            }
            if (!e.sourcePosition.isEqual(e.targetPosition)) {
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) {
                    t.howMany -= e.howMany
                }
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
            }
            t.splitPosition.stickiness = "toNone";
            t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
            t.splitPosition.stickiness = "toNext";
            if (t.graveyardPosition) {
                t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
            } else {
                t.insertionPosition = hk.getInsertionPosition(t.splitPosition)
            }
            return [t]
        }));
        pk(hk, hk, ((t, e, n) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
                if (!t.graveyardPosition && !e.graveyardPosition) {
                    return [new lk(0)]
                }
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                    return [new lk(0)]
                }
                if (n.abRelation == "splitBefore") {
                    t.howMany = 0;
                    t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                const i = t.splitPosition.root.rootName == "$graveyard";
                const o = e.splitPosition.root.rootName == "$graveyard";
                const r = i && !o;
                const s = o && !i;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = [];
                    if (e.howMany) {
                        n.push(new nk(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
                    }
                    if (t.howMany) {
                        n.push(new nk(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
                    }
                    return n
                } else {
                    return [new lk(0)]
                }
            }
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
            }
            if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
                t.howMany++;
                return [t]
            }
            if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
                const n = e.insertionPosition.path.slice();
                n.push(0);
                const i = new wm(e.insertionPosition.root, n);
                const o = new nk(t.insertionPosition, 1, i, 0);
                return [t, o]
            }
            if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) {
                t.howMany -= e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
            t.insertionPosition = hk.getInsertionPosition(t.splitPosition);
            return [t]
        }));

        function Ek(t, e) {
            return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
        }

        function Sk(t, e) {
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const o = t[i];
                const r = new nk(o.start, o.end.offset - o.start.offset, e, 0);
                n.push(r);
                for (let e = i + 1; e < t.length; e++) {
                    t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0]
                }
                e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
            }
            return n
        }

        class Dk extends (j(wm)) {
            constructor(t, e, n = "toNone") {
                super(t, e, n);
                if (!this.root.is("rootElement")) {
                    throw new P("model-liveposition-root-not-rootelement", t)
                }
                Tk.call(this)
            }

            detach() {
                this.stopListening()
            }

            toPosition() {
                return new wm(this.root, this.path.slice(), this.stickiness)
            }

            static fromPosition(t, e) {
                return new this(t.root, t.path.slice(), e ? e : t.stickiness)
            }
        }

        Dk.prototype.is = function (t) {
            return t === "livePosition" || t === "model:livePosition" || t == "position" || t === "model:position"
        };

        function Tk() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                Bk.call(this, n)
            }), {priority: "low"})
        }

        function Bk(t) {
            const e = this.getTransformedByOperation(t);
            if (!this.isEqual(e)) {
                const t = this.toPosition();
                this.path = e.path;
                this.root = e.root;
                this.fire("change", t)
            }
        }

        class Pk {
            constructor(t = {}) {
                if (typeof t === "string") {
                    t = t === "transparent" ? {isUndoable: false} : {};
                    I("batch-constructor-deprecated-string-type")
                }
                const {isUndoable: e = true, isLocal: n = true, isUndo: i = false, isTyping: o = false} = t;
                this.operations = [];
                this.isUndoable = e;
                this.isLocal = n;
                this.isUndo = i;
                this.isTyping = o
            }

            get type() {
                I("batch-type-deprecated");
                return "default"
            }

            get baseVersion() {
                for (const t of this.operations) {
                    if (t.baseVersion !== null) {
                        return t.baseVersion
                    }
                }
                return null
            }

            addOperation(t) {
                t.batch = this;
                this.operations.push(t);
                return t
            }
        }

        class Ik {
            constructor(t) {
                this._markerCollection = t;
                this._changesInElement = new Map;
                this._elementSnapshots = new Map;
                this._changedMarkers = new Map;
                this._changeCount = 0;
                this._cachedChanges = null;
                this._cachedChangesWithGraveyard = null;
                this._refreshedItems = new Set
            }

            get isEmpty() {
                return this._changesInElement.size == 0 && this._changedMarkers.size == 0
            }

            bufferOperation(t) {
                const e = t;
                switch (e.type) {
                    case"insert": {
                        if (this._isInInsertedElement(e.position.parent)) {
                            return
                        }
                        this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset);
                        break
                    }
                    case"addAttribute":
                    case"removeAttribute":
                    case"changeAttribute": {
                        for (const t of e.range.getItems({shallow: true})) {
                            if (this._isInInsertedElement(t.parent)) {
                                continue
                            }
                            this._markAttribute(t)
                        }
                        break
                    }
                    case"remove":
                    case"move":
                    case"reinsert": {
                        if (e.sourcePosition.isEqual(e.targetPosition) || e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)) {
                            return
                        }
                        const t = this._isInInsertedElement(e.sourcePosition.parent);
                        const n = this._isInInsertedElement(e.targetPosition.parent);
                        if (!t) {
                            this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany)
                        }
                        if (!n) {
                            this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany)
                        }
                        break
                    }
                    case"rename": {
                        if (this._isInInsertedElement(e.position.parent)) {
                            return
                        }
                        this._markRemove(e.position.parent, e.position.offset, 1);
                        this._markInsert(e.position.parent, e.position.offset, 1);
                        const t = Em._createFromPositionAndShift(e.position, 1);
                        for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                            const t = e.getData();
                            this.bufferMarkerChange(e.name, t, t)
                        }
                        break
                    }
                    case"split": {
                        const t = e.splitPosition.parent;
                        if (!this._isInInsertedElement(t)) {
                            this._markRemove(t, e.splitPosition.offset, e.howMany)
                        }
                        if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                            this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1)
                        }
                        if (e.graveyardPosition) {
                            this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1)
                        }
                        break
                    }
                    case"merge": {
                        const t = e.sourcePosition.parent;
                        if (!this._isInInsertedElement(t.parent)) {
                            this._markRemove(t.parent, t.startOffset, 1)
                        }
                        const n = e.graveyardPosition.parent;
                        this._markInsert(n, e.graveyardPosition.offset, 1);
                        const i = e.targetPosition.parent;
                        if (!this._isInInsertedElement(i)) {
                            this._markInsert(i, e.targetPosition.offset, t.maxOffset)
                        }
                        break
                    }
                }
                this._cachedChanges = null
            }

            bufferMarkerChange(t, e, n) {
                const i = this._changedMarkers.get(t);
                if (!i) {
                    this._changedMarkers.set(t, {newMarkerData: n, oldMarkerData: e})
                } else {
                    i.newMarkerData = n;
                    if (i.oldMarkerData.range == null && n.range == null) {
                        this._changedMarkers.delete(t)
                    }
                }
            }

            getMarkersToRemove() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.oldMarkerData.range != null) {
                        t.push({name: e, range: n.oldMarkerData.range})
                    }
                }
                return t
            }

            getMarkersToAdd() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.newMarkerData.range != null) {
                        t.push({name: e, range: n.newMarkerData.range})
                    }
                }
                return t
            }

            getChangedMarkers() {
                return Array.from(this._changedMarkers).map((([t, e]) => ({
                    name: t,
                    data: {oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range}
                })))
            }

            hasDataChanges() {
                if (this._changesInElement.size > 0) {
                    return true
                }
                for (const {newMarkerData: t, oldMarkerData: e} of this._changedMarkers.values()) {
                    if (t.affectsData !== e.affectsData) {
                        return true
                    }
                    if (t.affectsData) {
                        const n = t.range && !e.range;
                        const i = !t.range && e.range;
                        const o = t.range && e.range && !t.range.isEqual(e.range);
                        if (n || i || o) {
                            return true
                        }
                    }
                }
                return false
            }

            getChanges(t = {}) {
                if (this._cachedChanges) {
                    if (t.includeChangesInGraveyard) {
                        return this._cachedChangesWithGraveyard.slice()
                    } else {
                        return this._cachedChanges.slice()
                    }
                }
                let e = [];
                for (const t of this._changesInElement.keys()) {
                    const n = this._changesInElement.get(t).sort(((t, e) => {
                        if (t.offset === e.offset) {
                            if (t.type != e.type) {
                                return t.type == "remove" ? -1 : 1
                            }
                            return 0
                        }
                        return t.offset < e.offset ? -1 : 1
                    }));
                    const i = this._elementSnapshots.get(t);
                    const o = Rk(t.getChildren());
                    const r = zk(i.length, n);
                    let s = 0;
                    let a = 0;
                    for (const n of r) {
                        if (n === "i") {
                            e.push(this._getInsertDiff(t, s, o[s]));
                            s++
                        } else if (n === "r") {
                            e.push(this._getRemoveDiff(t, s, i[a]));
                            a++
                        } else if (n === "a") {
                            const n = o[s].attributes;
                            const r = i[a].attributes;
                            let l;
                            if (o[s].name == "$text") {
                                l = new Em(wm._createAt(t, s), wm._createAt(t, s + 1))
                            } else {
                                const e = t.offsetToIndex(s);
                                l = new Em(wm._createAt(t, s), wm._createAt(t.getChild(e), 0))
                            }
                            e.push(...this._getAttributesDiff(l, r, n));
                            s++;
                            a++
                        } else {
                            s++;
                            a++
                        }
                    }
                }
                e.sort(((t, e) => {
                    if (t.position.root != e.position.root) {
                        return t.position.root.rootName < e.position.root.rootName ? -1 : 1
                    }
                    if (t.position.isEqual(e.position)) {
                        return t.changeCount - e.changeCount
                    }
                    return t.position.isBefore(e.position) ? -1 : 1
                }));
                for (let t = 1, n = 0; t < e.length; t++) {
                    const i = e[n];
                    const o = e[t];
                    const r = i.type == "remove" && o.type == "remove" && i.name == "$text" && o.name == "$text" && i.position.isEqual(o.position);
                    const s = i.type == "insert" && o.type == "insert" && i.name == "$text" && o.name == "$text" && i.position.parent == o.position.parent && i.position.offset + i.length == o.position.offset;
                    const a = i.type == "attribute" && o.type == "attribute" && i.position.parent == o.position.parent && i.range.isFlat && o.range.isFlat && i.position.offset + i.length == o.position.offset && i.attributeKey == o.attributeKey && i.attributeOldValue == o.attributeOldValue && i.attributeNewValue == o.attributeNewValue;
                    if (r || s || a) {
                        i.length++;
                        if (a) {
                            i.range.end = i.range.end.getShiftedBy(1)
                        }
                        e[t] = null
                    } else {
                        n = t
                    }
                }
                e = e.filter((t => t));
                for (const t of e) {
                    delete t.changeCount;
                    if (t.type == "attribute") {
                        delete t.position;
                        delete t.length
                    }
                }
                this._changeCount = 0;
                this._cachedChangesWithGraveyard = e;
                this._cachedChanges = e.filter(Vk);
                if (t.includeChangesInGraveyard) {
                    return this._cachedChangesWithGraveyard.slice()
                } else {
                    return this._cachedChanges.slice()
                }
            }

            getRefreshedItems() {
                return new Set(this._refreshedItems)
            }

            reset() {
                this._changesInElement.clear();
                this._elementSnapshots.clear();
                this._changedMarkers.clear();
                this._refreshedItems = new Set;
                this._cachedChanges = null
            }

            _refreshItem(t) {
                if (this._isInInsertedElement(t.parent)) {
                    return
                }
                this._markRemove(t.parent, t.startOffset, t.offsetSize);
                this._markInsert(t.parent, t.startOffset, t.offsetSize);
                this._refreshedItems.add(t);
                const e = Em._createOn(t);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                    const e = t.getData();
                    this.bufferMarkerChange(t.name, e, e)
                }
                this._cachedChanges = null
            }

            _markInsert(t, e, n) {
                const i = {type: "insert", offset: e, howMany: n, count: this._changeCount++};
                this._markChange(t, i)
            }

            _markRemove(t, e, n) {
                const i = {type: "remove", offset: e, howMany: n, count: this._changeCount++};
                this._markChange(t, i);
                this._removeAllNestedChanges(t, e, n)
            }

            _markAttribute(t) {
                const e = {type: "attribute", offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++};
                this._markChange(t.parent, e)
            }

            _markChange(t, e) {
                this._makeSnapshot(t);
                const n = this._getChangesForElement(t);
                this._handleChange(e, n);
                n.push(e);
                for (let t = 0; t < n.length; t++) {
                    if (n[t].howMany < 1) {
                        n.splice(t, 1);
                        t--
                    }
                }
            }

            _getChangesForElement(t) {
                let e;
                if (this._changesInElement.has(t)) {
                    e = this._changesInElement.get(t)
                } else {
                    e = [];
                    this._changesInElement.set(t, e)
                }
                return e
            }

            _makeSnapshot(t) {
                if (!this._elementSnapshots.has(t)) {
                    this._elementSnapshots.set(t, Rk(t.getChildren()))
                }
            }

            _handleChange(t, e) {
                t.nodesToHandle = t.howMany;
                for (const n of e) {
                    const i = t.offset + t.howMany;
                    const o = n.offset + n.howMany;
                    if (t.type == "insert") {
                        if (n.type == "insert") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < o) {
                                n.howMany += t.nodesToHandle;
                                t.nodesToHandle = 0
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset) {
                                n.offset += t.howMany
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < o) {
                                const o = n.howMany;
                                n.howMany = t.offset - n.offset;
                                e.unshift({
                                    type: "attribute",
                                    offset: i,
                                    howMany: o - n.howMany,
                                    count: this._changeCount++
                                })
                            }
                        }
                    }
                    if (t.type == "remove") {
                        if (n.type == "insert") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (i <= o) {
                                if (t.offset < n.offset) {
                                    const e = i - n.offset;
                                    n.offset = t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                } else {
                                    n.howMany -= t.nodesToHandle;
                                    t.nodesToHandle = 0
                                }
                            } else {
                                if (t.offset <= n.offset) {
                                    t.nodesToHandle -= n.howMany;
                                    n.howMany = 0
                                } else if (t.offset < o) {
                                    const e = o - t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                t.nodesToHandle += n.howMany;
                                n.howMany = 0
                            }
                        }
                        if (n.type == "attribute") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                const e = i - n.offset;
                                n.offset = t.offset;
                                n.howMany -= e
                            } else if (t.offset < o) {
                                if (i <= o) {
                                    const i = n.howMany;
                                    n.howMany = t.offset - n.offset;
                                    const o = i - n.howMany - t.nodesToHandle;
                                    e.unshift({
                                        type: "attribute",
                                        offset: t.offset,
                                        howMany: o,
                                        count: this._changeCount++
                                    })
                                } else {
                                    n.howMany -= o - t.offset
                                }
                            }
                        }
                    }
                    if (t.type == "attribute") {
                        if (n.type == "insert") {
                            if (t.offset < n.offset && i > n.offset) {
                                if (i > o) {
                                    const t = {
                                        type: "attribute",
                                        offset: o,
                                        howMany: i - o,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(t, e);
                                    e.push(t)
                                }
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            } else if (t.offset >= n.offset && t.offset < o) {
                                if (i > o) {
                                    t.nodesToHandle = i - o;
                                    t.offset = o
                                } else {
                                    t.nodesToHandle = 0
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset && i > n.offset) {
                                const o = {
                                    type: "attribute",
                                    offset: n.offset,
                                    howMany: i - n.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(o, e);
                                e.push(o);
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset >= n.offset && i <= o) {
                                t.nodesToHandle = 0;
                                t.howMany = 0;
                                t.offset = 0
                            } else if (t.offset <= n.offset && i >= o) {
                                n.howMany = 0
                            }
                        }
                    }
                }
                t.howMany = t.nodesToHandle;
                delete t.nodesToHandle
            }

            _getInsertDiff(t, e, n) {
                return {
                    type: "insert",
                    position: wm._createAt(t, e),
                    name: n.name,
                    attributes: new Map(n.attributes),
                    length: 1,
                    changeCount: this._changeCount++
                }
            }

            _getRemoveDiff(t, e, n) {
                return {
                    type: "remove",
                    position: wm._createAt(t, e),
                    name: n.name,
                    attributes: new Map(n.attributes),
                    length: 1,
                    changeCount: this._changeCount++
                }
            }

            _getAttributesDiff(t, e, n) {
                const i = [];
                n = new Map(n);
                for (const [o, r] of e) {
                    const e = n.has(o) ? n.get(o) : null;
                    if (e !== r) {
                        i.push({
                            type: "attribute",
                            position: t.start,
                            range: t.clone(),
                            length: 1,
                            attributeKey: o,
                            attributeOldValue: r,
                            attributeNewValue: e,
                            changeCount: this._changeCount++
                        })
                    }
                    n.delete(o)
                }
                for (const [e, o] of n) {
                    i.push({
                        type: "attribute",
                        position: t.start,
                        range: t.clone(),
                        length: 1,
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: o,
                        changeCount: this._changeCount++
                    })
                }
                return i
            }

            _isInInsertedElement(t) {
                const e = t.parent;
                if (!e) {
                    return false
                }
                const n = this._changesInElement.get(e);
                const i = t.startOffset;
                if (n) {
                    for (const t of n) {
                        if (t.type == "insert" && i >= t.offset && i < t.offset + t.howMany) {
                            return true
                        }
                    }
                }
                return this._isInInsertedElement(e)
            }

            _removeAllNestedChanges(t, e, n) {
                const i = new Em(wm._createAt(t, e), wm._createAt(t, e + n));
                for (const t of i.getItems({shallow: true})) {
                    if (t.is("element")) {
                        this._elementSnapshots.delete(t);
                        this._changesInElement.delete(t);
                        this._removeAllNestedChanges(t, 0, t.maxOffset)
                    }
                }
            }
        }

        function Rk(t) {
            const e = [];
            for (const n of t) {
                if (n.is("$text")) {
                    for (let t = 0; t < n.data.length; t++) {
                        e.push({name: "$text", attributes: new Map(n.getAttributes())})
                    }
                } else {
                    e.push({name: n.name, attributes: new Map(n.getAttributes())})
                }
            }
            return e
        }

        function zk(t, e) {
            const n = [];
            let i = 0;
            let o = 0;
            for (const t of e) {
                if (t.offset > i) {
                    for (let e = 0; e < t.offset - i; e++) {
                        n.push("e")
                    }
                    o += t.offset - i
                }
                if (t.type == "insert") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("i")
                    }
                    i = t.offset + t.howMany
                } else if (t.type == "remove") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("r")
                    }
                    i = t.offset;
                    o += t.howMany
                } else {
                    n.push(..."a".repeat(t.howMany).split(""));
                    i = t.offset + t.howMany;
                    o += t.howMany
                }
            }
            if (o < t) {
                for (let e = 0; e < t - o - i; e++) {
                    n.push("e")
                }
            }
            return n
        }

        function Vk(t) {
            const e = "position" in t && t.position.root.rootName == "$graveyard";
            const n = "range" in t && t.range.root.rootName == "$graveyard";
            return !e && !n
        }

        class Fk {
            constructor() {
                this._operations = [];
                this._undoPairs = new Map;
                this._undoneOperations = new Set;
                this._baseVersionToOperationIndex = new Map;
                this._version = 0;
                this._gaps = new Map
            }

            get version() {
                return this._version
            }

            set version(t) {
                if (this._operations.length && t > this._version + 1) {
                    this._gaps.set(this._version, t)
                }
                this._version = t
            }

            get lastOperation() {
                return this._operations[this._operations.length - 1]
            }

            addOperation(t) {
                if (t.baseVersion !== this.version) {
                    throw new P("model-document-history-addoperation-incorrect-version", this, {
                        operation: t,
                        historyVersion: this.version
                    })
                }
                this._operations.push(t);
                this._version++;
                this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1)
            }

            getOperations(t, e = this.version) {
                if (!this._operations.length) {
                    return []
                }
                const n = this._operations[0];
                if (t === undefined) {
                    t = n.baseVersion
                }
                let i = e - 1;
                for (const [e, n] of this._gaps) {
                    if (t > e && t < n) {
                        t = n
                    }
                    if (i > e && i < n) {
                        i = e - 1
                    }
                }
                if (i < n.baseVersion || t > this.lastOperation.baseVersion) {
                    return []
                }
                let o = this._baseVersionToOperationIndex.get(t);
                if (o === undefined) {
                    o = 0
                }
                let r = this._baseVersionToOperationIndex.get(i);
                if (r === undefined) {
                    r = this._operations.length - 1
                }
                return this._operations.slice(o, r + 1)
            }

            getOperation(t) {
                const e = this._baseVersionToOperationIndex.get(t);
                if (e === undefined) {
                    return
                }
                return this._operations[e]
            }

            setOperationAsUndone(t, e) {
                this._undoPairs.set(e, t);
                this._undoneOperations.add(t)
            }

            isUndoingOperation(t) {
                return this._undoPairs.has(t)
            }

            isUndoneOperation(t) {
                return this._undoneOperations.has(t)
            }

            getUndoneOperation(t) {
                return this._undoPairs.get(t)
            }

            reset() {
                this._version = 0;
                this._undoPairs = new Map;
                this._operations = [];
                this._undoneOperations = new Set;
                this._gaps = new Map;
                this._baseVersionToOperationIndex = new Map
            }
        }

        class Lk extends mm {
            constructor(t, e, n = "main") {
                super(e);
                this._document = t;
                this.rootName = n
            }

            get document() {
                return this._document
            }

            toJSON() {
                return this.rootName
            }
        }

        Lk.prototype.is = function (t, e) {
            if (!e) {
                return t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element" || t === "node" || t === "model:node"
            }
            return e === this.name && (t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element")
        };
        const Ok = "$graveyard";

        class Nk extends (j()) {
            constructor(t) {
                super();
                this.model = t;
                this.history = new Fk;
                this.selection = new $m(this);
                this.roots = new rc({idProperty: "rootName"});
                this.differ = new Ik(t.markers);
                this._postFixers = new Set;
                this._hasSelectionChangedFromTheLastChangeBlock = false;
                this.createRoot("$root", Ok);
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.differ.bufferOperation(n)
                    }
                }), {priority: "high"});
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.history.addOperation(n)
                    }
                }), {priority: "low"});
                this.listenTo(this.selection, "change", (() => {
                    this._hasSelectionChangedFromTheLastChangeBlock = true
                }));
                this.listenTo(t.markers, "update", ((t, e, n, i, o) => {
                    const r = {...e.getData(), range: i};
                    this.differ.bufferMarkerChange(e.name, o, r);
                    if (n === null) {
                        e.on("change", ((t, n) => {
                            const i = e.getData();
                            this.differ.bufferMarkerChange(e.name, {...i, range: n}, i)
                        }))
                    }
                }))
            }

            get version() {
                return this.history.version
            }

            set version(t) {
                this.history.version = t
            }

            get graveyard() {
                return this.getRoot(Ok)
            }

            createRoot(t = "$root", e = "main") {
                if (this.roots.get(e)) {
                    throw new P("model-document-createroot-name-exists", this, {name: e})
                }
                const n = new Lk(this, t, e);
                this.roots.add(n);
                return n
            }

            destroy() {
                this.selection.destroy();
                this.stopListening()
            }

            getRoot(t = "main") {
                return this.roots.get(t)
            }

            getRootNames() {
                return Array.from(this.roots, (t => t.rootName)).filter((t => t != Ok))
            }

            registerPostFixer(t) {
                this._postFixers.add(t)
            }

            toJSON() {
                const t = Gc(this);
                t.selection = "[engine.model.DocumentSelection]";
                t.model = "[engine.model.Model]";
                return t
            }

            _handleChangeBlock(t) {
                if (this._hasDocumentChangedFromTheLastChangeBlock()) {
                    this._callPostFixers(t);
                    this.selection.refresh();
                    if (this.differ.hasDataChanges()) {
                        this.fire("change:data", t.batch)
                    } else {
                        this.fire("change", t.batch)
                    }
                    this.selection.refresh();
                    this.differ.reset()
                }
                this._hasSelectionChangedFromTheLastChangeBlock = false
            }

            _hasDocumentChangedFromTheLastChangeBlock() {
                return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
            }

            _getDefaultRoot() {
                for (const t of this.roots) {
                    if (t !== this.graveyard) {
                        return t
                    }
                }
                return this.graveyard
            }

            _getDefaultRange() {
                const t = this._getDefaultRoot();
                const e = this.model;
                const n = e.schema;
                const i = e.createPositionFromPath(t, [0]);
                const o = n.getNearestSelectionRange(i);
                return o || e.createRange(i)
            }

            _validateSelectionRange(t) {
                return Mk(t.start) && Mk(t.end)
            }

            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        this.selection.refresh();
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }

        function Mk(t) {
            const e = t.textNode;
            if (e) {
                const n = e.data;
                const i = t.offset - e.startOffset;
                return !pc(n, i) && !bc(n, i)
            }
            return true
        }

        class Hk extends (j()) {
            constructor() {
                super();
                this._markers = new Map
            }

            [Symbol.iterator]() {
                return this._markers.values()
            }

            has(t) {
                const e = t instanceof Wk ? t.name : t;
                return this._markers.has(e)
            }

            get(t) {
                return this._markers.get(t) || null
            }

            _set(t, e, n = false, i = false) {
                const o = t instanceof Wk ? t.name : t;
                if (o.includes(",")) {
                    throw new P("markercollection-incorrect-marker-name", this)
                }
                const r = this._markers.get(o);
                if (r) {
                    const t = r.getData();
                    const s = r.getRange();
                    let a = false;
                    if (!s.isEqual(e)) {
                        r._attachLiveRange(Mm.fromRange(e));
                        a = true
                    }
                    if (n != r.managedUsingOperations) {
                        r._managedUsingOperations = n;
                        a = true
                    }
                    if (typeof i === "boolean" && i != r.affectsData) {
                        r._affectsData = i;
                        a = true
                    }
                    if (a) {
                        this.fire(`update:${o}`, r, s, e, t)
                    }
                    return r
                }
                const s = Mm.fromRange(e);
                const a = new Wk(o, s, n, i);
                this._markers.set(o, a);
                this.fire(`update:${o}`, a, null, e, {...a.getData(), range: null});
                return a
            }

            _remove(t) {
                const e = t instanceof Wk ? t.name : t;
                const n = this._markers.get(e);
                if (n) {
                    this._markers.delete(e);
                    this.fire(`update:${e}`, n, n.getRange(), null, n.getData());
                    this._destroyMarker(n);
                    return true
                }
                return false
            }

            _refresh(t) {
                const e = t instanceof Wk ? t.name : t;
                const n = this._markers.get(e);
                if (!n) {
                    throw new P("markercollection-refresh-marker-not-exists", this)
                }
                const i = n.getRange();
                this.fire(`update:${e}`, n, i, i, n.getData())
            }

            * getMarkersAtPosition(t) {
                for (const e of this) {
                    if (e.getRange().containsPosition(t)) {
                        yield e
                    }
                }
            }

            * getMarkersIntersectingRange(t) {
                for (const e of this) {
                    if (e.getRange().getIntersection(t) !== null) {
                        yield e
                    }
                }
            }

            destroy() {
                for (const t of this._markers.values()) {
                    this._destroyMarker(t)
                }
                this._markers = null;
                this.stopListening()
            }

            * getMarkersGroup(t) {
                for (const e of this._markers.values()) {
                    if (e.name.startsWith(t + ":")) {
                        yield e
                    }
                }
            }

            _destroyMarker(t) {
                t.stopListening();
                t._detachLiveRange()
            }
        }

        class Wk extends (j(dm)) {
            constructor(t, e, n, i) {
                super();
                this.name = t;
                this._liveRange = this._attachLiveRange(e);
                this._managedUsingOperations = n;
                this._affectsData = i
            }

            get managedUsingOperations() {
                if (!this._liveRange) {
                    throw new P("marker-destroyed", this)
                }
                return this._managedUsingOperations
            }

            get affectsData() {
                if (!this._liveRange) {
                    throw new P("marker-destroyed", this)
                }
                return this._affectsData
            }

            getData() {
                return {
                    range: this.getRange(),
                    affectsData: this.affectsData,
                    managedUsingOperations: this.managedUsingOperations
                }
            }

            getStart() {
                if (!this._liveRange) {
                    throw new P("marker-destroyed", this)
                }
                return this._liveRange.start.clone()
            }

            getEnd() {
                if (!this._liveRange) {
                    throw new P("marker-destroyed", this)
                }
                return this._liveRange.end.clone()
            }

            getRange() {
                if (!this._liveRange) {
                    throw new P("marker-destroyed", this)
                }
                return this._liveRange.toRange()
            }

            _attachLiveRange(t) {
                if (this._liveRange) {
                    this._detachLiveRange()
                }
                t.delegate("change:range").to(this);
                t.delegate("change:content").to(this);
                this._liveRange = t;
                return t
            }

            _detachLiveRange() {
                this._liveRange.stopDelegating("change:range", this);
                this._liveRange.stopDelegating("change:content", this);
                this._liveRange.detach();
                this._liveRange = null
            }
        }

        Wk.prototype.is = function (t) {
            return t === "marker" || t === "model:marker"
        };

        class qk extends Gb {
            constructor(t, e) {
                super(null);
                this.sourcePosition = t.clone();
                this.howMany = e
            }

            get type() {
                return "detach"
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                return t
            }

            _validate() {
                if (this.sourcePosition.root.document) {
                    throw new P("detach-operation-on-document-node", this)
                }
            }

            _execute() {
                Zb(Em._createFromPositionAndShift(this.sourcePosition, this.howMany))
            }

            static get className() {
                return "DetachOperation"
            }
        }

        class jk extends dm {
            constructor(t) {
                super();
                this.markers = new Map;
                this._children = new hm;
                if (t) {
                    this._insertChild(0, t)
                }
            }

            [Symbol.iterator]() {
                return this.getChildren()
            }

            get childCount() {
                return this._children.length
            }

            get maxOffset() {
                return this._children.maxOffset
            }

            get isEmpty() {
                return this.childCount === 0
            }

            get nextSibling() {
                return null
            }

            get previousSibling() {
                return null
            }

            get root() {
                return this
            }

            get parent() {
                return null
            }

            get document() {
                return null
            }

            getAncestors() {
                return []
            }

            getChild(t) {
                return this._children.getNode(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }

            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }

            getPath() {
                return []
            }

            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }

            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }

            toJSON() {
                const t = [];
                for (const e of this._children) {
                    t.push(e.toJSON())
                }
                return t
            }

            static fromJSON(t) {
                const e = [];
                for (const n of t) {
                    if (n.name) {
                        e.push(mm.fromJSON(n))
                    } else {
                        e.push(fm.fromJSON(n))
                    }
                }
                return new jk(e)
            }

            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                const n = $k(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }

            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }
        }

        jk.prototype.is = function (t) {
            return t === "documentFragment" || t === "model:documentFragment"
        };

        function $k(t) {
            if (typeof t == "string") {
                return [new fm(t)]
            }
            if (!yt(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new fm(t)
                }
                if (t instanceof gm) {
                    return new fm(t.data, t.getAttributes())
                }
                return t
            }))
        }

        class Uk {
            constructor(t, e) {
                this.model = t;
                this.batch = e
            }

            createText(t, e) {
                return new fm(t, e)
            }

            createElement(t, e) {
                return new mm(t, e)
            }

            createDocumentFragment() {
                return new jk
            }

            cloneElement(t, e = true) {
                return t._clone(e)
            }

            insert(t, e, n = 0) {
                this._assertWriterUsedCorrectly();
                if (t instanceof fm && t.data == "") {
                    return
                }
                const i = wm._createAt(e, n);
                if (t.parent) {
                    if (Yk(t.root, i.root)) {
                        this.move(Em._createOn(t), i);
                        return
                    } else {
                        if (t.root.document) {
                            throw new P("model-writer-insert-forbidden-move", this)
                        } else {
                            this.remove(t)
                        }
                    }
                }
                const o = i.root.document ? i.root.document.version : null;
                const r = new ik(i, t, o);
                if (t instanceof fm) {
                    r.shouldReceiveAttributes = true
                }
                this.batch.addOperation(r);
                this.model.applyOperation(r);
                if (t instanceof jk) {
                    for (const [e, n] of t.markers) {
                        const t = wm._createAt(n.root, 0);
                        const o = new Em(n.start._getCombined(t, i), n.end._getCombined(t, i));
                        const r = {range: o, usingOperation: true, affectsData: true};
                        if (this.model.markers.has(e)) {
                            this.updateMarker(e, r)
                        } else {
                            this.addMarker(e, r)
                        }
                    }
                }
            }

            insertText(t, e, n, i) {
                if (e instanceof jk || e instanceof mm || e instanceof wm) {
                    this.insert(this.createText(t), e, n)
                } else {
                    this.insert(this.createText(t, e), n, i)
                }
            }

            insertElement(t, e, n, i) {
                if (e instanceof jk || e instanceof mm || e instanceof wm) {
                    this.insert(this.createElement(t), e, n)
                } else {
                    this.insert(this.createElement(t, e), n, i)
                }
            }

            append(t, e) {
                this.insert(t, e, "end")
            }

            appendText(t, e, n) {
                if (e instanceof jk || e instanceof mm) {
                    this.insert(this.createText(t), e, "end")
                } else {
                    this.insert(this.createText(t, e), n, "end")
                }
            }

            appendElement(t, e, n) {
                if (e instanceof jk || e instanceof mm) {
                    this.insert(this.createElement(t), e, "end")
                } else {
                    this.insert(this.createElement(t, e), n, "end")
                }
            }

            setAttribute(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (n instanceof Em) {
                    const i = n.getMinimalFlatRanges();
                    for (const n of i) {
                        Gk(this, t, e, n)
                    }
                } else {
                    Kk(this, t, e, n)
                }
            }

            setAttributes(t, e) {
                for (const [n, i] of dc(t)) {
                    this.setAttribute(n, i, e)
                }
            }

            removeAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (e instanceof Em) {
                    const n = e.getMinimalFlatRanges();
                    for (const e of n) {
                        Gk(this, t, null, e)
                    }
                } else {
                    Kk(this, t, null, e)
                }
            }

            clearAttributes(t) {
                this._assertWriterUsedCorrectly();
                const e = t => {
                    for (const e of t.getAttributeKeys()) {
                        this.removeAttribute(e, t)
                    }
                };
                if (!(t instanceof Em)) {
                    e(t)
                } else {
                    for (const n of t.getItems()) {
                        e(n)
                    }
                }
            }

            move(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof Em)) {
                    throw new P("writer-move-invalid-range", this)
                }
                if (!t.isFlat) {
                    throw new P("writer-move-range-not-flat", this)
                }
                const i = wm._createAt(e, n);
                if (i.isEqual(t.start)) {
                    return
                }
                this._addOperationForAffectedMarkers("move", t);
                if (!Yk(t.root, i.root)) {
                    throw new P("writer-move-different-document", this)
                }
                const o = t.root.document ? t.root.document.version : null;
                const r = new nk(t.start, t.end.offset - t.start.offset, i, o);
                this.batch.addOperation(r);
                this.model.applyOperation(r)
            }

            remove(t) {
                this._assertWriterUsedCorrectly();
                const e = t instanceof Em ? t : Em._createOn(t);
                const n = e.getMinimalFlatRanges().reverse();
                for (const t of n) {
                    this._addOperationForAffectedMarkers("move", t);
                    Jk(t.start, t.end.offset - t.start.offset, this.batch, this.model)
                }
            }

            merge(t) {
                this._assertWriterUsedCorrectly();
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this._addOperationForAffectedMarkers("merge", t);
                if (!(e instanceof mm)) {
                    throw new P("writer-merge-no-element-before", this)
                }
                if (!(n instanceof mm)) {
                    throw new P("writer-merge-no-element-after", this)
                }
                if (!t.root.document) {
                    this._mergeDetached(t)
                } else {
                    this._merge(t)
                }
            }

            createPositionFromPath(t, e, n) {
                return this.model.createPositionFromPath(t, e, n)
            }

            createPositionAt(t, e) {
                return this.model.createPositionAt(t, e)
            }

            createPositionAfter(t) {
                return this.model.createPositionAfter(t)
            }

            createPositionBefore(t) {
                return this.model.createPositionBefore(t)
            }

            createRange(t, e) {
                return this.model.createRange(t, e)
            }

            createRangeIn(t) {
                return this.model.createRangeIn(t)
            }

            createRangeOn(t) {
                return this.model.createRangeOn(t)
            }

            createSelection(...t) {
                return this.model.createSelection(...t)
            }

            _mergeDetached(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this.move(Em._createIn(n), wm._createAt(e, "end"));
                this.remove(n)
            }

            _merge(t) {
                const e = wm._createAt(t.nodeBefore, "end");
                const n = wm._createAt(t.nodeAfter, 0);
                const i = t.root.document.graveyard;
                const o = new wm(i, [0]);
                const r = t.root.document.version;
                const s = new uk(n, t.nodeAfter.maxOffset, e, o, r);
                this.batch.addOperation(s);
                this.model.applyOperation(s)
            }

            rename(t, e) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof mm)) {
                    throw new P("writer-rename-not-element-instance", this)
                }
                const n = t.root.document ? t.root.document.version : null;
                const i = new ck(wm._createBefore(t), t.name, e, n);
                this.batch.addOperation(i);
                this.model.applyOperation(i)
            }

            split(t, e) {
                this._assertWriterUsedCorrectly();
                let n = t.parent;
                if (!n.parent) {
                    throw new P("writer-split-element-no-parent", this)
                }
                if (!e) {
                    e = n.parent
                }
                if (!t.parent.getAncestors({includeSelf: true}).includes(e)) {
                    throw new P("writer-split-invalid-limit-element", this)
                }
                let i;
                let o;
                do {
                    const e = n.root.document ? n.root.document.version : null;
                    const r = n.maxOffset - t.offset;
                    const s = hk.getInsertionPosition(t);
                    const a = new hk(t, r, s, null, e);
                    this.batch.addOperation(a);
                    this.model.applyOperation(a);
                    if (!i && !o) {
                        i = n;
                        o = t.parent.nextSibling
                    }
                    t = this.createPositionAfter(t.parent);
                    n = t.parent
                } while (n !== e);
                return {position: t, range: new Em(wm._createAt(i, "end"), wm._createAt(o, 0))}
            }

            wrap(t, e) {
                this._assertWriterUsedCorrectly();
                if (!t.isFlat) {
                    throw new P("writer-wrap-range-not-flat", this)
                }
                const n = e instanceof mm ? e : new mm(e);
                if (n.childCount > 0) {
                    throw new P("writer-wrap-element-not-empty", this)
                }
                if (n.parent !== null) {
                    throw new P("writer-wrap-element-attached", this)
                }
                this.insert(n, t.start);
                const i = new Em(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                this.move(i, wm._createAt(n, 0))
            }

            unwrap(t) {
                this._assertWriterUsedCorrectly();
                if (t.parent === null) {
                    throw new P("writer-unwrap-element-no-parent", this)
                }
                this.move(Em._createIn(t), this.createPositionAfter(t));
                this.remove(t)
            }

            addMarker(t, e) {
                this._assertWriterUsedCorrectly();
                if (!e || typeof e.usingOperation != "boolean") {
                    throw new P("writer-addmarker-no-usingoperation", this)
                }
                const n = e.usingOperation;
                const i = e.range;
                const o = e.affectsData === undefined ? false : e.affectsData;
                if (this.model.markers.has(t)) {
                    throw new P("writer-addmarker-marker-exists", this)
                }
                if (!i) {
                    throw new P("writer-addmarker-no-range", this)
                }
                if (!n) {
                    return this.model.markers._set(t, i, n, o)
                }
                Zk(this, t, null, i, o);
                return this.model.markers.get(t)
            }

            updateMarker(t, e) {
                this._assertWriterUsedCorrectly();
                const n = typeof t == "string" ? t : t.name;
                const i = this.model.markers.get(n);
                if (!i) {
                    throw new P("writer-updatemarker-marker-not-exists", this)
                }
                if (!e) {
                    I("writer-updatemarker-reconvert-using-editingcontroller", {markerName: n});
                    this.model.markers._refresh(i);
                    return
                }
                const o = typeof e.usingOperation == "boolean";
                const r = typeof e.affectsData == "boolean";
                const s = r ? e.affectsData : i.affectsData;
                if (!o && !e.range && !r) {
                    throw new P("writer-updatemarker-wrong-options", this)
                }
                const a = i.getRange();
                const l = e.range ? e.range : a;
                if (o && e.usingOperation !== i.managedUsingOperations) {
                    if (e.usingOperation) {
                        Zk(this, n, null, l, s)
                    } else {
                        Zk(this, n, a, null, s);
                        this.model.markers._set(n, l, undefined, s)
                    }
                    return
                }
                if (i.managedUsingOperations) {
                    Zk(this, n, a, l, s)
                } else {
                    this.model.markers._set(n, l, undefined, s)
                }
            }

            removeMarker(t) {
                this._assertWriterUsedCorrectly();
                const e = typeof t == "string" ? t : t.name;
                if (!this.model.markers.has(e)) {
                    throw new P("writer-removemarker-no-marker", this)
                }
                const n = this.model.markers.get(e);
                if (!n.managedUsingOperations) {
                    this.model.markers._remove(e);
                    return
                }
                const i = n.getRange();
                Zk(this, e, i, null, n.affectsData)
            }

            setSelection(...t) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setTo(...t)
            }

            setSelectionFocus(t, e) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setFocus(t, e)
            }

            setSelectionAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._setSelectionAttribute(t, e)
                } else {
                    for (const [e, n] of dc(t)) {
                        this._setSelectionAttribute(e, n)
                    }
                }
            }

            removeSelectionAttribute(t) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._removeSelectionAttribute(t)
                } else {
                    for (const e of t) {
                        this._removeSelectionAttribute(e)
                    }
                }
            }

            overrideSelectionGravity() {
                return this.model.document.selection._overrideGravity()
            }

            restoreSelectionGravity(t) {
                this.model.document.selection._restoreGravity(t)
            }

            _setSelectionAttribute(t, e) {
                const n = this.model.document.selection;
                if (n.isCollapsed && n.anchor.parent.isEmpty) {
                    const i = $m._getStoreAttributeKey(t);
                    this.setAttribute(i, e, n.anchor.parent)
                }
                n._setAttribute(t, e)
            }

            _removeSelectionAttribute(t) {
                const e = this.model.document.selection;
                if (e.isCollapsed && e.anchor.parent.isEmpty) {
                    const n = $m._getStoreAttributeKey(t);
                    this.removeAttribute(n, e.anchor.parent)
                }
                e._removeAttribute(t)
            }

            _assertWriterUsedCorrectly() {
                if (this.model._currentWriter !== this) {
                    throw new P("writer-incorrect-use", this)
                }
            }

            _addOperationForAffectedMarkers(t, e) {
                for (const n of this.model.markers) {
                    if (!n.managedUsingOperations) {
                        continue
                    }
                    const i = n.getRange();
                    let o = false;
                    if (t === "move") {
                        const t = e;
                        o = t.containsPosition(i.start) || t.start.isEqual(i.start) || t.containsPosition(i.end) || t.end.isEqual(i.end)
                    } else {
                        const t = e;
                        const n = t.nodeBefore;
                        const r = t.nodeAfter;
                        const s = i.start.parent == n && i.start.isAtEnd;
                        const a = i.end.parent == r && i.end.offset == 0;
                        const l = i.end.nodeAfter == r;
                        const c = i.start.nodeAfter == r;
                        o = s || a || l || c
                    }
                    if (o) {
                        this.updateMarker(n.name, {range: i})
                    }
                }
            }
        }

        function Gk(t, e, n, i) {
            const o = t.model;
            const r = o.document;
            let s = i.start;
            let a;
            let l;
            let c;
            for (const t of i.getWalker({shallow: true})) {
                c = t.item.getAttribute(e);
                if (a && l != c) {
                    if (l != n) {
                        d()
                    }
                    s = a
                }
                a = t.nextPosition;
                l = c
            }
            if (a instanceof wm && a != s && l != n) {
                d()
            }

            function d() {
                const i = new Em(s, a);
                const c = i.root.document ? r.version : null;
                const d = new ak(i, e, l, n, c);
                t.batch.addOperation(d);
                o.applyOperation(d)
            }
        }

        function Kk(t, e, n, i) {
            const o = t.model;
            const r = o.document;
            const s = i.getAttribute(e);
            let a, l;
            if (s != n) {
                const c = i.root === i;
                if (c) {
                    const t = i.document ? r.version : null;
                    l = new dk(i, e, s, n, t)
                } else {
                    a = new Em(wm._createBefore(i), t.createPositionAfter(i));
                    const o = a.root.document ? r.version : null;
                    l = new ak(a, e, s, n, o)
                }
                t.batch.addOperation(l);
                o.applyOperation(l)
            }
        }

        function Zk(t, e, n, i, o) {
            const r = t.model;
            const s = r.document;
            const a = new ok(e, n, i, r.markers, !!o, s.version);
            t.batch.addOperation(a);
            r.applyOperation(a)
        }

        function Jk(t, e, n, i) {
            let o;
            if (t.root.document) {
                const n = i.document;
                const r = new wm(n.graveyard, [0]);
                o = new nk(t, e, r, n.version)
            } else {
                o = new qk(t, e)
            }
            n.addOperation(o);
            i.applyOperation(o)
        }

        function Yk(t, e) {
            if (t === e) {
                return true
            }
            if (t instanceof Lk && e instanceof Lk) {
                return true
            }
            return false
        }

        function Qk(t) {
            t.document.registerPostFixer((e => Xk(e, t)))
        }

        function Xk(t, e) {
            const n = e.document.selection;
            const i = e.schema;
            const o = [];
            let r = false;
            for (const t of n.getRanges()) {
                const e = tw(t, i);
                if (e && !e.isEqual(t)) {
                    o.push(e);
                    r = true
                } else {
                    o.push(t)
                }
            }
            if (r) {
                t.setSelection(rw(o), {backward: n.isBackward})
            }
            return false
        }

        function tw(t, e) {
            if (t.isCollapsed) {
                return ew(t, e)
            }
            return nw(t, e)
        }

        function ew(t, e) {
            const n = t.start;
            const i = e.getNearestSelectionRange(n);
            if (!i) {
                const t = n.getAncestors().reverse().find((t => e.isObject(t)));
                if (t) {
                    return Em._createOn(t)
                }
                return null
            }
            if (!i.isCollapsed) {
                return i
            }
            const o = i.start;
            if (n.isEqual(o)) {
                return null
            }
            return new Em(o)
        }

        function nw(t, e) {
            const {start: n, end: i} = t;
            const o = e.checkChild(n, "$text");
            const r = e.checkChild(i, "$text");
            const s = e.getLimitElement(n);
            const a = e.getLimitElement(i);
            if (s === a) {
                if (o && r) {
                    return null
                }
                if (ow(n, i, e)) {
                    const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
                    const o = t ? null : e.getNearestSelectionRange(n, "forward");
                    const r = i.nodeBefore && e.isSelectable(i.nodeBefore);
                    const s = r ? null : e.getNearestSelectionRange(i, "backward");
                    const a = o ? o.start : n;
                    const l = s ? s.end : i;
                    return new Em(a, l)
                }
            }
            const l = s && !s.is("rootElement");
            const c = a && !a.is("rootElement");
            if (l || c) {
                const t = n.nodeAfter && i.nodeBefore && n.nodeAfter.parent === i.nodeBefore.parent;
                const o = l && (!t || !sw(n.nodeAfter, e));
                const r = c && (!t || !sw(i.nodeBefore, e));
                let d = n;
                let u = i;
                if (o) {
                    d = wm._createBefore(iw(s, e))
                }
                if (r) {
                    u = wm._createAfter(iw(a, e))
                }
                return new Em(d, u)
            }
            return null
        }

        function iw(t, e) {
            let n = t;
            let i = n;
            while (e.isLimit(i) && i.parent) {
                n = i;
                i = i.parent
            }
            return n
        }

        function ow(t, e, n) {
            const i = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text");
            const o = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
            return i || o
        }

        function rw(t) {
            const e = [...t];
            const n = new Set;
            let i = 1;
            while (i < e.length) {
                const t = e[i];
                const o = e.slice(0, i);
                for (const [r, s] of o.entries()) {
                    if (n.has(r)) {
                        continue
                    }
                    if (t.isEqual(s)) {
                        n.add(r)
                    } else if (t.isIntersecting(s)) {
                        n.add(r);
                        n.add(i);
                        const o = t.getJoined(s);
                        e.push(o)
                    }
                }
                i++
            }
            const o = e.filter(((t, e) => !n.has(e)));
            return o
        }

        function sw(t, e) {
            return t && e.isSelectable(t)
        }

        function aw(t, e, n = {}) {
            if (e.isCollapsed) {
                return
            }
            const i = e.getFirstRange();
            if (i.root.rootName == "$graveyard") {
                return
            }
            const o = t.schema;
            t.change((t => {
                if (!n.doNotResetEntireContent && _w(o, e)) {
                    ww(t, e);
                    return
                }
                const r = {};
                if (!n.doNotAutoparagraph) {
                    const t = e.getSelectedElement();
                    if (t) {
                        Object.assign(r, o.getAttributesWithProperty(t, "copyOnReplace", true))
                    }
                }
                const [s, a] = lw(i);
                if (!s.isTouching(a)) {
                    t.remove(t.createRange(s, a))
                }
                if (!n.leaveUnmerged) {
                    dw(t, s, a);
                    o.removeDisallowedAttributes(s.parent.getChildren(), t)
                }
                Aw(t, e, s);
                if (!n.doNotAutoparagraph && pw(o, s)) {
                    kw(t, s, e, r)
                }
                s.detach();
                a.detach()
            }))
        }

        function lw(t) {
            const e = t.root.document.model;
            const n = t.start;
            let i = t.end;
            if (e.hasContent(t, {ignoreMarkers: true})) {
                const n = cw(i);
                if (n && i.isTouching(e.createPositionAt(n, 0))) {
                    const n = e.createSelection(t);
                    e.modifySelection(n, {direction: "backward"});
                    const o = n.getLastPosition();
                    const r = e.createRange(o, i);
                    if (!e.hasContent(r, {ignoreMarkers: true})) {
                        i = o
                    }
                }
            }
            return [Dk.fromPosition(n, "toPrevious"), Dk.fromPosition(i, "toNext")]
        }

        function cw(t) {
            const e = t.parent;
            const n = e.root.document.model.schema;
            const i = e.getAncestors({parentFirst: true, includeSelf: true});
            for (const t of i) {
                if (n.isLimit(t)) {
                    return null
                }
                if (n.isBlock(t)) {
                    return t
                }
            }
        }

        function dw(t, e, n) {
            const i = t.model;
            if (!gw(t.model.schema, e, n)) {
                return
            }
            const [o, r] = mw(e, n);
            if (!o || !r) {
                return
            }
            if (!i.hasContent(o, {ignoreMarkers: true}) && i.hasContent(r, {ignoreMarkers: true})) {
                hw(t, e, n, o.parent)
            } else {
                uw(t, e, n, o.parent)
            }
        }

        function uw(t, e, n, i) {
            const o = e.parent;
            const r = n.parent;
            if (o == i || r == i) {
                return
            }
            e = t.createPositionAfter(o);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(r, e)
            }
            t.merge(e);
            while (n.parent.isEmpty) {
                const e = n.parent;
                n = t.createPositionBefore(e);
                t.remove(e)
            }
            if (!gw(t.model.schema, e, n)) {
                return
            }
            uw(t, e, n, i)
        }

        function hw(t, e, n, i) {
            const o = e.parent;
            const r = n.parent;
            if (o == i || r == i) {
                return
            }
            e = t.createPositionAfter(o);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(o, n)
            }
            while (e.parent.isEmpty) {
                const n = e.parent;
                e = t.createPositionBefore(n);
                t.remove(n)
            }
            n = t.createPositionBefore(r);
            fw(t, n);
            if (!gw(t.model.schema, e, n)) {
                return
            }
            hw(t, e, n, i)
        }

        function fw(t, e) {
            const n = e.nodeBefore;
            const i = e.nodeAfter;
            if (n.name != i.name) {
                t.rename(n, i.name)
            }
            t.clearAttributes(n);
            t.setAttributes(Object.fromEntries(i.getAttributes()), n);
            t.merge(e)
        }

        function gw(t, e, n) {
            const i = e.parent;
            const o = n.parent;
            if (i == o) {
                return false
            }
            if (t.isLimit(i) || t.isLimit(o)) {
                return false
            }
            return bw(e, n, t)
        }

        function mw(t, e) {
            const n = t.getAncestors();
            const i = e.getAncestors();
            let o = 0;
            while (n[o] && n[o] == i[o]) {
                o++
            }
            return [n[o], i[o]]
        }

        function pw(t, e) {
            const n = t.checkChild(e, "$text");
            const i = t.checkChild(e, "paragraph");
            return !n && i
        }

        function bw(t, e, n) {
            const i = new Em(t, e);
            for (const t of i.getWalker()) {
                if (n.isLimit(t.item)) {
                    return false
                }
            }
            return true
        }

        function kw(t, e, n, i = {}) {
            const o = t.createElement("paragraph");
            t.model.schema.setAllowedAttributes(o, i, t);
            t.insert(o, e);
            Aw(t, n, t.createPositionAt(o, 0))
        }

        function ww(t, e) {
            const n = t.model.schema.getLimitElement(e);
            t.remove(t.createRangeIn(n));
            kw(t, t.createPositionAt(n, 0), e)
        }

        function _w(t, e) {
            const n = t.getLimitElement(e);
            if (!e.containsEntireContent(n)) {
                return false
            }
            const i = e.getFirstRange();
            if (i.start.parent == i.end.parent) {
                return false
            }
            return t.checkChild(n, "paragraph")
        }

        function Aw(t, e, n) {
            if (e instanceof $m) {
                t.setSelection(n)
            } else {
                e.setTo(n)
            }
        }

        function Cw(t, e) {
            return t.change((t => {
                const n = t.createDocumentFragment();
                const i = e.getFirstRange();
                if (!i || i.isCollapsed) {
                    return n
                }
                const o = i.start.root;
                const r = i.start.getCommonPath(i.end);
                const s = o.getNodeByPath(r);
                let a;
                if (i.start.parent == i.end.parent) {
                    a = i
                } else {
                    a = t.createRange(t.createPositionAt(s, i.start.path[r.length]), t.createPositionAt(s, i.end.path[r.length] + 1))
                }
                const l = a.end.offset - a.start.offset;
                for (const e of a.getItems({shallow: true})) {
                    if (e.is("$textProxy")) {
                        t.appendText(e.data, e.getAttributes(), n)
                    } else {
                        t.append(t.cloneElement(e, true), n)
                    }
                }
                if (a != i) {
                    const e = i._getTransformedByMove(a.start, t.createPositionAt(n, 0), l)[0];
                    const o = t.createRange(t.createPositionAt(n, 0), e.start);
                    const r = t.createRange(e.end, t.createPositionAt(n, "end"));
                    vw(r, t);
                    vw(o, t)
                }
                return n
            }))
        }

        function vw(t, e) {
            const n = [];
            Array.from(t.getItems({direction: "backward"})).map((t => e.createRangeOn(t))).filter((e => {
                const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end));
                return n
            })).forEach((t => {
                n.push(t.start.parent);
                e.remove(t)
            }));
            n.forEach((t => {
                let n = t;
                while (n.parent && n.isEmpty) {
                    const t = e.createRangeOn(n);
                    n = n.parent;
                    e.remove(t)
                }
            }))
        }

        function yw(t, e, n, i) {
            return t.change((o => {
                let r;
                if (!n) {
                    r = t.document.selection
                } else if (n instanceof zm || n instanceof $m) {
                    r = n
                } else {
                    r = o.createSelection(n, i)
                }
                if (!r.isCollapsed) {
                    t.deleteContent(r, {doNotAutoparagraph: true})
                }
                const s = new xw(t, o, r.anchor);
                const a = [];
                let l;
                if (e.is("documentFragment")) {
                    if (e.markers.size) {
                        const t = [];
                        for (const [n, i] of e.markers) {
                            const {start: e, end: o} = i;
                            const r = e.isEqual(o);
                            t.push({position: e, name: n, isCollapsed: r}, {position: o, name: n, isCollapsed: r})
                        }
                        t.sort((({position: t}, {position: e}) => t.isBefore(e) ? 1 : -1));
                        for (const {position: n, name: i, isCollapsed: r} of t) {
                            let t = null;
                            let s = null;
                            const l = n.parent === e && n.isAtStart;
                            const c = n.parent === e && n.isAtEnd;
                            if (!l && !c) {
                                t = o.createElement("$marker");
                                o.insert(t, n)
                            } else if (r) {
                                s = l ? "start" : "end"
                            }
                            a.push({name: i, element: t, collapsed: s})
                        }
                    }
                    l = e.getChildren()
                } else {
                    l = [e]
                }
                s.handleNodes(l);
                let c = s.getSelectionRange();
                if (e.is("documentFragment") && a.length) {
                    const t = c ? Mm.fromRange(c) : null;
                    const e = {};
                    for (let t = a.length - 1; t >= 0; t--) {
                        const {name: n, element: i, collapsed: r} = a[t];
                        const l = !e[n];
                        if (l) {
                            e[n] = []
                        }
                        if (i) {
                            const t = o.createPositionAt(i, "before");
                            e[n].push(t);
                            o.remove(i)
                        } else {
                            const t = s.getAffectedRange();
                            if (!t) {
                                if (r) {
                                    e[n].push(s.position)
                                }
                                continue
                            }
                            if (r) {
                                e[n].push(t[r])
                            } else {
                                e[n].push(l ? t.start : t.end)
                            }
                        }
                    }
                    for (const [t, [n, i]] of Object.entries(e)) {
                        if (n && i && n.root === i.root) {
                            o.addMarker(t, {usingOperation: true, affectsData: true, range: new Em(n, i)})
                        }
                    }
                    if (t) {
                        c = t.toRange();
                        t.detach()
                    }
                }
                if (c) {
                    if (r instanceof $m) {
                        o.setSelection(c)
                    } else {
                        r.setTo(c)
                    }
                } else {
                }
                const d = s.getAffectedRange() || t.createRange(r.anchor);
                s.destroy();
                return d
            }))
        }

        class xw {
            constructor(t, e, n) {
                this.model = t;
                this.writer = e;
                this.position = n;
                this.canMergeWith = new Set([this.position.parent]);
                this.schema = t.schema;
                this._documentFragment = e.createDocumentFragment();
                this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0);
                this._firstNode = null;
                this._lastNode = null;
                this._lastAutoParagraph = null;
                this._filterAttributesOf = [];
                this._affectedStart = null;
                this._affectedEnd = null
            }

            handleNodes(t) {
                for (const e of Array.from(t)) {
                    this._handleNode(e)
                }
                this._insertPartialFragment();
                if (this._lastAutoParagraph) {
                    this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph)
                }
                this._mergeOnRight();
                this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
                this._filterAttributesOf = []
            }

            _updateLastNodeFromAutoParagraph(t) {
                const e = this.writer.createPositionAfter(this._lastNode);
                const n = this.writer.createPositionAfter(t);
                if (n.isAfter(e)) {
                    this._lastNode = t;
                    if (this.position.parent != t || !this.position.isAtEnd) {
                        throw new P("insertcontent-invalid-insertion-position", this)
                    }
                    this.position = n;
                    this._setAffectedBoundaries(this.position)
                }
            }

            getSelectionRange() {
                if (this._nodeToSelect) {
                    return Em._createOn(this._nodeToSelect)
                }
                return this.model.schema.getNearestSelectionRange(this.position)
            }

            getAffectedRange() {
                if (!this._affectedStart) {
                    return null
                }
                return new Em(this._affectedStart, this._affectedEnd)
            }

            destroy() {
                if (this._affectedStart) {
                    this._affectedStart.detach()
                }
                if (this._affectedEnd) {
                    this._affectedEnd.detach()
                }
            }

            _handleNode(t) {
                if (this.schema.isObject(t)) {
                    this._handleObject(t);
                    return
                }
                let e = this._checkAndAutoParagraphToAllowedPosition(t);
                if (!e) {
                    e = this._checkAndSplitToAllowedPosition(t);
                    if (!e) {
                        this._handleDisallowedNode(t);
                        return
                    }
                }
                this._appendToFragment(t);
                if (!this._firstNode) {
                    this._firstNode = t
                }
                this._lastNode = t
            }

            _insertPartialFragment() {
                if (this._documentFragment.isEmpty) {
                    return
                }
                const t = Dk.fromPosition(this.position, "toNext");
                this._setAffectedBoundaries(this.position);
                if (this._documentFragment.getChild(0) == this._firstNode) {
                    this.writer.insert(this._firstNode, this.position);
                    this._mergeOnLeft();
                    this.position = t.toPosition()
                }
                if (!this._documentFragment.isEmpty) {
                    this.writer.insert(this._documentFragment, this.position)
                }
                this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
                this.position = t.toPosition();
                t.detach()
            }

            _handleObject(t) {
                if (this._checkAndSplitToAllowedPosition(t)) {
                    this._appendToFragment(t)
                } else {
                    this._tryAutoparagraphing(t)
                }
            }

            _handleDisallowedNode(t) {
                if (t.is("element")) {
                    this.handleNodes(t.getChildren())
                } else {
                    this._tryAutoparagraphing(t)
                }
            }

            _appendToFragment(t) {
                if (!this.schema.checkChild(this.position, t)) {
                    throw new P("insertcontent-wrong-position", this, {node: t, position: this.position})
                }
                this.writer.insert(t, this._documentFragmentPosition);
                this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize);
                if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
                    this._nodeToSelect = t
                } else {
                    this._nodeToSelect = null
                }
                this._filterAttributesOf.push(t)
            }

            _setAffectedBoundaries(t) {
                if (!this._affectedStart) {
                    this._affectedStart = Dk.fromPosition(t, "toPrevious")
                }
                if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
                    if (this._affectedEnd) {
                        this._affectedEnd.detach()
                    }
                    this._affectedEnd = Dk.fromPosition(t, "toNext")
                }
            }

            _mergeOnLeft() {
                const t = this._firstNode;
                if (!(t instanceof mm)) {
                    return
                }
                if (!this._canMergeLeft(t)) {
                    return
                }
                const e = Dk._createBefore(t);
                e.stickiness = "toNext";
                const n = Dk.fromPosition(this.position, "toNext");
                if (this._affectedStart.isEqual(e)) {
                    this._affectedStart.detach();
                    this._affectedStart = Dk._createAt(e.nodeBefore, "end", "toPrevious")
                }
                if (this._firstNode === this._lastNode) {
                    this._firstNode = e.nodeBefore;
                    this._lastNode = e.nodeBefore
                }
                this.writer.merge(e);
                if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
                    this._affectedEnd.detach();
                    this._affectedEnd = Dk._createAt(e.nodeBefore, "end", "toNext")
                }
                this.position = n.toPosition();
                n.detach();
                this._filterAttributesOf.push(this.position.parent);
                e.detach()
            }

            _mergeOnRight() {
                const t = this._lastNode;
                if (!(t instanceof mm)) {
                    return
                }
                if (!this._canMergeRight(t)) {
                    return
                }
                const e = Dk._createAfter(t);
                e.stickiness = "toNext";
                if (!this.position.isEqual(e)) {
                    throw new P("insertcontent-invalid-insertion-position", this)
                }
                this.position = wm._createAt(e.nodeBefore, "end");
                const n = Dk.fromPosition(this.position, "toPrevious");
                if (this._affectedEnd.isEqual(e)) {
                    this._affectedEnd.detach();
                    this._affectedEnd = Dk._createAt(e.nodeBefore, "end", "toNext")
                }
                if (this._firstNode === this._lastNode) {
                    this._firstNode = e.nodeBefore;
                    this._lastNode = e.nodeBefore
                }
                this.writer.merge(e);
                if (e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
                    this._affectedStart.detach();
                    this._affectedStart = Dk._createAt(e.nodeBefore, 0, "toPrevious")
                }
                this.position = n.toPosition();
                n.detach();
                this._filterAttributesOf.push(this.position.parent);
                e.detach()
            }

            _canMergeLeft(t) {
                const e = t.previousSibling;
                return e instanceof mm && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t)
            }

            _canMergeRight(t) {
                const e = t.nextSibling;
                return e instanceof mm && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e)
            }

            _tryAutoparagraphing(t) {
                const e = this.writer.createElement("paragraph");
                if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) {
                    e._appendChild(t);
                    this._handleNode(e)
                }
            }

            _checkAndAutoParagraphToAllowedPosition(t) {
                if (this.schema.checkChild(this.position.parent, t)) {
                    return true
                }
                if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t)) {
                    return false
                }
                this._insertPartialFragment();
                const e = this.writer.createElement("paragraph");
                this.writer.insert(e, this.position);
                this._setAffectedBoundaries(this.position);
                this._lastAutoParagraph = e;
                this.position = this.writer.createPositionAt(e, 0);
                return true
            }

            _checkAndSplitToAllowedPosition(t) {
                const e = this._getAllowedIn(this.position.parent, t);
                if (!e) {
                    return false
                }
                if (e != this.position.parent) {
                    this._insertPartialFragment()
                }
                while (e != this.position.parent) {
                    if (this.position.isAtStart) {
                        const t = this.position.parent;
                        this.position = this.writer.createPositionBefore(t);
                        if (t.isEmpty && t.parent === e) {
                            this.writer.remove(t)
                        }
                    } else if (this.position.isAtEnd) {
                        this.position = this.writer.createPositionAfter(this.position.parent)
                    } else {
                        const t = this.writer.createPositionAfter(this.position.parent);
                        this._setAffectedBoundaries(this.position);
                        this.writer.split(this.position);
                        this.position = t;
                        this.canMergeWith.add(this.position.nodeAfter)
                    }
                }
                return true
            }

            _getAllowedIn(t, e) {
                if (this.schema.checkChild(t, e)) {
                    return t
                }
                if (this.schema.isLimit(t)) {
                    return null
                }
                return this._getAllowedIn(t.parent, e)
            }
        }

        function Ew(t, e, n = "auto") {
            const i = t.getSelectedElement();
            if (i && e.schema.isObject(i) && !e.schema.isInline(i)) {
                if (n == "before" || n == "after") {
                    return e.createRange(e.createPositionAt(i, n))
                }
                return e.createRangeOn(i)
            }
            const o = sc(t.getSelectedBlocks());
            if (!o) {
                return e.createRange(t.focus)
            }
            if (o.isEmpty) {
                return e.createRange(e.createPositionAt(o, 0))
            }
            const r = e.createPositionAfter(o);
            if (t.focus.isTouching(r)) {
                return e.createRange(r)
            }
            return e.createRange(e.createPositionBefore(o))
        }

        function Sw(t, e, n, i, o = {}) {
            if (!t.schema.isObject(e)) {
                throw new P("insertobject-element-not-an-object", t, {object: e})
            }
            let r;
            if (!n) {
                r = t.document.selection
            } else if (n instanceof zm || n instanceof $m) {
                r = n
            } else {
                r = t.createSelection(n, i)
            }
            let s = r;
            if (o.findOptimalPosition && t.schema.isBlock(e)) {
                s = t.createSelection(Ew(r, t, o.findOptimalPosition))
            }
            const a = sc(r.getSelectedBlocks());
            const l = {};
            if (a) {
                Object.assign(l, t.schema.getAttributesWithProperty(a, "copyOnReplace", true))
            }
            return t.change((n => {
                if (!s.isCollapsed) {
                    t.deleteContent(s, {doNotAutoparagraph: true})
                }
                let i = e;
                const r = s.anchor.parent;
                if (!t.schema.checkChild(r, e) && t.schema.checkChild(r, "paragraph") && t.schema.checkChild("paragraph", e)) {
                    i = n.createElement("paragraph");
                    n.insert(e, i)
                }
                t.schema.setAllowedAttributes(i, l, n);
                const a = t.insertContent(i, s);
                if (a.isCollapsed) {
                    return a
                }
                if (o.setSelection) {
                    Dw(n, e, o.setSelection, l)
                }
                return a
            }))
        }

        function Dw(t, e, n, i) {
            const o = t.model;
            if (n == "on") {
                t.setSelection(e, "on");
                return
            }
            if (n != "after") {
                throw new P("insertobject-invalid-place-parameter-value", o)
            }
            let r = e.nextSibling;
            if (o.schema.isInline(e)) {
                t.setSelection(e, "after");
                return
            }
            const s = r && o.schema.checkChild(r, "$text");
            if (!s && o.schema.checkChild(e.parent, "paragraph")) {
                r = t.createElement("paragraph");
                o.schema.setAllowedAttributes(r, i, t);
                o.insertContent(r, t.createPositionAfter(e))
            }
            if (r) {
                t.setSelection(r, 0)
            }
        }

        const Tw = ' ,.?!:;"-()';

        function Bw(t, e, n = {}) {
            const i = t.schema;
            const o = n.direction != "backward";
            const r = n.unit ? n.unit : "character";
            const s = !!n.treatEmojiAsSingleUnit;
            const a = e.focus;
            const l = new bm({boundaries: zw(a, o), singleCharacters: true, direction: o ? "forward" : "backward"});
            const c = {walker: l, schema: i, isForward: o, unit: r, treatEmojiAsSingleUnit: s};
            let d;
            while (d = l.next()) {
                if (d.done) {
                    return
                }
                const n = Pw(c, d.value);
                if (n) {
                    if (e instanceof $m) {
                        t.change((t => {
                            t.setSelectionFocus(n)
                        }))
                    } else {
                        e.setFocus(n)
                    }
                    return
                }
            }
        }

        function Pw(t, e) {
            const {isForward: n, walker: i, unit: o, schema: r, treatEmojiAsSingleUnit: s} = t;
            const {type: a, item: l, nextPosition: c} = e;
            if (a == "text") {
                if (t.unit === "word") {
                    return Rw(i, n)
                }
                return Iw(i, o, s)
            }
            if (a == (n ? "elementStart" : "elementEnd")) {
                if (r.isSelectable(l)) {
                    return wm._createAt(l, n ? "after" : "before")
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            } else {
                if (r.isLimit(l)) {
                    i.skip((() => true));
                    return
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            }
        }

        function Iw(t, e, n) {
            const i = t.position.textNode;
            if (i) {
                const o = i.data;
                let r = t.position.offset - i.startOffset;
                while (pc(o, r) || e == "character" && bc(o, r) || n && wc(o, r)) {
                    t.next();
                    r = t.position.offset - i.startOffset
                }
            }
            return t.position
        }

        function Rw(t, e) {
            let n = t.position.textNode;
            if (!n) {
                n = e ? t.position.nodeAfter : t.position.nodeBefore
            }
            while (n && n.is("$text")) {
                const i = t.position.offset - n.startOffset;
                if (Fw(n, i, e)) {
                    n = e ? t.position.nodeAfter : t.position.nodeBefore
                } else if (Vw(n.data, i, e)) {
                    break
                } else {
                    t.next()
                }
            }
            return t.position
        }

        function zw(t, e) {
            const n = t.root;
            const i = wm._createAt(n, e ? "end" : 0);
            if (e) {
                return new Em(t, i)
            } else {
                return new Em(i, t)
            }
        }

        function Vw(t, e, n) {
            const i = e + (n ? 0 : -1);
            return Tw.includes(t.charAt(i))
        }

        function Fw(t, e, n) {
            return e === (n ? t.offsetSize : 0)
        }

        class Lw extends (dt()) {
            constructor() {
                super();
                this.markers = new Hk;
                this.document = new Nk(this);
                this.schema = new bb;
                this._pendingChanges = [];
                this._currentWriter = null;
                ["insertContent", "insertObject", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t)));
                this.on("applyOperation", ((t, e) => {
                    const n = e[0];
                    n._validate()
                }), {priority: "highest"});
                this.schema.register("$root", {isLimit: true});
                this.schema.register("$container", {allowIn: ["$root", "$container"]});
                this.schema.register("$block", {allowIn: ["$root", "$container"], isBlock: true});
                this.schema.register("$blockObject", {allowWhere: "$block", isBlock: true, isObject: true});
                this.schema.register("$inlineObject", {
                    allowWhere: "$text",
                    allowAttributesOf: "$text",
                    isInline: true,
                    isObject: true
                });
                this.schema.register("$text", {allowIn: "$block", isInline: true, isContent: true});
                this.schema.register("$clipboardHolder", {
                    allowContentOf: "$root",
                    allowChildren: "$text",
                    isLimit: true
                });
                this.schema.register("$documentFragment", {
                    allowContentOf: "$root",
                    allowChildren: "$text",
                    isLimit: true
                });
                this.schema.register("$marker");
                this.schema.addChildCheck(((t, e) => {
                    if (e.name === "$marker") {
                        return true
                    }
                }));
                Qk(this);
                this.document.registerPostFixer(jp)
            }

            change(t) {
                try {
                    if (this._pendingChanges.length === 0) {
                        this._pendingChanges.push({batch: new Pk, callback: t});
                        return this._runPendingChanges()[0]
                    } else {
                        return t(this._currentWriter)
                    }
                } catch (t) {
                    P.rethrowUnexpectedError(t, this)
                }
            }

            enqueueChange(t, e) {
                try {
                    if (!t) {
                        t = new Pk
                    } else if (typeof t === "function") {
                        e = t;
                        t = new Pk
                    } else if (!(t instanceof Pk)) {
                        t = new Pk(t)
                    }
                    this._pendingChanges.push({batch: t, callback: e});
                    if (this._pendingChanges.length == 1) {
                        this._runPendingChanges()
                    }
                } catch (t) {
                    P.rethrowUnexpectedError(t, this)
                }
            }

            applyOperation(t) {
                t._execute()
            }

            insertContent(t, e, n) {
                return yw(this, t, e, n)
            }

            insertObject(t, e, n, i) {
                return Sw(this, t, e, n, i)
            }

            deleteContent(t, e) {
                aw(this, t, e)
            }

            modifySelection(t, e) {
                Bw(this, t, e)
            }

            getSelectedContent(t) {
                return Cw(this, t)
            }

            hasContent(t, e = {}) {
                const n = t instanceof Em ? t : Em._createIn(t);
                if (n.isCollapsed) {
                    return false
                }
                const {ignoreWhitespaces: i = false, ignoreMarkers: o = false} = e;
                if (!o) {
                    for (const t of this.markers.getMarkersIntersectingRange(n)) {
                        if (t.affectsData) {
                            return true
                        }
                    }
                }
                for (const t of n.getItems()) {
                    if (this.schema.isContent(t)) {
                        if (t.is("$textProxy")) {
                            if (!i) {
                                return true
                            } else if (t.data.search(/\S/) !== -1) {
                                return true
                            }
                        } else {
                            return true
                        }
                    }
                }
                return false
            }

            createPositionFromPath(t, e, n) {
                return new wm(t, e, n)
            }

            createPositionAt(t, e) {
                return wm._createAt(t, e)
            }

            createPositionAfter(t) {
                return wm._createAfter(t)
            }

            createPositionBefore(t) {
                return wm._createBefore(t)
            }

            createRange(t, e) {
                return new Em(t, e)
            }

            createRangeIn(t) {
                return Em._createIn(t)
            }

            createRangeOn(t) {
                return Em._createOn(t)
            }

            createSelection(...t) {
                return new zm(...t)
            }

            createBatch(t) {
                return new Pk(t)
            }

            createOperationFromJSON(t) {
                return gk.fromJSON(t, this.document)
            }

            destroy() {
                this.document.destroy();
                this.stopListening()
            }

            _runPendingChanges() {
                const t = [];
                this.fire("_beforeChanges");
                try {
                    while (this._pendingChanges.length) {
                        const e = this._pendingChanges[0].batch;
                        this._currentWriter = new Uk(this, e);
                        const n = this._pendingChanges[0].callback(this._currentWriter);
                        t.push(n);
                        this.document._handleChangeBlock(this._currentWriter);
                        this._pendingChanges.shift();
                        this._currentWriter = null
                    }
                } finally {
                    this._pendingChanges.length = 0;
                    this._currentWriter = null;
                    this.fire("_afterChanges")
                }
                return t
            }
        }

        class Ow extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = "click"
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        class Nw extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"]
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        class Mw {
            constructor(t) {
                this.document = t
            }

            createDocumentFragment(t) {
                return new Ph(this.document, t)
            }

            createElement(t, e, n) {
                return new Zu(this.document, t, e, n)
            }

            createText(t) {
                return new Zc(this.document, t)
            }

            clone(t, e = false) {
                return t._clone(e)
            }

            appendChild(t, e) {
                return e._appendChild(t)
            }

            insertChild(t, e, n) {
                return n._insertChild(t, e)
            }

            removeChildren(t, e, n) {
                return n._removeChildren(t, e)
            }

            remove(t) {
                const e = t.parent;
                if (e) {
                    return this.removeChildren(e.getChildIndex(t), 1, e)
                }
                return []
            }

            replace(t, e) {
                const n = t.parent;
                if (n) {
                    const i = n.getChildIndex(t);
                    this.removeChildren(i, 1, n);
                    this.insertChild(i, e, n);
                    return true
                }
                return false
            }

            unwrapElement(t) {
                const e = t.parent;
                if (e) {
                    const n = e.getChildIndex(t);
                    this.remove(t);
                    this.insertChild(n, t.getChildren(), e)
                }
            }

            rename(t, e) {
                const n = new Zu(this.document, t, e.getAttributes(), e.getChildren());
                return this.replace(e, n) ? n : null
            }

            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }

            removeAttribute(t, e) {
                e._removeAttribute(t)
            }

            addClass(t, e) {
                e._addClass(t)
            }

            removeClass(t, e) {
                e._removeClass(t)
            }

            setStyle(t, e, n) {
                if (he(t) && n === undefined) {
                    e._setStyle(t)
                } else {
                    n._setStyle(t, e)
                }
            }

            removeStyle(t, e) {
                e._removeStyle(t)
            }

            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }

            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }

            createPositionAt(t, e) {
                return rh._createAt(t, e)
            }

            createPositionAfter(t) {
                return rh._createAfter(t)
            }

            createPositionBefore(t) {
                return rh._createBefore(t)
            }

            createRange(t, e) {
                return new sh(t, e)
            }

            createRangeOn(t) {
                return sh._createOn(t)
            }

            createRangeIn(t) {
                return sh._createIn(t)
            }

            createSelection(...t) {
                return new lh(...t)
            }
        }

        const Hw = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
        const Ww = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
        const qw = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const jw = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
        const $w = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const Uw = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);

        function Gw(t) {
            if (t.startsWith("#")) {
                return Hw.test(t)
            }
            if (t.startsWith("rgb")) {
                return Ww.test(t) || qw.test(t)
            }
            if (t.startsWith("hsl")) {
                return jw.test(t) || $w.test(t)
            }
            return Uw.has(t.toLowerCase())
        }

        const Kw = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];

        function Zw(t) {
            return Kw.includes(t)
        }

        const Jw = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;

        function Yw(t) {
            return Jw.test(t)
        }

        const Qw = /^[+-]?[0-9]*([.][0-9]+)?%$/;

        function Xw(t) {
            return Qw.test(t)
        }

        const t_ = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];

        function e_(t) {
            return t_.includes(t)
        }

        const n_ = ["center", "top", "bottom", "left", "right"];

        function i_(t) {
            return n_.includes(t)
        }

        const o_ = ["fixed", "scroll", "local"];

        function r_(t) {
            return o_.includes(t)
        }

        const s_ = /^url\(/;

        function a_(t) {
            return s_.test(t)
        }

        function l_(t = "") {
            if (t === "") {
                return {top: undefined, right: undefined, bottom: undefined, left: undefined}
            }
            const e = h_(t);
            const n = e[0];
            const i = e[2] || n;
            const o = e[1] || n;
            const r = e[3] || o;
            return {top: n, bottom: i, right: o, left: r}
        }

        function c_(t) {
            return e => {
                const {top: n, right: i, bottom: o, left: r} = e;
                const s = [];
                if (![n, i, r, o].every((t => !!t))) {
                    if (n) {
                        s.push([t + "-top", n])
                    }
                    if (i) {
                        s.push([t + "-right", i])
                    }
                    if (o) {
                        s.push([t + "-bottom", o])
                    }
                    if (r) {
                        s.push([t + "-left", r])
                    }
                } else {
                    s.push([t, d_(e)])
                }
                return s
            }
        }

        function d_({top: t, right: e, bottom: n, left: i}) {
            const o = [];
            if (i !== e) {
                o.push(t, e, n, i)
            } else if (n !== t) {
                o.push(t, e, n)
            } else if (e !== t) {
                o.push(t, e)
            } else {
                o.push(t)
            }
            return o.join(" ")
        }

        function u_(t) {
            return e => ({path: t, value: l_(e)})
        }

        function h_(t) {
            return t.replace(/, /g, ",").split(" ").map((t => t.replace(/,/g, ", ")))
        }

        function f_(t) {
            t.setNormalizer("background", g_());
            t.setNormalizer("background-color", m_());
            t.setReducer("background", p_());
            t.setStyleRelation("background", ["background-color"])
        }

        function g_() {
            return t => {
                const e = {};
                const n = h_(t);
                for (const t of n) {
                    if (e_(t)) {
                        e.repeat = e.repeat || [];
                        e.repeat.push(t)
                    } else if (i_(t)) {
                        e.position = e.position || [];
                        e.position.push(t)
                    } else if (r_(t)) {
                        e.attachment = t
                    } else if (Gw(t)) {
                        e.color = t
                    } else if (a_(t)) {
                        e.image = t
                    }
                }
                return {path: "background", value: e}
            }
        }

        function m_() {
            return t => ({path: "background.color", value: t})
        }

        function p_() {
            return t => {
                const e = [];
                e.push(["background-color", t.color]);
                return e
            }
        }

        function b_(t) {
            t.setNormalizer("border", k_());
            t.setNormalizer("border-top", w_("top"));
            t.setNormalizer("border-right", w_("right"));
            t.setNormalizer("border-bottom", w_("bottom"));
            t.setNormalizer("border-left", w_("left"));
            t.setNormalizer("border-color", __("color"));
            t.setNormalizer("border-width", __("width"));
            t.setNormalizer("border-style", __("style"));
            t.setNormalizer("border-top-color", C_("color", "top"));
            t.setNormalizer("border-top-style", C_("style", "top"));
            t.setNormalizer("border-top-width", C_("width", "top"));
            t.setNormalizer("border-right-color", C_("color", "right"));
            t.setNormalizer("border-right-style", C_("style", "right"));
            t.setNormalizer("border-right-width", C_("width", "right"));
            t.setNormalizer("border-bottom-color", C_("color", "bottom"));
            t.setNormalizer("border-bottom-style", C_("style", "bottom"));
            t.setNormalizer("border-bottom-width", C_("width", "bottom"));
            t.setNormalizer("border-left-color", C_("color", "left"));
            t.setNormalizer("border-left-style", C_("style", "left"));
            t.setNormalizer("border-left-width", C_("width", "left"));
            t.setExtractor("border-top", v_("top"));
            t.setExtractor("border-right", v_("right"));
            t.setExtractor("border-bottom", v_("bottom"));
            t.setExtractor("border-left", v_("left"));
            t.setExtractor("border-top-color", "border.color.top");
            t.setExtractor("border-right-color", "border.color.right");
            t.setExtractor("border-bottom-color", "border.color.bottom");
            t.setExtractor("border-left-color", "border.color.left");
            t.setExtractor("border-top-width", "border.width.top");
            t.setExtractor("border-right-width", "border.width.right");
            t.setExtractor("border-bottom-width", "border.width.bottom");
            t.setExtractor("border-left-width", "border.width.left");
            t.setExtractor("border-top-style", "border.style.top");
            t.setExtractor("border-right-style", "border.style.right");
            t.setExtractor("border-bottom-style", "border.style.bottom");
            t.setExtractor("border-left-style", "border.style.left");
            t.setReducer("border-color", c_("border-color"));
            t.setReducer("border-style", c_("border-style"));
            t.setReducer("border-width", c_("border-width"));
            t.setReducer("border-top", S_("top"));
            t.setReducer("border-right", S_("right"));
            t.setReducer("border-bottom", S_("bottom"));
            t.setReducer("border-left", S_("left"));
            t.setReducer("border", E_());
            t.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
            t.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]);
            t.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]);
            t.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
            t.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]);
            t.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]);
            t.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]);
            t.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"])
        }

        function k_() {
            return t => {
                const {color: e, style: n, width: i} = x_(t);
                return {path: "border", value: {color: l_(e), style: l_(n), width: l_(i)}}
            }
        }

        function w_(t) {
            return e => {
                const {color: n, style: i, width: o} = x_(e);
                const r = {};
                if (n !== undefined) {
                    r.color = {[t]: n}
                }
                if (i !== undefined) {
                    r.style = {[t]: i}
                }
                if (o !== undefined) {
                    r.width = {[t]: o}
                }
                return {path: "border", value: r}
            }
        }

        function __(t) {
            return e => ({path: "border", value: A_(e, t)})
        }

        function A_(t, e) {
            return {[e]: l_(t)}
        }

        function C_(t, e) {
            return n => ({path: "border", value: {[t]: {[e]: n}}})
        }

        function v_(t) {
            return (e, n) => {
                if (n.border) {
                    return y_(n.border, t)
                }
            }
        }

        function y_(t, e) {
            const n = {};
            if (t.width && t.width[e]) {
                n.width = t.width[e]
            }
            if (t.style && t.style[e]) {
                n.style = t.style[e]
            }
            if (t.color && t.color[e]) {
                n.color = t.color[e]
            }
            return n
        }

        function x_(t) {
            const e = {};
            const n = h_(t);
            for (const t of n) {
                if (Yw(t) || /thin|medium|thick/.test(t)) {
                    e.width = t
                } else if (Zw(t)) {
                    e.style = t
                } else {
                    e.color = t
                }
            }
            return e
        }

        function E_() {
            return e => {
                const n = y_(e, "top");
                const i = y_(e, "right");
                const o = y_(e, "bottom");
                const r = y_(e, "left");
                const s = [n, i, o, r];
                const a = {width: t(s, "width"), style: t(s, "style"), color: t(s, "color")};
                const l = D_(a, "all");
                if (l.length) {
                    return l
                }
                const c = Object.entries(a).reduce(((t, [e, n]) => {
                    if (n) {
                        t.push([`border-${e}`, n]);
                        s.forEach((t => delete t[e]))
                    }
                    return t
                }), []);
                return [...c, ...D_(n, "top"), ...D_(i, "right"), ...D_(o, "bottom"), ...D_(r, "left")]
            };

            function t(t, e) {
                return t.map((t => t[e])).reduce(((t, e) => t == e ? t : null))
            }
        }

        function S_(t) {
            return e => D_(e, t)
        }

        function D_(t, e) {
            const n = [];
            if (t && t.width) {
                n.push("width")
            }
            if (t && t.style) {
                n.push("style")
            }
            if (t && t.color) {
                n.push("color")
            }
            if (n.length == 3) {
                const i = n.map((e => t[e])).join(" ");
                return [e == "all" ? ["border", i] : [`border-${e}`, i]]
            }
            if (e == "all") {
                return []
            }
            return n.map((n => [`border-${e}-${n}`, t[n]]))
        }

        function T_(t) {
            t.setNormalizer("margin", u_("margin"));
            t.setNormalizer("margin-top", (t => ({path: "margin.top", value: t})));
            t.setNormalizer("margin-right", (t => ({path: "margin.right", value: t})));
            t.setNormalizer("margin-bottom", (t => ({path: "margin.bottom", value: t})));
            t.setNormalizer("margin-left", (t => ({path: "margin.left", value: t})));
            t.setReducer("margin", c_("margin"));
            t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"])
        }

        function B_(t) {
            t.setNormalizer("padding", u_("padding"));
            t.setNormalizer("padding-top", (t => ({path: "padding.top", value: t})));
            t.setNormalizer("padding-right", (t => ({path: "padding.right", value: t})));
            t.setNormalizer("padding-bottom", (t => ({path: "padding.bottom", value: t})));
            t.setNormalizer("padding-left", (t => ({path: "padding.left", value: t})));
            t.setReducer("padding", c_("padding"));
            t.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"])
        }

        class P_ {
            constructor() {
                this._commands = new Map
            }

            add(t, e) {
                this._commands.set(t, e)
            }

            get(t) {
                return this._commands.get(t)
            }

            execute(t, ...e) {
                const n = this.get(t);
                if (!n) {
                    throw new P("commandcollection-command-not-found", this, {commandName: t})
                }
                return n.execute(...e)
            }

            * names() {
                yield* this._commands.keys()
            }

            * commands() {
                yield* this._commands.values()
            }

            [Symbol.iterator]() {
                return this._commands[Symbol.iterator]()
            }

            destroy() {
                for (const t of this.commands()) {
                    t.destroy()
                }
            }
        }

        class I_ extends lc {
            constructor(t) {
                super();
                this.editor = t
            }

            set(t, e, n = {}) {
                if (typeof e == "string") {
                    const t = e;
                    e = (e, n) => {
                        this.editor.execute(t);
                        n()
                    }
                }
                super.set(t, e, n)
            }
        }

        class R_ extends (dt()) {
            constructor(t = {}) {
                super();
                const e = this.constructor;
                const n = t.language || e.defaultConfig && e.defaultConfig.language;
                this._context = t.context || new Sc({language: n});
                this._context._addEditor(this, !t.context);
                const i = Array.from(e.builtinPlugins || []);
                this.config = new Wa(t, e.defaultConfig);
                this.config.define("plugins", i);
                this.config.define(this._context._getEditorConfig());
                this.plugins = new Ec(this, i, this._context.plugins);
                this.locale = this._context.locale;
                this.t = this.locale.t;
                this._readOnlyLocks = new Set;
                this.commands = new P_;
                this.set("state", "initializing");
                this.once("ready", (() => this.state = "ready"), {priority: "high"});
                this.once("destroy", (() => this.state = "destroyed"), {priority: "high"});
                this.model = new Lw;
                const o = new $u;
                this.data = new Wb(this.model, o);
                this.editing = new fb(this.model, o);
                this.editing.view.document.bind("isReadOnly").to(this);
                this.conversion = new jb([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
                this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
                this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
                this.keystrokes = new I_(this);
                this.keystrokes.listenTo(this.editing.view.document)
            }

            get isReadOnly() {
                return this._readOnlyLocks.size > 0
            }

            set isReadOnly(t) {
                throw new P("editor-isreadonly-has-no-setter")
            }

            enableReadOnlyMode(t) {
                if (typeof t !== "string" && typeof t !== "symbol") {
                    throw new P("editor-read-only-lock-id-invalid", null, {lockId: t})
                }
                if (this._readOnlyLocks.has(t)) {
                    return
                }
                this._readOnlyLocks.add(t);
                if (this._readOnlyLocks.size === 1) {
                    this.fire("change:isReadOnly", "isReadOnly", true, false)
                }
            }

            disableReadOnlyMode(t) {
                if (typeof t !== "string" && typeof t !== "symbol") {
                    throw new P("editor-read-only-lock-id-invalid", null, {lockId: t})
                }
                if (!this._readOnlyLocks.has(t)) {
                    return
                }
                this._readOnlyLocks.delete(t);
                if (this._readOnlyLocks.size === 0) {
                    this.fire("change:isReadOnly", "isReadOnly", false, true)
                }
            }

            initPlugins() {
                const t = this.config;
                const e = t.get("plugins");
                const n = t.get("removePlugins") || [];
                const i = t.get("extraPlugins") || [];
                const o = t.get("substitutePlugins") || [];
                return this.plugins.init(e.concat(i), n, o)
            }

            destroy() {
                let t = Promise.resolve();
                if (this.state == "initializing") {
                    t = new Promise((t => this.once("ready", t)))
                }
                return t.then((() => {
                    this.fire("destroy");
                    this.stopListening();
                    this.commands.destroy()
                })).then((() => this.plugins.destroy())).then((() => {
                    this.model.destroy();
                    this.data.destroy();
                    this.editing.destroy();
                    this.keystrokes.destroy()
                })).then((() => this._context._removeEditor(this)))
            }

            execute(t, ...e) {
                try {
                    return this.commands.execute(t, ...e)
                } catch (t) {
                    P.rethrowUnexpectedError(t, this)
                }
            }

            focus() {
                this.editing.view.focus()
            }
        }

        class z_ {
            constructor(t) {
                this.editor = t;
                this._components = new Map
            }

            * names() {
                for (const t of this._components.values()) {
                    yield t.originalName
                }
            }

            add(t, e) {
                this._components.set(V_(t), {callback: e, originalName: t})
            }

            create(t) {
                if (!this.has(t)) {
                    throw new P("componentfactory-item-missing", this, {name: t})
                }
                return this._components.get(V_(t)).callback(this.editor.locale)
            }

            has(t) {
                return this._components.has(V_(t))
            }
        }

        function V_(t) {
            return String(t).toLowerCase()
        }

        class F_ extends rc {
            constructor(t = []) {
                super(t, {idProperty: "viewUid"});
                this.on("add", ((t, e, n) => {
                    this._renderViewIntoCollectionParent(e, n)
                }));
                this.on("remove", ((t, e) => {
                    if (e.element && this._parentElement) {
                        e.element.remove()
                    }
                }));
                this._parentElement = null
            }

            destroy() {
                this.map((t => t.destroy()))
            }

            setParent(t) {
                this._parentElement = t;
                for (const t of this) {
                    this._renderViewIntoCollectionParent(t)
                }
            }

            delegate(...t) {
                if (!t.length || !L_(t)) {
                    throw new P("ui-viewcollection-delegate-wrong-events", this)
                }
                return {
                    to: e => {
                        for (const n of this) {
                            for (const i of t) {
                                n.delegate(i).to(e)
                            }
                        }
                        this.on("add", ((n, i) => {
                            for (const n of t) {
                                i.delegate(n).to(e)
                            }
                        }));
                        this.on("remove", ((n, i) => {
                            for (const n of t) {
                                i.stopDelegating(n, e)
                            }
                        }))
                    }
                }
            }

            _renderViewIntoCollectionParent(t, e) {
                if (!t.isRendered) {
                    t.render()
                }
                if (t.element && this._parentElement) {
                    this._parentElement.insertBefore(t.element, this._parentElement.children[e])
                }
            }
        }

        function L_(t) {
            return t.every((t => typeof t == "string"))
        }

        const O_ = "http://www.w3.org/1999/xhtml";

        class N_ extends (j()) {
            constructor(t) {
                super();
                Object.assign(this, J_(Z_(t)));
                this._isRendered = false;
                this._revertData = null
            }

            render() {
                const t = this._renderNode({intoFragment: true});
                this._isRendered = true;
                return t
            }

            apply(t) {
                this._revertData = dA();
                this._renderNode({node: t, intoFragment: false, isApplying: true, revertData: this._revertData});
                return t
            }

            revert(t) {
                if (!this._revertData) {
                    throw new P("ui-template-revert-not-applied", [this, t])
                }
                this._revertTemplateFromNode(t, this._revertData)
            }

            * getViews() {
                function* t(e) {
                    if (e.children) {
                        for (const n of e.children) {
                            if (sA(n)) {
                                yield n
                            } else if (aA(n)) {
                                yield* t(n)
                            }
                        }
                    }
                }

                yield* t(this)
            }

            static bind(t, e) {
                return {
                    to(n, i) {
                        return new H_({eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: i})
                    }, if(n, i, o) {
                        return new W_({observable: t, emitter: e, attribute: n, valueIfTrue: i, callback: o})
                    }
                }
            }

            static extend(t, e) {
                if (t._isRendered) {
                    throw new P("template-extend-render", [this, t])
                }
                oA(t, J_(Z_(e)))
            }

            _renderNode(t) {
                let e;
                if (t.node) {
                    e = this.tag && this.text
                } else {
                    e = this.tag ? this.text : !this.text
                }
                if (e) {
                    throw new P("ui-template-wrong-syntax", this)
                }
                if (this.text) {
                    return this._renderText(t)
                } else {
                    return this._renderElement(t)
                }
            }

            _renderElement(t) {
                let e = t.node;
                if (!e) {
                    e = t.node = document.createElementNS(this.ns || O_, this.tag)
                }
                this._renderAttributes(t);
                this._renderElementChildren(t);
                this._setUpListeners(t);
                return e
            }

            _renderText(t) {
                let e = t.node;
                if (e) {
                    t.revertData.text = e.textContent
                } else {
                    e = t.node = document.createTextNode("")
                }
                if (q_(this.text)) {
                    this._bindToObservable({schema: this.text, updater: U_(e), data: t})
                } else {
                    e.textContent = this.text.join("")
                }
                return e
            }

            _renderAttributes(t) {
                if (!this.attributes) {
                    return
                }
                const e = t.node;
                const n = t.revertData;
                for (const i in this.attributes) {
                    const o = e.getAttribute(i);
                    const r = this.attributes[i];
                    if (n) {
                        n.attributes[i] = o
                    }
                    const s = cA(r) ? r[0].ns : null;
                    if (q_(r)) {
                        const a = cA(r) ? r[0].value : r;
                        if (n && uA(i)) {
                            a.unshift(o)
                        }
                        this._bindToObservable({schema: a, updater: G_(e, i, s), data: t})
                    } else if (i == "style" && typeof r[0] !== "string") {
                        this._renderStyleAttribute(r[0], t)
                    } else {
                        if (n && o && uA(i)) {
                            r.unshift(o)
                        }
                        const t = r.map((t => t ? t.value || t : t)).reduce(((t, e) => t.concat(e)), []).reduce(nA, "");
                        if (!rA(t)) {
                            e.setAttributeNS(s, i, t)
                        }
                    }
                }
            }

            _renderStyleAttribute(t, e) {
                const n = e.node;
                for (const i in t) {
                    const o = t[i];
                    if (q_(o)) {
                        this._bindToObservable({schema: [o], updater: K_(n, i), data: e})
                    } else {
                        n.style[i] = o
                    }
                }
            }

            _renderElementChildren(t) {
                const e = t.node;
                const n = t.intoFragment ? document.createDocumentFragment() : e;
                const i = t.isApplying;
                let o = 0;
                for (const r of this.children) {
                    if (lA(r)) {
                        if (!i) {
                            r.setParent(e);
                            for (const t of r) {
                                n.appendChild(t.element)
                            }
                        }
                    } else if (sA(r)) {
                        if (!i) {
                            if (!r.isRendered) {
                                r.render()
                            }
                            n.appendChild(r.element)
                        }
                    } else if ($a(r)) {
                        n.appendChild(r)
                    } else {
                        if (i) {
                            const e = t.revertData;
                            const i = dA();
                            e.children.push(i);
                            r._renderNode({
                                intoFragment: false,
                                node: n.childNodes[o++],
                                isApplying: true,
                                revertData: i
                            })
                        } else {
                            n.appendChild(r.render())
                        }
                    }
                }
                if (t.intoFragment) {
                    e.appendChild(n)
                }
            }

            _setUpListeners(t) {
                if (!this.eventListeners) {
                    return
                }
                for (const e in this.eventListeners) {
                    const n = this.eventListeners[e].map((n => {
                        const [i, o] = e.split("@");
                        return n.activateDomEventListener(i, o, t)
                    }));
                    if (t.revertData) {
                        t.revertData.bindings.push(n)
                    }
                }
            }

            _bindToObservable({schema: t, updater: e, data: n}) {
                const i = n.revertData;
                $_(t, e, n);
                const o = t.filter((t => !rA(t))).filter((t => t.observable)).map((i => i.activateAttributeListener(t, e, n)));
                if (i) {
                    i.bindings.push(o)
                }
            }

            _revertTemplateFromNode(t, e) {
                for (const t of e.bindings) {
                    for (const e of t) {
                        e()
                    }
                }
                if (e.text) {
                    t.textContent = e.text;
                    return
                }
                const n = t;
                for (const t in e.attributes) {
                    const i = e.attributes[t];
                    if (i === null) {
                        n.removeAttribute(t)
                    } else {
                        n.setAttribute(t, i)
                    }
                }
                for (let t = 0; t < e.children.length; ++t) {
                    this._revertTemplateFromNode(n.childNodes[t], e.children[t])
                }
            }
        }

        class M_ {
            constructor(t) {
                this.attribute = t.attribute;
                this.observable = t.observable;
                this.emitter = t.emitter;
                this.callback = t.callback
            }

            getValue(t) {
                const e = this.observable[this.attribute];
                return this.callback ? this.callback(e, t) : e
            }

            activateAttributeListener(t, e, n) {
                const i = () => $_(t, e, n);
                this.emitter.listenTo(this.observable, `change:${this.attribute}`, i);
                return () => {
                    this.emitter.stopListening(this.observable, `change:${this.attribute}`, i)
                }
            }
        }

        class H_ extends M_ {
            constructor(t) {
                super(t);
                this.eventNameOrFunction = t.eventNameOrFunction
            }

            activateDomEventListener(t, e, n) {
                const i = (t, n) => {
                    if (!e || n.target.matches(e)) {
                        if (typeof this.eventNameOrFunction == "function") {
                            this.eventNameOrFunction(n)
                        } else {
                            this.observable.fire(this.eventNameOrFunction, n)
                        }
                    }
                };
                this.emitter.listenTo(n.node, t, i);
                return () => {
                    this.emitter.stopListening(n.node, t, i)
                }
            }
        }

        class W_ extends M_ {
            constructor(t) {
                super(t);
                this.valueIfTrue = t.valueIfTrue
            }

            getValue(t) {
                const e = super.getValue(t);
                return rA(e) ? false : this.valueIfTrue || true
            }
        }

        function q_(t) {
            if (!t) {
                return false
            }
            if (t.value) {
                t = t.value
            }
            if (Array.isArray(t)) {
                return t.some(q_)
            } else if (t instanceof M_) {
                return true
            }
            return false
        }

        function j_(t, e) {
            return t.map((t => {
                if (t instanceof M_) {
                    return t.getValue(e)
                }
                return t
            }))
        }

        function $_(t, e, {node: n}) {
            const i = j_(t, n);
            let o;
            if (t.length == 1 && t[0] instanceof W_) {
                o = i[0]
            } else {
                o = i.reduce(nA, "")
            }
            if (rA(o)) {
                e.remove()
            } else {
                e.set(o)
            }
        }

        function U_(t) {
            return {
                set(e) {
                    t.textContent = e
                }, remove() {
                    t.textContent = ""
                }
            }
        }

        function G_(t, e, n) {
            return {
                set(i) {
                    t.setAttributeNS(n, e, i)
                }, remove() {
                    t.removeAttributeNS(n, e)
                }
            }
        }

        function K_(t, e) {
            return {
                set(n) {
                    t.style[e] = n
                }, remove() {
                    t.style[e] = null
                }
            }
        }

        function Z_(t) {
            const e = Na(t, (t => {
                if (t && (t instanceof M_ || aA(t) || sA(t) || lA(t))) {
                    return t
                }
            }));
            return e
        }

        function J_(t) {
            if (typeof t == "string") {
                t = X_(t)
            } else if (t.text) {
                tA(t)
            }
            if (t.on) {
                t.eventListeners = Q_(t.on);
                delete t.on
            }
            if (!t.text) {
                if (t.attributes) {
                    Y_(t.attributes)
                }
                const e = [];
                if (t.children) {
                    if (lA(t.children)) {
                        e.push(t.children)
                    } else {
                        for (const n of t.children) {
                            if (aA(n) || sA(n) || $a(n)) {
                                e.push(n)
                            } else {
                                e.push(new N_(n))
                            }
                        }
                    }
                }
                t.children = e
            }
            return t
        }

        function Y_(t) {
            for (const e in t) {
                if (t[e].value) {
                    t[e].value = Zl(t[e].value)
                }
                eA(t, e)
            }
        }

        function Q_(t) {
            for (const e in t) {
                eA(t, e)
            }
            return t
        }

        function X_(t) {
            return {text: [t]}
        }

        function tA(t) {
            t.text = Zl(t.text)
        }

        function eA(t, e) {
            t[e] = Zl(t[e])
        }

        function nA(t, e) {
            if (rA(e)) {
                return t
            } else if (rA(t)) {
                return e
            } else {
                return `${t} ${e}`
            }
        }

        function iA(t, e) {
            for (const n in e) {
                if (t[n]) {
                    t[n].push(...e[n])
                } else {
                    t[n] = e[n]
                }
            }
        }

        function oA(t, e) {
            if (e.attributes) {
                if (!t.attributes) {
                    t.attributes = {}
                }
                iA(t.attributes, e.attributes)
            }
            if (e.eventListeners) {
                if (!t.eventListeners) {
                    t.eventListeners = {}
                }
                iA(t.eventListeners, e.eventListeners)
            }
            if (e.text) {
                t.text.push(...e.text)
            }
            if (e.children && e.children.length) {
                if (t.children.length != e.children.length) {
                    throw new P("ui-template-extend-children-mismatch", t)
                }
                let n = 0;
                for (const i of e.children) {
                    oA(t.children[n++], i)
                }
            }
        }

        function rA(t) {
            return !t && t !== 0
        }

        function sA(t) {
            return t instanceof pA
        }

        function aA(t) {
            return t instanceof N_
        }

        function lA(t) {
            return t instanceof F_
        }

        function cA(t) {
            return it(t[0]) && t[0].ns
        }

        function dA() {
            return {children: [], bindings: [], attributes: {}}
        }

        function uA(t) {
            return t == "class" || t == "style"
        }

        var hA = n(6150);
        var fA = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        fA.insert = "head";
        fA.singleton = true;
        var gA = Bc()(hA.Z, fA);
        const mA = hA.Z.locals || {};

        class pA extends (Ka(dt())) {
            constructor(t) {
                super();
                this.element = null;
                this.isRendered = false;
                this.locale = t;
                this.t = t && t.t;
                this._viewCollections = new rc;
                this._unboundChildren = this.createCollection();
                this._viewCollections.on("add", ((e, n) => {
                    n.locale = t;
                    n.t = t && t.t
                }));
                this.decorate("render")
            }

            get bindTemplate() {
                if (this._bindTemplate) {
                    return this._bindTemplate
                }
                return this._bindTemplate = N_.bind(this, this)
            }

            createCollection(t) {
                const e = new F_(t);
                this._viewCollections.add(e);
                return e
            }

            registerChild(t) {
                if (!yt(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.add(e)
                }
            }

            deregisterChild(t) {
                if (!yt(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.remove(e)
                }
            }

            setTemplate(t) {
                this.template = new N_(t)
            }

            extendTemplate(t) {
                N_.extend(this.template, t)
            }

            render() {
                if (this.isRendered) {
                    throw new P("ui-view-render-already-rendered", this)
                }
                if (this.template) {
                    this.element = this.template.render();
                    this.registerChild(this.template.getViews())
                }
                this.isRendered = true
            }

            destroy() {
                this.stopListening();
                this._viewCollections.map((t => t.destroy()));
                if (this.template && this.template._revertData) {
                    this.template.revert(this.element)
                }
            }
        }

        var bA = n(8245);
        var kA = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        kA.insert = "head";
        kA.singleton = true;
        var wA = Bc()(bA.Z, kA);
        const _A = bA.Z.locals || {};
        const AA = hl("px");
        const CA = Xa.document.body;

        class vA extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("position", "arrow_nw");
                this.set("isVisible", false);
                this.set("withArrow", true);
                this.set("class", undefined);
                this._pinWhenIsVisibleCallback = null;
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                        style: {top: e.to("top", AA), left: e.to("left", AA)}
                    },
                    children: this.content
                })
            }

            show() {
                this.isVisible = true
            }

            hide() {
                this.isVisible = false
            }

            attachTo(t) {
                this.show();
                const e = vA.defaultPositions;
                const n = Object.assign({}, {
                    element: this.element,
                    positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth],
                    limiter: CA,
                    fitInViewport: true
                }, t);
                const i = vA._getOptimalPosition(n);
                const o = parseInt(i.left);
                const r = parseInt(i.top);
                const s = i.name;
                const a = i.config || {};
                const {withArrow: l = true} = a;
                this.top = r;
                this.left = o;
                this.position = s;
                this.withArrow = l
            }

            pin(t) {
                this.unpin();
                this._pinWhenIsVisibleCallback = () => {
                    if (this.isVisible) {
                        this._startPinning(t)
                    } else {
                        this._stopPinning()
                    }
                };
                this._startPinning(t);
                this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
            }

            unpin() {
                if (this._pinWhenIsVisibleCallback) {
                    this._stopPinning();
                    this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
                    this._pinWhenIsVisibleCallback = null;
                    this.hide()
                }
            }

            _startPinning(t) {
                this.attachTo(t);
                const e = yA(t.target);
                const n = t.limiter ? yA(t.limiter) : CA;
                this.listenTo(Xa.document, "scroll", ((i, o) => {
                    const r = o.target;
                    const s = e && r.contains(e);
                    const a = n && r.contains(n);
                    if (s || a || !e || !n) {
                        this.attachTo(t)
                    }
                }), {useCapture: true});
                this.listenTo(Xa.window, "resize", (() => {
                    this.attachTo(t)
                }))
            }

            _stopPinning() {
                this.stopListening(Xa.document, "scroll");
                this.stopListening(Xa.window, "resize")
            }
        }

        vA.arrowSideOffset = 25;
        vA.arrowHeightOffset = 10;
        vA.stickyVerticalOffset = 20;
        vA._getOptimalPosition = kl;
        vA.defaultPositions = xA();

        function yA(t) {
            if (Ha(t)) {
                return t
            }
            if (il(t)) {
                return t.commonAncestorContainer
            }
            if (typeof t == "function") {
                return yA(t())
            }
            return null
        }

        function xA(t = {}) {
            const {
                sideOffset: e = vA.arrowSideOffset,
                heightOffset: n = vA.arrowHeightOffset,
                stickyVerticalOffset: i = vA.stickyVerticalOffset,
                config: o
            } = t;
            return {
                northWestArrowSouthWest: (t, n) => ({
                    top: r(t, n),
                    left: t.left - e,
                    name: "arrow_sw", ...o && {config: o}
                }),
                northWestArrowSouthMiddleWest: (t, n) => ({
                    top: r(t, n),
                    left: t.left - n.width * .25 - e,
                    name: "arrow_smw", ...o && {config: o}
                }),
                northWestArrowSouth: (t, e) => ({
                    top: r(t, e),
                    left: t.left - e.width / 2,
                    name: "arrow_s", ...o && {config: o}
                }),
                northWestArrowSouthMiddleEast: (t, n) => ({
                    top: r(t, n),
                    left: t.left - n.width * .75 + e,
                    name: "arrow_sme", ...o && {config: o}
                }),
                northWestArrowSouthEast: (t, n) => ({
                    top: r(t, n),
                    left: t.left - n.width + e,
                    name: "arrow_se", ...o && {config: o}
                }),
                northArrowSouthWest: (t, n) => ({
                    top: r(t, n),
                    left: t.left + t.width / 2 - e,
                    name: "arrow_sw", ...o && {config: o}
                }),
                northArrowSouthMiddleWest: (t, n) => ({
                    top: r(t, n),
                    left: t.left + t.width / 2 - n.width * .25 - e,
                    name: "arrow_smw", ...o && {config: o}
                }),
                northArrowSouth: (t, e) => ({
                    top: r(t, e),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_s", ...o && {config: o}
                }),
                northArrowSouthMiddleEast: (t, n) => ({
                    top: r(t, n),
                    left: t.left + t.width / 2 - n.width * .75 + e,
                    name: "arrow_sme", ...o && {config: o}
                }),
                northArrowSouthEast: (t, n) => ({
                    top: r(t, n),
                    left: t.left + t.width / 2 - n.width + e,
                    name: "arrow_se", ...o && {config: o}
                }),
                northEastArrowSouthWest: (t, n) => ({
                    top: r(t, n),
                    left: t.right - e,
                    name: "arrow_sw", ...o && {config: o}
                }),
                northEastArrowSouthMiddleWest: (t, n) => ({
                    top: r(t, n),
                    left: t.right - n.width * .25 - e,
                    name: "arrow_smw", ...o && {config: o}
                }),
                northEastArrowSouth: (t, e) => ({
                    top: r(t, e),
                    left: t.right - e.width / 2,
                    name: "arrow_s", ...o && {config: o}
                }),
                northEastArrowSouthMiddleEast: (t, n) => ({
                    top: r(t, n),
                    left: t.right - n.width * .75 + e,
                    name: "arrow_sme", ...o && {config: o}
                }),
                northEastArrowSouthEast: (t, n) => ({
                    top: r(t, n),
                    left: t.right - n.width + e,
                    name: "arrow_se", ...o && {config: o}
                }),
                southWestArrowNorthWest: t => ({top: s(t), left: t.left - e, name: "arrow_nw", ...o && {config: o}}),
                southWestArrowNorthMiddleWest: (t, n) => ({
                    top: s(t),
                    left: t.left - n.width * .25 - e,
                    name: "arrow_nmw", ...o && {config: o}
                }),
                southWestArrowNorth: (t, e) => ({
                    top: s(t),
                    left: t.left - e.width / 2,
                    name: "arrow_n", ...o && {config: o}
                }),
                southWestArrowNorthMiddleEast: (t, n) => ({
                    top: s(t),
                    left: t.left - n.width * .75 + e,
                    name: "arrow_nme", ...o && {config: o}
                }),
                southWestArrowNorthEast: (t, n) => ({
                    top: s(t),
                    left: t.left - n.width + e,
                    name: "arrow_ne", ...o && {config: o}
                }),
                southArrowNorthWest: t => ({
                    top: s(t),
                    left: t.left + t.width / 2 - e,
                    name: "arrow_nw", ...o && {config: o}
                }),
                southArrowNorthMiddleWest: (t, n) => ({
                    top: s(t),
                    left: t.left + t.width / 2 - n.width * .25 - e,
                    name: "arrow_nmw", ...o && {config: o}
                }),
                southArrowNorth: (t, e) => ({
                    top: s(t),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_n", ...o && {config: o}
                }),
                southArrowNorthMiddleEast: (t, n) => ({
                    top: s(t),
                    left: t.left + t.width / 2 - n.width * .75 + e,
                    name: "arrow_nme", ...o && {config: o}
                }),
                southArrowNorthEast: (t, n) => ({
                    top: s(t),
                    left: t.left + t.width / 2 - n.width + e,
                    name: "arrow_ne", ...o && {config: o}
                }),
                southEastArrowNorthWest: t => ({top: s(t), left: t.right - e, name: "arrow_nw", ...o && {config: o}}),
                southEastArrowNorthMiddleWest: (t, n) => ({
                    top: s(t),
                    left: t.right - n.width * .25 - e,
                    name: "arrow_nmw", ...o && {config: o}
                }),
                southEastArrowNorth: (t, e) => ({
                    top: s(t),
                    left: t.right - e.width / 2,
                    name: "arrow_n", ...o && {config: o}
                }),
                southEastArrowNorthMiddleEast: (t, n) => ({
                    top: s(t),
                    left: t.right - n.width * .75 + e,
                    name: "arrow_nme", ...o && {config: o}
                }),
                southEastArrowNorthEast: (t, n) => ({
                    top: s(t),
                    left: t.right - n.width + e,
                    name: "arrow_ne", ...o && {config: o}
                }),
                westArrowEast: (t, e) => ({
                    top: t.top + t.height / 2 - e.height / 2,
                    left: t.left - e.width - n,
                    name: "arrow_e", ...o && {config: o}
                }),
                eastArrowWest: (t, e) => ({
                    top: t.top + t.height / 2 - e.height / 2,
                    left: t.right + n,
                    name: "arrow_w", ...o && {config: o}
                }),
                viewportStickyNorth: (t, e, n) => {
                    if (!t.getIntersection(n)) {
                        return null
                    }
                    return {
                        top: n.top + i,
                        left: t.left + t.width / 2 - e.width / 2,
                        name: "arrowless",
                        config: {withArrow: false, ...o}
                    }
                }
            };

            function r(t, e) {
                return t.top - e.height - n
            }

            function s(t) {
                return t.bottom + n
            }
        }

        var EA = n(9948);
        var SA = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        SA.insert = "head";
        SA.singleton = true;
        var DA = Bc()(EA.Z, SA);
        const TA = EA.Z.locals || {};
        const BA = "ck-tooltip";

        class PA extends (Ka()) {
            constructor(t) {
                super();
                PA._editors.add(t);
                if (PA._instance) {
                    return PA._instance
                }
                PA._instance = this;
                this.tooltipTextView = new pA(t.locale);
                this.tooltipTextView.set("text", "");
                this.tooltipTextView.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-tooltip__text"]},
                    children: [{text: this.tooltipTextView.bindTemplate.to("text")}]
                });
                this.balloonPanelView = new vA(t.locale);
                this.balloonPanelView.class = BA;
                this.balloonPanelView.content.add(this.tooltipTextView);
                this._resizeObserver = null;
                this._currentElementWithTooltip = null;
                this._currentTooltipPosition = null;
                this._pinTooltipDebounced = Qf(this._pinTooltip, 600);
                this.listenTo(Xa.document, "mouseenter", this._onEnterOrFocus.bind(this), {useCapture: true});
                this.listenTo(Xa.document, "mouseleave", this._onLeaveOrBlur.bind(this), {useCapture: true});
                this.listenTo(Xa.document, "focus", this._onEnterOrFocus.bind(this), {useCapture: true});
                this.listenTo(Xa.document, "blur", this._onLeaveOrBlur.bind(this), {useCapture: true});
                this.listenTo(Xa.document, "scroll", this._onScroll.bind(this), {useCapture: true});
                this._watchdogExcluded = true
            }

            destroy(t) {
                const e = t.ui.view && t.ui.view.body;
                PA._editors.delete(t);
                this.stopListening(t.ui);
                if (e && e.has(this.balloonPanelView)) {
                    e.remove(this.balloonPanelView)
                }
                if (!PA._editors.size) {
                    this._unpinTooltip();
                    this.balloonPanelView.destroy();
                    this.stopListening();
                    PA._instance = null
                }
            }

            static getPositioningFunctions(t) {
                const e = PA.defaultBalloonPositions;
                return {
                    s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
                    n: [e.northArrowSouth],
                    e: [e.eastArrowWest],
                    w: [e.westArrowEast],
                    sw: [e.southArrowNorthEast],
                    se: [e.southArrowNorthWest]
                }[t]
            }

            _onEnterOrFocus(t, {target: e}) {
                const n = IA(e);
                if (!n) {
                    return
                }
                if (n === this._currentElementWithTooltip) {
                    return
                }
                this._unpinTooltip();
                this._pinTooltipDebounced(n, RA(n))
            }

            _onLeaveOrBlur(t, {target: e, relatedTarget: n}) {
                if (t.name === "mouseleave") {
                    if (!Ha(e)) {
                        return
                    }
                    if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
                        return
                    }
                    const t = IA(e);
                    const i = IA(n);
                    if (t && t !== i) {
                        this._unpinTooltip()
                    }
                } else {
                    if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
                        return
                    }
                    this._unpinTooltip()
                }
            }

            _onScroll(t, {target: e}) {
                if (!this._currentElementWithTooltip) {
                    return
                }
                if (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip)) {
                    return
                }
                this._unpinTooltip()
            }

            _pinTooltip(t, {text: e, position: n, cssClass: i}) {
                const o = sc(PA._editors.values()).ui.view.body;
                if (!o.has(this.balloonPanelView)) {
                    o.add(this.balloonPanelView)
                }
                this.tooltipTextView.text = e;
                this.balloonPanelView.pin({target: t, positions: PA.getPositioningFunctions(n)});
                this._resizeObserver = new dl(t, (() => {
                    if (!pl(t)) {
                        this._unpinTooltip()
                    }
                }));
                this.balloonPanelView.class = [BA, i].filter((t => t)).join(" ");
                for (const t of PA._editors) {
                    this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), {priority: "low"})
                }
                this._currentElementWithTooltip = t;
                this._currentTooltipPosition = n
            }

            _unpinTooltip() {
                this._pinTooltipDebounced.cancel();
                this.balloonPanelView.unpin();
                for (const t of PA._editors) {
                    this.stopListening(t.ui, "update")
                }
                this._currentElementWithTooltip = null;
                this._currentTooltipPosition = null;
                if (this._resizeObserver) {
                    this._resizeObserver.destroy()
                }
            }

            _updateTooltipPosition() {
                if (!pl(this._currentElementWithTooltip)) {
                    this._unpinTooltip();
                    return
                }
                this.balloonPanelView.pin({
                    target: this._currentElementWithTooltip,
                    positions: PA.getPositioningFunctions(this._currentTooltipPosition)
                })
            }
        }

        PA.defaultBalloonPositions = xA({heightOffset: 5, sideOffset: 13});
        PA._editors = new Set;
        PA._instance = null;

        function IA(t) {
            if (!Ha(t)) {
                return null
            }
            return t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])")
        }

        function RA(t) {
            return {
                text: t.dataset.ckeTooltipText,
                position: t.dataset.ckeTooltipPosition || "s",
                cssClass: t.dataset.ckeTooltipClass || ""
            }
        }

        class zA extends (dt()) {
            constructor(t) {
                super();
                this.editor = t;
                this.componentFactory = new z_(t);
                this.focusTracker = new ac;
                this.tooltipManager = new PA(t);
                this.set("viewportOffset", this._readViewportOffsetFromConfig());
                this.isReady = false;
                this.once("ready", (() => {
                    this.isReady = true
                }));
                this._editableElementsMap = new Map;
                this._focusableToolbarDefinitions = [];
                this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update()));
                this._initFocusTracking()
            }

            get element() {
                return null
            }

            update() {
                this.fire("update")
            }

            destroy() {
                this.stopListening();
                this.focusTracker.destroy();
                this.tooltipManager.destroy(this.editor);
                for (const t of this._editableElementsMap.values()) {
                    t.ckeditorInstance = null
                }
                this._editableElementsMap = new Map;
                this._focusableToolbarDefinitions = []
            }

            setEditableElement(t, e) {
                this._editableElementsMap.set(t, e);
                if (!e.ckeditorInstance) {
                    e.ckeditorInstance = this.editor
                }
                this.focusTracker.add(e);
                const n = () => {
                    if (this.editor.editing.view.getDomRoot(t)) {
                        return
                    }
                    this.editor.keystrokes.listenTo(e)
                };
                if (this.isReady) {
                    n()
                } else {
                    this.once("ready", n)
                }
            }

            getEditableElement(t = "main") {
                return this._editableElementsMap.get(t)
            }

            getEditableElementsNames() {
                return this._editableElementsMap.keys()
            }

            addToolbar(t, e = {}) {
                if (t.isRendered) {
                    this.focusTracker.add(t.element);
                    this.editor.keystrokes.listenTo(t.element)
                } else {
                    t.once("render", (() => {
                        this.focusTracker.add(t.element);
                        this.editor.keystrokes.listenTo(t.element)
                    }))
                }
                this._focusableToolbarDefinitions.push({toolbarView: t, options: e})
            }

            get _editableElements() {
                console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this});
                return this._editableElementsMap
            }

            _readViewportOffsetFromConfig() {
                const t = this.editor;
                const e = t.config.get("ui.viewportOffset");
                if (e) {
                    return e
                }
                const n = t.config.get("toolbar.viewportTopOffset");
                if (n) {
                    console.warn("editor-ui-deprecated-viewport-offset-config: " + "The `toolbar.vieportTopOffset` configuration option is deprecated. " + "It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
                    return {top: n}
                }
                return {top: 0}
            }

            _initFocusTracking() {
                const t = this.editor;
                const e = t.editing.view;
                let n;
                let i;
                t.keystrokes.set("Alt+F10", ((t, o) => {
                    const r = this.focusTracker.focusedElement;
                    if (Array.from(this._editableElementsMap.values()).includes(r) && !Array.from(e.domRoots.values()).includes(r)) {
                        n = r
                    }
                    const s = this._getCurrentFocusedToolbarDefinition();
                    if (!s || !i) {
                        i = this._getFocusableCandidateToolbarDefinitions()
                    }
                    for (let t = 0; t < i.length; t++) {
                        const t = i.shift();
                        i.push(t);
                        if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                            if (s && s.options.afterBlur) {
                                s.options.afterBlur()
                            }
                            break
                        }
                    }
                    o()
                }));
                t.keystrokes.set("Esc", ((e, i) => {
                    const o = this._getCurrentFocusedToolbarDefinition();
                    if (!o) {
                        return
                    }
                    if (n) {
                        n.focus();
                        n = null
                    } else {
                        t.editing.view.focus()
                    }
                    if (o.options.afterBlur) {
                        o.options.afterBlur()
                    }
                    i()
                }))
            }

            _getFocusableCandidateToolbarDefinitions() {
                const t = [];
                for (const e of this._focusableToolbarDefinitions) {
                    const {toolbarView: n, options: i} = e;
                    if (pl(n.element) || i.beforeFocus) {
                        t.push(e)
                    }
                }
                t.sort(((t, e) => VA(t) - VA(e)));
                return t
            }

            _getCurrentFocusedToolbarDefinition() {
                for (const t of this._focusableToolbarDefinitions) {
                    if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) {
                        return t
                    }
                }
                return null
            }

            _focusFocusableCandidateToolbar(t) {
                const {toolbarView: e, options: {beforeFocus: n}} = t;
                if (n) {
                    n()
                }
                if (!pl(e.element)) {
                    return false
                }
                e.focus();
                return true
            }
        }

        function VA(t) {
            const {toolbarView: e, options: n} = t;
            let i = 10;
            if (pl(e.element)) {
                i--
            }
            if (n.isContextual) {
                i--
            }
            return i
        }

        function FA(t) {
            if (!je(t.updateSourceElement)) {
                throw new P("attachtoform-missing-elementapi-interface", t)
            }
            const e = t.sourceElement;
            if (LA(e) && e.form) {
                let n;
                const i = e.form;
                const o = () => t.updateSourceElement();
                if (je(i.submit)) {
                    n = i.submit;
                    i.submit = () => {
                        o();
                        n.apply(i)
                    }
                }
                i.addEventListener("submit", o);
                t.on("destroy", (() => {
                    i.removeEventListener("submit", o);
                    if (n) {
                        i.submit = n
                    }
                }))
            }
        }

        function LA(t) {
            return !!t && t.tagName.toLowerCase() === "textarea"
        }

        function OA(t) {
            class e extends t {
                setData(t) {
                    this.data.set(t)
                }

                getData(t) {
                    return this.data.get(t)
                }
            }

            return e
        }

        {
            const t = OA(Object);
            OA.setData = t.prototype.setData;
            OA.getData = t.prototype.getData
        }

        function NA(t) {
            class e extends t {
                updateSourceElement(t = this.data.get()) {
                    if (!this.sourceElement) {
                        throw new P("editor-missing-sourceelement", this)
                    }
                    const e = this.config.get("updateSourceElementOnDestroy");
                    const n = this.sourceElement instanceof HTMLTextAreaElement;
                    if (!e && !n) {
                        ul(this.sourceElement, "");
                        return
                    }
                    ul(this.sourceElement, t)
                }
            }

            return e
        }

        NA.updateSourceElement = NA(Object).prototype.updateSourceElement;

        function MA(t) {
            const e = t.sourceElement;
            if (!e) {
                return
            }
            if (e.ckeditorInstance) {
                throw new CKEditorError("editor-source-element-already-used", t)
            }
            e.ckeditorInstance = t;
            t.once("destroy", (() => {
                delete e.ckeditorInstance
            }))
        }

        class HA extends Dc {
            static get pluginName() {
                return "PendingActions"
            }

            init() {
                this.set("hasAny", false);
                this._actions = new rc({idProperty: "_id"});
                this._actions.delegate("add", "remove").to(this)
            }

            add(t) {
                if (typeof t !== "string") {
                    throw new P("pendingactions-add-invalid-message", this)
                }
                const e = new (dt());
                e.set("message", t);
                this._actions.add(e);
                this.hasAny = true;
                return e
            }

            remove(t) {
                this._actions.remove(t);
                this.hasAny = !!this._actions.length
            }

            get first() {
                return this._actions.get(0)
            }

            [Symbol.iterator]() {
                return this._actions[Symbol.iterator]()
            }
        }

        const WA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        const qA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
        const jA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
        const $A = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
        const UA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
        const GA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
        const KA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
        const ZA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
        const JA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
        const YA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
        const QA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        const XA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
        const tC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
        const eC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        const nC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
        const iC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
        const oC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
        const rC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
        const sC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
        const aC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
        const lC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
        const cC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
        const dC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
        const uC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
        const hC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
        const fC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
        const gC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
        const mC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
        const pC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
        const bC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
        const kC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
        const wC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
        const _C = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>';
        const AC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>';
        const CC = {
            bold: bC,
            cancel: WA,
            caption: qA,
            check: jA,
            cog: $A,
            eraser: UA,
            image: KA,
            lowVision: GA,
            importExport: AC,
            paragraph: kC,
            plus: wC,
            text: _C,
            alignBottom: ZA,
            alignMiddle: JA,
            alignTop: YA,
            alignLeft: QA,
            alignCenter: XA,
            alignRight: tC,
            alignJustify: eC,
            objectLeft: aC,
            objectCenter: iC,
            objectRight: lC,
            objectFullWidth: rC,
            objectInline: sC,
            objectBlockLeft: nC,
            objectBlockRight: oC,
            objectSizeFull: cC,
            objectSizeLarge: dC,
            objectSizeSmall: uC,
            objectSizeMedium: hC,
            pencil: fC,
            pilcrow: gC,
            quote: mC,
            threeVerticalDots: pC
        };

        function vC({emitter: t, activator: e, callback: n, contextElements: i}) {
            t.listenTo(document, "mousedown", ((t, o) => {
                if (!e()) {
                    return
                }
                const r = typeof o.composedPath == "function" ? o.composedPath() : [];
                for (const t of i) {
                    if (t.contains(o.target) || r.includes(t)) {
                        return
                    }
                }
                n()
            }))
        }

        function yC(t) {
            const e = t;
            e.set("_isCssTransitionsDisabled", false);
            e.disableCssTransitions = () => {
                e._isCssTransitionsDisabled = true
            };
            e.enableCssTransitions = () => {
                e._isCssTransitionsDisabled = false
            };
            e.extendTemplate({attributes: {class: [e.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]}})
        }

        function xC({view: t}) {
            t.listenTo(t.element, "submit", ((e, n) => {
                n.preventDefault();
                t.fire("submit")
            }), {useCapture: true})
        }

        function EC({keystrokeHandler: t, focusTracker: e, gridItems: n, numberOfColumns: i, uiLanguageDirection: o}) {
            const r = typeof i === "number" ? () => i : i;
            t.set("arrowright", s(((t, e) => o === "rtl" ? l(t, e.length) : a(t, e.length))));
            t.set("arrowleft", s(((t, e) => o === "rtl" ? a(t, e.length) : l(t, e.length))));
            t.set("arrowup", s(((t, e) => {
                let n = t - r();
                if (n < 0) {
                    n = t + r() * Math.floor(e.length / r());
                    if (n > e.length - 1) {
                        n -= r()
                    }
                }
                return n
            })));
            t.set("arrowdown", s(((t, e) => {
                let n = t + r();
                if (n > e.length - 1) {
                    n = t % r()
                }
                return n
            })));

            function s(t) {
                return i => {
                    const o = n.find((t => t.element === e.focusedElement));
                    const r = n.getIndex(o);
                    const s = t(r, n);
                    n.get(s).focus();
                    i.stopPropagation();
                    i.preventDefault()
                }
            }

            function a(t, e) {
                if (t === e - 1) {
                    return 0
                } else {
                    return t + 1
                }
            }

            function l(t, e) {
                if (t === 0) {
                    return e - 1
                } else {
                    return t - 1
                }
            }
        }

        class SC extends F_ {
            constructor(t, e = []) {
                super(e);
                this.locale = t
            }

            attachToDom() {
                this._bodyCollectionContainer = new N_({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                        dir: this.locale.uiLanguageDirection
                    },
                    children: this
                }).render();
                let t = document.querySelector(".ck-body-wrapper");
                if (!t) {
                    t = te(document, "div", {class: "ck-body-wrapper"});
                    document.body.appendChild(t)
                }
                t.appendChild(this._bodyCollectionContainer)
            }

            detachFromDom() {
                super.destroy();
                if (this._bodyCollectionContainer) {
                    this._bodyCollectionContainer.remove()
                }
                const t = document.querySelector(".ck-body-wrapper");
                if (t && t.childElementCount == 0) {
                    t.remove()
                }
            }
        }

        var DC = n(1174);
        var TC = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        TC.insert = "head";
        TC.singleton = true;
        var BC = Bc()(DC.Z, TC);
        const PC = DC.Z.locals || {};

        class IC extends pA {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.set("content", "");
                this.set("viewBox", "0 0 20 20");
                this.set("fillColor", "");
                this.set("isColorInherited", true);
                this.setTemplate({
                    tag: "svg",
                    ns: "http://www.w3.org/2000/svg",
                    attributes: {
                        class: ["ck", "ck-icon", "ck-reset_all-excluded", t.if("isColorInherited", "ck-icon_inherit-color")],
                        viewBox: t.to("viewBox")
                    }
                })
            }

            render() {
                super.render();
                this._updateXMLContent();
                this._colorFillPaths();
                this.on("change:content", (() => {
                    this._updateXMLContent();
                    this._colorFillPaths()
                }));
                this.on("change:fillColor", (() => {
                    this._colorFillPaths()
                }))
            }

            _updateXMLContent() {
                if (this.content) {
                    const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml");
                    const e = t.querySelector("svg");
                    const n = e.getAttribute("viewBox");
                    if (n) {
                        this.viewBox = n
                    }
                    for (const {name: t, value: n} of Array.from(e.attributes)) {
                        if (IC.presentationalAttributeNames.includes(t)) {
                            this.element.setAttribute(t, n)
                        }
                    }
                    while (this.element.firstChild) {
                        this.element.removeChild(this.element.firstChild)
                    }
                    while (e.childNodes.length > 0) {
                        this.element.appendChild(e.childNodes[0])
                    }
                }
            }

            _colorFillPaths() {
                if (this.fillColor) {
                    this.element.querySelectorAll(".ck-icon__fill").forEach((t => {
                        t.style.fill = this.fillColor
                    }))
                }
            }
        }

        IC.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
        var RC = n(4499);
        var zC = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        zC.insert = "head";
        zC.singleton = true;
        var VC = Bc()(RC.Z, zC);
        const FC = RC.Z.locals || {};

        class LC extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                const n = E();
                this.set("class", undefined);
                this.set("labelStyle", undefined);
                this.set("icon", undefined);
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isVisible", true);
                this.set("isToggleable", false);
                this.set("keystroke", undefined);
                this.set("label", undefined);
                this.set("tabindex", -1);
                this.set("tooltip", false);
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.set("withKeystroke", false);
                this.children = this.createCollection();
                this.labelView = this._createLabelView(n);
                this.iconView = new IC;
                this.iconView.extendTemplate({attributes: {class: "ck-button__icon"}});
                this.keystrokeView = this._createKeystrokeView();
                this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                const i = {
                    tag: "button",
                    attributes: {
                        class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                        type: e.to("type", (t => t ? t : "button")),
                        tabindex: e.to("tabindex"),
                        "aria-labelledby": `ck-editor__aria-label_${n}`,
                        "aria-disabled": e.if("isEnabled", true, (t => !t)),
                        "aria-pressed": e.to("isOn", (t => this.isToggleable ? String(!!t) : false)),
                        "data-cke-tooltip-text": e.to("_tooltipString"),
                        "data-cke-tooltip-position": e.to("tooltipPosition")
                    },
                    children: this.children,
                    on: {
                        click: e.to((t => {
                            if (this.isEnabled) {
                                this.fire("execute")
                            } else {
                                t.preventDefault()
                            }
                        }))
                    }
                };
                if (r.isSafari) {
                    i.on.mousedown = e.to((t => {
                        this.focus();
                        t.preventDefault()
                    }))
                }
                this.setTemplate(i)
            }

            render() {
                super.render();
                if (this.icon) {
                    this.iconView.bind("content").to(this, "icon");
                    this.children.add(this.iconView)
                }
                this.children.add(this.labelView);
                if (this.withKeystroke && this.keystroke) {
                    this.children.add(this.keystrokeView)
                }
            }

            focus() {
                this.element.focus()
            }

            _createLabelView(t) {
                const e = new pA;
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__label"],
                        style: n.to("labelStyle"),
                        id: `ck-editor__aria-label_${t}`
                    },
                    children: [{text: this.bindTemplate.to("label")}]
                });
                return e
            }

            _createKeystrokeView() {
                const t = new pA;
                t.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-button__keystroke"]},
                    children: [{text: this.bindTemplate.to("keystroke", (t => Wl(t)))}]
                });
                return t
            }

            _getTooltipString(t, e, n) {
                if (t) {
                    if (typeof t == "string") {
                        return t
                    } else {
                        if (n) {
                            n = Wl(n)
                        }
                        if (t instanceof Function) {
                            return t(e, n)
                        } else {
                            return `${e}${n ? ` (${n})` : ""}`
                        }
                    }
                }
                return ""
            }
        }

        var OC = n(9681);
        var NC = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        NC.insert = "head";
        NC.singleton = true;
        var MC = Bc()(OC.Z, NC);
        const HC = OC.Z.locals || {};

        class WC extends LC {
            constructor(t) {
                super(t);
                this.isToggleable = true;
                this.toggleSwitchView = this._createToggleView();
                this.extendTemplate({attributes: {class: "ck-switchbutton"}})
            }

            render() {
                super.render();
                this.children.add(this.toggleSwitchView)
            }

            _createToggleView() {
                const t = new pA;
                t.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-button__toggle"]},
                    children: [{tag: "span", attributes: {class: ["ck", "ck-button__toggle__inner"]}}]
                });
                return t
            }
        }

        function qC(t, e) {
            const n = t.t;
            const i = {
                Black: n("Black"),
                "Dim grey": n("Dim grey"),
                Grey: n("Grey"),
                "Light grey": n("Light grey"),
                White: n("White"),
                Red: n("Red"),
                Orange: n("Orange"),
                Yellow: n("Yellow"),
                "Light green": n("Light green"),
                Green: n("Green"),
                Aquamarine: n("Aquamarine"),
                Turquoise: n("Turquoise"),
                "Light blue": n("Light blue"),
                Blue: n("Blue"),
                Purple: n("Purple")
            };
            return e.map((t => {
                const e = i[t.label];
                if (e && e != t.label) {
                    t.label = e
                }
                return t
            }))
        }

        function jC(t) {
            return t.map($C).filter((t => !!t))
        }

        function $C(t) {
            if (typeof t === "string") {
                return {model: t, label: t, hasBorder: false, view: {name: "span", styles: {color: t}}}
            } else {
                return {
                    model: t.color,
                    label: t.label || t.color,
                    hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
                    view: {name: "span", styles: {color: `${t.color}`}}
                }
            }
        }

        const UC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';

        class GC extends LC {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("color", undefined);
                this.set("hasBorder", false);
                this.icon = UC;
                this.extendTemplate({
                    attributes: {
                        style: {backgroundColor: e.to("color")},
                        class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")]
                    }
                })
            }

            render() {
                super.render();
                this.iconView.fillColor = "hsl(0, 0%, 100%)"
            }
        }

        var KC = n(4923);
        var ZC = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        ZC.insert = "head";
        ZC.singleton = true;
        var JC = Bc()(KC.Z, ZC);
        const YC = KC.Z.locals || {};

        class QC extends pA {
            constructor(t, e) {
                super(t);
                const n = e && e.colorDefinitions || [];
                this.columns = e && e.columns ? e.columns : 5;
                const i = {gridTemplateColumns: `repeat( ${this.columns}, 1fr)`};
                this.set("selectedColor", undefined);
                this.items = this.createCollection();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.items.on("add", ((t, e) => {
                    e.isOn = e.color === this.selectedColor
                }));
                n.forEach((t => {
                    const e = new GC;
                    e.set({color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder});
                    e.on("execute", (() => {
                        this.fire("execute", {value: t.color, hasBorder: t.options.hasBorder, label: t.label})
                    }));
                    this.items.add(e)
                }));
                this.setTemplate({
                    tag: "div",
                    children: this.items,
                    attributes: {class: ["ck", "ck-color-grid"], style: i}
                });
                this.on("change:selectedColor", ((t, e, n) => {
                    for (const t of this.items) {
                        t.isOn = t.color === n
                    }
                }))
            }

            focus() {
                if (this.items.length) {
                    this.items.first.focus()
                }
            }

            focusLast() {
                if (this.items.length) {
                    this.items.last.focus()
                }
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element);
                EC({
                    keystrokeHandler: this.keystrokes,
                    focusTracker: this.focusTracker,
                    gridItems: this.items,
                    numberOfColumns: this.columns,
                    uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                })
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }
        }

        const XC = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';

        class tv extends LC {
            constructor(t) {
                super(t);
                this.arrowView = this._createArrowView();
                this.extendTemplate({
                    attributes: {
                        "aria-haspopup": true,
                        "aria-expanded": this.bindTemplate.to("isOn", (t => String(t)))
                    }
                });
                this.delegate("execute").to(this, "open")
            }

            render() {
                super.render();
                this.children.add(this.arrowView)
            }

            _createArrowView() {
                const t = new IC;
                t.content = XC;
                t.extendTemplate({attributes: {class: "ck-dropdown__arrow"}});
                return t
            }
        }

        var ev = n(66);
        var nv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        nv.insert = "head";
        nv.singleton = true;
        var iv = Bc()(ev.Z, nv);
        const ov = ev.Z.locals || {};

        class rv extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("class", undefined);
                this.set("labelStyle", undefined);
                this.set("icon", undefined);
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isToggleable", false);
                this.set("isVisible", true);
                this.set("keystroke", undefined);
                this.set("withKeystroke", false);
                this.set("label", undefined);
                this.set("tabindex", -1);
                this.set("tooltip", false);
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.children = this.createCollection();
                this.actionView = this._createActionView();
                this.arrowView = this._createArrowView();
                this.keystrokes = new lc;
                this.focusTracker = new ac;
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-splitbutton", e.to("class"), e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]},
                    children: this.children
                })
            }

            render() {
                super.render();
                this.children.add(this.actionView);
                this.children.add(this.arrowView);
                this.focusTracker.add(this.actionView.element);
                this.focusTracker.add(this.arrowView.element);
                this.keystrokes.listenTo(this.element);
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.actionView.element) {
                        this.arrowView.focus();
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.arrowView.element) {
                        this.actionView.focus();
                        e()
                    }
                }))
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this.actionView.focus()
            }

            _createActionView() {
                const t = new LC;
                t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
                t.extendTemplate({attributes: {class: "ck-splitbutton__action"}});
                t.delegate("execute").to(this);
                return t
            }

            _createArrowView() {
                const t = new LC;
                const e = t.bindTemplate;
                t.icon = XC;
                t.extendTemplate({
                    attributes: {
                        class: ["ck-splitbutton__arrow"],
                        "data-cke-tooltip-disabled": e.to("isOn"),
                        "aria-haspopup": true,
                        "aria-expanded": e.to("isOn", (t => String(t)))
                    }
                });
                t.bind("isEnabled").to(this);
                t.bind("label").to(this);
                t.bind("tooltip").to(this);
                t.delegate("execute").to(this, "open");
                return t
            }
        }

        class sv extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", false);
                this.set("position", "se");
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")]},
                    children: this.children,
                    on: {selectstart: e.to((t => t.preventDefault()))}
                })
            }

            focus() {
                if (this.children.length) {
                    const t = this.children.first;
                    if (typeof t.focus === "function") {
                        t.focus()
                    } else {
                        I("ui-dropdown-panel-focus-child-missing-focus", {
                            childView: this.children.first,
                            dropdownPanel: this
                        })
                    }
                }
            }

            focusLast() {
                if (this.children.length) {
                    const t = this.children.last;
                    if (typeof t.focusLast === "function") {
                        t.focusLast()
                    } else {
                        t.focus()
                    }
                }
            }
        }

        var av = n(3488);
        var lv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        lv.insert = "head";
        lv.singleton = true;
        var cv = Bc()(av.Z, lv);
        const dv = av.Z.locals || {};

        class uv extends pA {
            constructor(t, e, n) {
                super(t);
                const i = this.bindTemplate;
                this.buttonView = e;
                this.panelView = n;
                this.set("isOpen", false);
                this.set("isEnabled", true);
                this.set("class", undefined);
                this.set("id", undefined);
                this.set("panelPosition", "auto");
                this.keystrokes = new lc;
                this.focusTracker = new ac;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t))],
                        id: i.to("id"),
                        "aria-describedby": i.to("ariaDescribedById")
                    },
                    children: [e, n]
                });
                e.extendTemplate({
                    attributes: {
                        class: ["ck-dropdown__button"],
                        "data-cke-tooltip-disabled": i.to("isOpen")
                    }
                })
            }

            render() {
                super.render();
                this.focusTracker.add(this.buttonView.element);
                this.focusTracker.add(this.panelView.element);
                this.listenTo(this.buttonView, "open", (() => {
                    this.isOpen = !this.isOpen
                }));
                this.panelView.bind("isVisible").to(this, "isOpen");
                this.on("change:isOpen", ((t, e, n) => {
                    if (!n) {
                        return
                    }
                    if (this.panelPosition === "auto") {
                        this.panelView.position = uv._getOptimalPosition({
                            element: this.panelView.element,
                            target: this.buttonView.element,
                            fitInViewport: true,
                            positions: this._panelPositions
                        }).name
                    } else {
                        this.panelView.position = this.panelPosition
                    }
                }));
                this.keystrokes.listenTo(this.element);
                const t = (t, e) => {
                    if (this.isOpen) {
                        this.isOpen = false;
                        e()
                    }
                };
                this.keystrokes.set("arrowdown", ((t, e) => {
                    if (this.buttonView.isEnabled && !this.isOpen) {
                        this.isOpen = true;
                        e()
                    }
                }));
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.isOpen) {
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", t);
                this.keystrokes.set("esc", t)
            }

            focus() {
                this.buttonView.focus()
            }

            get _panelPositions() {
                const {
                    south: t,
                    north: e,
                    southEast: n,
                    southWest: i,
                    northEast: o,
                    northWest: r,
                    southMiddleEast: s,
                    southMiddleWest: a,
                    northMiddleEast: l,
                    northMiddleWest: c
                } = uv.defaultPanelPositions;
                if (this.locale.uiLanguageDirection !== "rtl") {
                    return [n, i, s, a, t, o, r, l, c, e]
                } else {
                    return [i, n, a, s, t, r, o, c, l, e]
                }
            }
        }

        uv.defaultPanelPositions = {
            south: (t, e) => ({
                top: t.bottom,
                left: t.left - (e.width - t.width) / 2,
                name: "s"
            }),
            southEast: t => ({top: t.bottom, left: t.left, name: "se"}),
            southWest: (t, e) => ({top: t.bottom, left: t.left - e.width + t.width, name: "sw"}),
            southMiddleEast: (t, e) => ({top: t.bottom, left: t.left - (e.width - t.width) / 4, name: "sme"}),
            southMiddleWest: (t, e) => ({top: t.bottom, left: t.left - (e.width - t.width) * 3 / 4, name: "smw"}),
            north: (t, e) => ({top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: "n"}),
            northEast: (t, e) => ({top: t.top - e.height, left: t.left, name: "ne"}),
            northWest: (t, e) => ({top: t.top - e.height, left: t.left - e.width + t.width, name: "nw"}),
            northMiddleEast: (t, e) => ({top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: "nme"}),
            northMiddleWest: (t, e) => ({
                top: t.top - e.height,
                left: t.left - (e.width - t.width) * 3 / 4,
                name: "nmw"
            })
        };
        uv._getOptimalPosition = kl;

        class hv {
            constructor(t) {
                this.focusables = t.focusables;
                this.focusTracker = t.focusTracker;
                this.keystrokeHandler = t.keystrokeHandler;
                this.actions = t.actions;
                if (t.actions && t.keystrokeHandler) {
                    for (const e in t.actions) {
                        let n = t.actions[e];
                        if (typeof n == "string") {
                            n = [n]
                        }
                        for (const i of n) {
                            t.keystrokeHandler.set(i, ((t, n) => {
                                this[e]();
                                n()
                            }))
                        }
                    }
                }
            }

            get first() {
                return this.focusables.find(fv) || null
            }

            get last() {
                return this.focusables.filter(fv).slice(-1)[0] || null
            }

            get next() {
                return this._getFocusableItem(1)
            }

            get previous() {
                return this._getFocusableItem(-1)
            }

            get current() {
                let t = null;
                if (this.focusTracker.focusedElement === null) {
                    return null
                }
                this.focusables.find(((e, n) => {
                    const i = e.element === this.focusTracker.focusedElement;
                    if (i) {
                        t = n
                    }
                    return i
                }));
                return t
            }

            focusFirst() {
                this._focus(this.first)
            }

            focusLast() {
                this._focus(this.last)
            }

            focusNext() {
                this._focus(this.next)
            }

            focusPrevious() {
                this._focus(this.previous)
            }

            _focus(t) {
                if (t) {
                    t.focus()
                }
            }

            _getFocusableItem(t) {
                const e = this.current;
                const n = this.focusables.length;
                if (!n) {
                    return null
                }
                if (e === null) {
                    return this[t === 1 ? "first" : "last"]
                }
                let i = (e + n + t) % n;
                do {
                    const e = this.focusables.get(i);
                    if (fv(e)) {
                        return e
                    }
                    i = (i + n + t) % n
                } while (i !== e);
                return null
            }
        }

        function fv(t) {
            return !!(t.focus && pl(t.element))
        }

        class gv extends pA {
            constructor(t) {
                super(t);
                this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__separator"]}})
            }
        }

        class mv extends pA {
            constructor(t) {
                super(t);
                this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__line-break"]}})
            }
        }

        function pv(t) {
            return t.bindTemplate.to((e => {
                if (e.target === t.element) {
                    e.preventDefault()
                }
            }))
        }

        function bv(t) {
            if (Array.isArray(t)) {
                return {items: t, removeItems: []}
            }
            if (!t) {
                return {items: [], removeItems: []}
            }
            return Object.assign({items: [], removeItems: []}, t)
        }

        var kv = n(5571);
        var wv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        wv.insert = "head";
        wv.singleton = true;
        var _v = Bc()(kv.Z, wv);
        const Av = kv.Z.locals || {};
        const {threeVerticalDots: Cv} = CC;
        const vv = {
            alignLeft: CC.alignLeft,
            bold: CC.bold,
            importExport: CC.importExport,
            paragraph: CC.paragraph,
            plus: CC.plus,
            text: CC.text,
            threeVerticalDots: CC.threeVerticalDots
        };

        class yv extends pA {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                const i = this.t;
                this.options = e || {};
                this.set("ariaLabel", i("Editor toolbar"));
                this.set("maxWidth", "auto");
                this.items = this.createCollection();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.set("class", undefined);
                this.set("isCompact", false);
                this.itemsView = new xv(t);
                this.children = this.createCollection();
                this.children.add(this.itemsView);
                this.focusables = this.createCollection();
                const o = t.uiLanguageDirection === "rtl";
                this._focusCycler = new hv({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {
                        focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
                        focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"]
                    }
                });
                const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
                if (this.options.shouldGroupWhenFull && this.options.isFloating) {
                    r.push("ck-toolbar_floating")
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: r,
                        role: "toolbar",
                        "aria-label": n.to("ariaLabel"),
                        style: {maxWidth: n.to("maxWidth")}
                    },
                    children: this.children,
                    on: {mousedown: pv(this)}
                });
                this._behavior = this.options.shouldGroupWhenFull ? new Sv(this) : new Ev(this)
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element);
                this._behavior.render(this)
            }

            destroy() {
                this._behavior.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy();
                return super.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }

            fillFromConfig(t, e, n) {
                const i = bv(t);
                const o = n || i.removeItems;
                const r = this._cleanItemsConfiguration(i.items, e, o).map((t => {
                    if (it(t)) {
                        return this._createNestedToolbarDropdown(t, e, o)
                    } else if (t === "|") {
                        return new gv
                    } else if (t === "-") {
                        return new mv
                    }
                    return e.create(t)
                })).filter((t => !!t));
                this.items.addMany(r)
            }

            _cleanItemsConfiguration(t, e, n) {
                const i = t.filter(((t, i, o) => {
                    if (t === "|") {
                        return true
                    }
                    if (n.indexOf(t) !== -1) {
                        return false
                    }
                    if (t === "-") {
                        if (this.options.shouldGroupWhenFull) {
                            I("toolbarview-line-break-ignored-when-grouping-items", o);
                            return false
                        }
                        return true
                    }
                    if (!it(t) && !e.has(t)) {
                        I("toolbarview-item-unavailable", {item: t});
                        return false
                    }
                    return true
                }));
                return this._cleanSeparatorsAndLineBreaks(i)
            }

            _cleanSeparatorsAndLineBreaks(t) {
                const e = t => t !== "-" && t !== "|";
                const n = t.length;
                const i = t.findIndex(e);
                if (i === -1) {
                    return []
                }
                const o = n - t.slice().reverse().findIndex(e);
                return t.slice(i, o).filter(((t, n, i) => {
                    if (e(t)) {
                        return true
                    }
                    const o = n > 0 && i[n - 1] === t;
                    return !o
                }))
            }

            _createNestedToolbarDropdown(t, e, n) {
                let {label: i, icon: o, items: r, tooltip: s = true, withText: a = false} = t;
                r = this._cleanItemsConfiguration(r, e, n);
                if (!r.length) {
                    return null
                }
                const l = this.locale;
                const c = qv(l);
                if (!i) {
                    I("toolbarview-nested-toolbar-dropdown-missing-label", t)
                }
                c.class = "ck-toolbar__nested-toolbar-dropdown";
                c.buttonView.set({label: i, tooltip: s, withText: !!a});
                if (o !== false) {
                    c.buttonView.icon = vv[o] || o || Cv
                } else {
                    c.buttonView.withText = true
                }
                jv(c, []);
                c.toolbarView.fillFromConfig(r, e, n);
                return c
            }
        }

        class xv extends pA {
            constructor(t) {
                super(t);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-toolbar__items"]},
                    children: this.children
                })
            }
        }

        class Ev {
            constructor(t) {
                const e = t.bindTemplate;
                t.set("isVertical", false);
                t.itemsView.children.bindTo(t.items).using((t => t));
                t.focusables.bindTo(t.items).using((t => t));
                t.extendTemplate({attributes: {class: [e.if("isVertical", "ck-toolbar_vertical")]}})
            }

            render() {
            }

            destroy() {
            }
        }

        class Sv {
            constructor(t) {
                this.view = t;
                this.viewChildren = t.children;
                this.viewFocusables = t.focusables;
                this.viewItemsView = t.itemsView;
                this.viewFocusTracker = t.focusTracker;
                this.viewLocale = t.locale;
                this.ungroupedItems = t.createCollection();
                this.groupedItems = t.createCollection();
                this.groupedItemsDropdown = this._createGroupedItemsDropdown();
                this.resizeObserver = null;
                this.cachedPadding = null;
                this.shouldUpdateGroupingOnNextResize = false;
                t.itemsView.children.bindTo(this.ungroupedItems).using((t => t));
                this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this));
                t.children.on("change", this._updateFocusCycleableItems.bind(this));
                t.items.on("change", ((t, e) => {
                    const n = e.index;
                    const i = Array.from(e.added);
                    for (const t of e.removed) {
                        if (n >= this.ungroupedItems.length) {
                            this.groupedItems.remove(t)
                        } else {
                            this.ungroupedItems.remove(t)
                        }
                    }
                    for (let t = n; t < n + i.length; t++) {
                        const e = i[t - n];
                        if (t > this.ungroupedItems.length) {
                            this.groupedItems.add(e, t - this.ungroupedItems.length)
                        } else {
                            this.ungroupedItems.add(e, t)
                        }
                    }
                    this._updateGrouping()
                }));
                t.extendTemplate({attributes: {class: ["ck-toolbar_grouping"]}})
            }

            render(t) {
                this.viewElement = t.element;
                this._enableGroupingOnResize();
                this._enableGroupingOnMaxWidthChange(t)
            }

            destroy() {
                this.groupedItemsDropdown.destroy();
                this.resizeObserver.destroy()
            }

            _updateGrouping() {
                if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
                    return
                }
                if (!pl(this.viewElement)) {
                    this.shouldUpdateGroupingOnNextResize = true;
                    return
                }
                const t = this.groupedItems.length;
                let e;
                while (this._areItemsOverflowing) {
                    this._groupLastItem();
                    e = true
                }
                if (!e && this.groupedItems.length) {
                    while (this.groupedItems.length && !this._areItemsOverflowing) {
                        this._ungroupFirstItem()
                    }
                    if (this._areItemsOverflowing) {
                        this._groupLastItem()
                    }
                }
                if (this.groupedItems.length !== t) {
                    this.view.fire("groupedItemsUpdate")
                }
            }

            get _areItemsOverflowing() {
                if (!this.ungroupedItems.length) {
                    return false
                }
                const t = this.viewElement;
                const e = this.viewLocale.uiLanguageDirection;
                const n = new sl(t.lastChild);
                const i = new sl(t);
                if (!this.cachedPadding) {
                    const n = Xa.window.getComputedStyle(t);
                    const i = e === "ltr" ? "paddingRight" : "paddingLeft";
                    this.cachedPadding = Number.parseInt(n[i])
                }
                if (e === "ltr") {
                    return n.right > i.right - this.cachedPadding
                } else {
                    return n.left < i.left + this.cachedPadding
                }
            }

            _enableGroupingOnResize() {
                let t;
                this.resizeObserver = new dl(this.viewElement, (e => {
                    if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
                        this.shouldUpdateGroupingOnNextResize = false;
                        this._updateGrouping();
                        t = e.contentRect.width
                    }
                }));
                this._updateGrouping()
            }

            _enableGroupingOnMaxWidthChange(t) {
                t.on("change:maxWidth", (() => {
                    this._updateGrouping()
                }))
            }

            _groupLastItem() {
                if (!this.groupedItems.length) {
                    this.viewChildren.add(new gv);
                    this.viewChildren.add(this.groupedItemsDropdown);
                    this.viewFocusTracker.add(this.groupedItemsDropdown.element)
                }
                this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
            }

            _ungroupFirstItem() {
                this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
                if (!this.groupedItems.length) {
                    this.viewChildren.remove(this.groupedItemsDropdown);
                    this.viewChildren.remove(this.viewChildren.last);
                    this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
                }
            }

            _createGroupedItemsDropdown() {
                const t = this.viewLocale;
                const e = t.t;
                const n = qv(t);
                n.class = "ck-toolbar__grouped-dropdown";
                n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
                jv(n, []);
                n.buttonView.set({
                    label: e("Show more items"),
                    tooltip: true,
                    tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw",
                    icon: Cv
                });
                n.toolbarView.items.bindTo(this.groupedItems).using((t => t));
                return n
            }

            _updateFocusCycleableItems() {
                this.viewFocusables.clear();
                this.ungroupedItems.map((t => {
                    this.viewFocusables.add(t)
                }));
                if (this.groupedItems.length) {
                    this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }
        }

        var Dv = n(1162);
        var Tv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Tv.insert = "head";
        Tv.singleton = true;
        var Bv = Bc()(Dv.Z, Tv);
        const Pv = Dv.Z.locals || {};

        class Iv extends pA {
            constructor(t) {
                super(t);
                this.items = this.createCollection();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this._focusCycler = new hv({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
                });
                this.setTemplate({tag: "ul", attributes: {class: ["ck", "ck-reset", "ck-list"]}, children: this.items})
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }
        }

        class Rv extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", true);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "li",
                    attributes: {class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t => !t))]},
                    children: this.children
                })
            }

            focus() {
                this.children.first.focus()
            }
        }

        class zv extends pA {
            constructor(t) {
                super(t);
                this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__separator"]}})
            }
        }

        var Vv = n(5075);
        var Fv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Fv.insert = "head";
        Fv.singleton = true;
        var Lv = Bc()(Vv.Z, Fv);
        const Ov = Vv.Z.locals || {};
        var Nv = n(6875);
        var Mv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Mv.insert = "head";
        Mv.singleton = true;
        var Hv = Bc()(Nv.Z, Mv);
        const Wv = Nv.Z.locals || {};

        function qv(t, e = tv) {
            const n = new e(t);
            const i = new sv(t);
            const o = new uv(t, n, i);
            n.bind("isEnabled").to(o);
            if (n instanceof rv) {
                n.arrowView.bind("isOn").to(o, "isOpen")
            } else {
                n.bind("isOn").to(o, "isOpen")
            }
            Gv(o);
            return o
        }

        function jv(t, e, n = {}) {
            const i = t.locale;
            const o = i.t;
            const r = t.toolbarView = new yv(i);
            r.set("ariaLabel", o("Dropdown toolbar"));
            t.extendTemplate({attributes: {class: ["ck-toolbar-dropdown"]}});
            e.map((t => r.items.add(t)));
            if (n.enableActiveItemFocusOnDropdownOpen) {
                Uv(t, (() => r.items.find((t => t.isOn))))
            }
            t.panelView.children.add(r);
            r.items.delegate("execute").to(t)
        }

        function $v(t, e) {
            const n = t.locale;
            const i = t.listView = new Iv(n);
            i.items.bindTo(e).using((t => {
                if (t.type === "separator") {
                    return new zv(n)
                } else if (t.type === "button" || t.type === "switchbutton") {
                    const e = new Rv(n);
                    let i;
                    if (t.type === "button") {
                        i = new LC(n)
                    } else {
                        i = new WC(n)
                    }
                    i.bind(...Object.keys(t.model)).to(t.model);
                    i.delegate("execute").to(e);
                    e.children.add(i);
                    return e
                }
                return null
            }));
            t.panelView.children.add(i);
            i.items.delegate("execute").to(t);
            Uv(t, (() => i.items.find((t => {
                if (t instanceof Rv) {
                    return t.children.first.isOn
                }
                return false
            }))))
        }

        function Uv(t, e) {
            t.on("change:isOpen", (() => {
                if (!t.isOpen) {
                    return
                }
                const n = e();
                if (!n) {
                    return
                }
                if (typeof n.focus === "function") {
                    n.focus()
                } else {
                    I("ui-dropdown-focus-child-on-open-child-missing-focus", {view: n})
                }
            }), {priority: D.low - 10})
        }

        function Gv(t) {
            Kv(t);
            Zv(t);
            Jv(t);
            Yv(t);
            Qv(t);
            Xv(t)
        }

        function Kv(t) {
            t.on("render", (() => {
                vC({
                    emitter: t, activator: () => t.isOpen, callback: () => {
                        t.isOpen = false
                    }, contextElements: [t.element]
                })
            }))
        }

        function Zv(t) {
            t.on("execute", (e => {
                if (e.source instanceof WC) {
                    return
                }
                t.isOpen = false
            }))
        }

        function Jv(t) {
            t.focusTracker.on("change:isFocused", ((e, n, i) => {
                if (t.isOpen && !i) {
                    t.isOpen = false
                }
            }))
        }

        function Yv(t) {
            t.keystrokes.set("arrowdown", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focus();
                    n()
                }
            }));
            t.keystrokes.set("arrowup", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focusLast();
                    n()
                }
            }))
        }

        function Qv(t) {
            t.on("change:isOpen", ((e, n, i) => {
                if (i) {
                    return
                }
                if (t.panelView.element.contains(Xa.document.activeElement)) {
                    t.buttonView.focus()
                }
            }))
        }

        function Xv(t) {
            t.on("change:isOpen", ((e, n, i) => {
                if (!i) {
                    return
                }
                t.panelView.focus()
            }), {priority: "low"})
        }

        var ty = n(4547);
        var ey = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        ey.insert = "head";
        ey.singleton = true;
        var ny = Bc()(ty.Z, ey);
        const iy = ty.Z.locals || {};

        class oy extends pA {
            constructor(t) {
                super(t);
                this.body = new SC(t)
            }

            render() {
                super.render();
                this.body.attachToDom()
            }

            destroy() {
                this.body.detachFromDom();
                return super.destroy()
            }
        }

        var ry = n(2751);
        var sy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        sy.insert = "head";
        sy.singleton = true;
        var ay = Bc()(ry.Z, sy);
        const ly = ry.Z.locals || {};

        class cy extends pA {
            constructor(t) {
                super(t);
                this.set("text", undefined);
                this.set("for", undefined);
                this.id = `ck-editor__label_${E()}`;
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "label",
                    attributes: {class: ["ck", "ck-label"], id: this.id, for: e.to("for")},
                    children: [{text: e.to("text")}]
                })
            }
        }

        class dy extends oy {
            constructor(t) {
                super(t);
                this.top = this.createCollection();
                this.main = this.createCollection();
                this._voiceLabelView = this._createVoiceLabel();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                        role: "application",
                        dir: t.uiLanguageDirection,
                        lang: t.uiLanguage,
                        "aria-labelledby": this._voiceLabelView.id
                    },
                    children: [this._voiceLabelView, {
                        tag: "div",
                        attributes: {class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation"},
                        children: this.top
                    }, {
                        tag: "div",
                        attributes: {class: ["ck", "ck-editor__main"], role: "presentation"},
                        children: this.main
                    }]
                })
            }

            _createVoiceLabel() {
                const t = this.t;
                const e = new cy;
                e.text = t("Rich Text Editor");
                e.extendTemplate({attributes: {class: "ck-voice-label"}});
                return e
            }
        }

        class uy extends pA {
            constructor(t, e, n) {
                super(t);
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                        lang: t.contentLanguage,
                        dir: t.contentLanguageDirection
                    }
                });
                this.name = null;
                this.set("isFocused", false);
                this._editableElement = n;
                this._hasExternalElement = !!this._editableElement;
                this._editingView = e
            }

            render() {
                super.render();
                if (this._hasExternalElement) {
                    this.template.apply(this.element = this._editableElement)
                } else {
                    this._editableElement = this.element
                }
                this.on("change:isFocused", (() => this._updateIsFocusedClasses()));
                this._updateIsFocusedClasses()
            }

            destroy() {
                if (this._hasExternalElement) {
                    this.template.revert(this._editableElement)
                }
                super.destroy()
            }

            _updateIsFocusedClasses() {
                const t = this._editingView;
                if (t.isRenderingInProgress) {
                    n(this)
                } else {
                    e(this)
                }

                function e(e) {
                    t.change((n => {
                        const i = t.document.getRoot(e.name);
                        n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i);
                        n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i)
                    }))
                }

                function n(i) {
                    t.once("change:isRenderingInProgress", ((t, o, r) => {
                        if (!r) {
                            e(i)
                        } else {
                            n(i)
                        }
                    }))
                }
            }
        }

        class hy extends uy {
            constructor(t, e, n, i = {}) {
                super(t, e, n);
                const o = t.t;
                this.extendTemplate({attributes: {role: "textbox", class: "ck-editor__editable_inline"}});
                this._generateLabel = i.label || (() => o("Editor editing area: %0", this.name))
            }

            render() {
                super.render();
                const t = this._editingView;
                t.change((e => {
                    const n = t.document.getRoot(this.name);
                    e.setAttribute("aria-label", this._generateLabel(this), n)
                }))
            }
        }

        var fy = n(5523);
        var gy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        gy.insert = "head";
        gy.singleton = true;
        var my = Bc()(fy.Z, gy);
        const py = fy.Z.locals || {};

        class by extends pA {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("label", e.label || "");
                this.set("class", e.class || null);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-form__header", n.to("class")]},
                    children: this.children
                });
                const i = new pA(t);
                i.setTemplate({
                    tag: "h2",
                    attributes: {class: ["ck", "ck-form__header__label"]},
                    children: [{text: n.to("label")}]
                });
                this.children.add(i)
            }
        }

        var ky = n(6985);
        var wy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        wy.insert = "head";
        wy.singleton = true;
        var _y = Bc()(ky.Z, wy);
        const Ay = ky.Z.locals || {};

        class Cy extends pA {
            constructor(t) {
                super(t);
                this.set("value", undefined);
                this.set("id", undefined);
                this.set("placeholder", undefined);
                this.set("isReadOnly", false);
                this.set("hasError", false);
                this.set("ariaDescribedById", undefined);
                this.focusTracker = new ac;
                this.bind("isFocused").to(this.focusTracker);
                this.set("isEmpty", true);
                this.set("inputMode", "text");
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")],
                        id: e.to("id"),
                        placeholder: e.to("placeholder"),
                        readonly: e.to("isReadOnly"),
                        inputmode: e.to("inputMode"),
                        "aria-invalid": e.if("hasError", true),
                        "aria-describedby": e.to("ariaDescribedById")
                    },
                    on: {
                        input: e.to(((...t) => {
                            this.fire("input", ...t);
                            this._updateIsEmpty()
                        })), change: e.to(this._updateIsEmpty.bind(this))
                    }
                })
            }

            render() {
                super.render();
                this.focusTracker.add(this.element);
                this._setDomElementValue(this.value);
                this._updateIsEmpty();
                this.on("change:value", ((t, e, n) => {
                    this._setDomElementValue(n);
                    this._updateIsEmpty()
                }))
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy()
            }

            select() {
                this.element.select()
            }

            focus() {
                this.element.focus()
            }

            _updateIsEmpty() {
                this.isEmpty = vy(this.element)
            }

            _setDomElementValue(t) {
                this.element.value = !t && t !== 0 ? "" : t
            }
        }

        function vy(t) {
            return !t.value
        }

        class yy extends Cy {
            constructor(t) {
                super(t);
                this.extendTemplate({attributes: {type: "text", class: ["ck-input-text"]}})
            }
        }

        class xy extends Cy {
            constructor(t, {min: e, max: n, step: i} = {}) {
                super(t);
                const o = this.bindTemplate;
                this.set("min", e);
                this.set("max", n);
                this.set("step", i);
                this.extendTemplate({
                    attributes: {
                        type: "number",
                        class: ["ck-input-number"],
                        min: o.to("min"),
                        max: o.to("max"),
                        step: o.to("step")
                    }
                })
            }
        }

        class Ey extends (null && View) {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "iframe",
                    attributes: {class: ["ck", "ck-reset_all"], sandbox: "allow-same-origin allow-scripts"},
                    on: {load: e.to("loaded")}
                })
            }

            render() {
                return new Promise((t => {
                    this.on("loaded", t);
                    return super.render()
                }))
            }
        }

        var Sy = n(8111);
        var Dy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Dy.insert = "head";
        Dy.singleton = true;
        var Ty = Bc()(Sy.Z, Dy);
        const By = Sy.Z.locals || {};

        class Py extends pA {
            constructor(t, e) {
                super(t);
                const n = `ck-labeled-field-view-${E()}`;
                const i = `ck-labeled-field-view-status-${E()}`;
                this.fieldView = e(this, n, i);
                this.set("label", undefined);
                this.set("isEnabled", true);
                this.set("isEmpty", true);
                this.set("isFocused", false);
                this.set("errorText", null);
                this.set("infoText", null);
                this.set("class", undefined);
                this.set("placeholder", undefined);
                this.labelView = this._createLabelView(n);
                this.statusView = this._createStatusView(i);
                this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
                this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e));
                const o = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-labeled-field-view", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t)), o.if("isEmpty", "ck-labeled-field-view_empty"), o.if("isFocused", "ck-labeled-field-view_focused"), o.if("placeholder", "ck-labeled-field-view_placeholder"), o.if("errorText", "ck-error")]},
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck", "ck-labeled-field-view__input-wrapper"]},
                        children: this.fieldWrapperChildren
                    }, this.statusView]
                })
            }

            _createLabelView(t) {
                const e = new cy(this.locale);
                e.for = t;
                e.bind("text").to(this, "label");
                return e
            }

            _createStatusView(t) {
                const e = new pA(this.locale);
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))],
                        id: t,
                        role: n.if("errorText", "alert")
                    },
                    children: [{text: n.to("_statusText")}]
                });
                return e
            }

            focus() {
                this.fieldView.focus()
            }
        }

        function Iy(t, e, n) {
            const i = new yy(t.locale);
            i.set({id: e, ariaDescribedById: n});
            i.bind("isReadOnly").to(t, "isEnabled", (t => !t));
            i.bind("hasError").to(t, "errorText", (t => !!t));
            i.on("input", (() => {
                t.errorText = null
            }));
            t.bind("isEmpty", "isFocused", "placeholder").to(i);
            return i
        }

        function Ry(t, e, n) {
            const i = new xy(t.locale);
            i.set({id: e, ariaDescribedById: n, inputMode: "numeric"});
            i.bind("isReadOnly").to(t, "isEnabled", (t => !t));
            i.bind("hasError").to(t, "errorText", (t => !!t));
            i.on("input", (() => {
                t.errorText = null
            }));
            t.bind("isEmpty", "isFocused", "placeholder").to(i);
            return i
        }

        function zy(t, e, n) {
            const i = qv(t.locale);
            i.set({id: e, ariaDescribedById: n});
            i.bind("isEnabled").to(t);
            return i
        }

        class Vy extends Dc {
            static get pluginName() {
                return "Notification"
            }

            init() {
                this.on("show:warning", ((t, e) => {
                    window.alert(e.message)
                }), {priority: "lowest"})
            }

            showSuccess(t, e = {}) {
                this._showNotification({message: t, type: "success", namespace: e.namespace, title: e.title})
            }

            showInfo(t, e = {}) {
                this._showNotification({message: t, type: "info", namespace: e.namespace, title: e.title})
            }

            showWarning(t, e = {}) {
                this._showNotification({message: t, type: "warning", namespace: e.namespace, title: e.title})
            }

            _showNotification(t) {
                const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`;
                this.fire(e, {message: t.message, type: t.type, title: t.title || ""})
            }
        }

        class Fy extends (dt()) {
            constructor(t, e) {
                super();
                if (e) {
                    Tf(this, e)
                }
                if (t) {
                    this.set(t)
                }
            }
        }

        const Ly = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        const Oy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
        var Ny = n(1757);
        var My = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        My.insert = "head";
        My.singleton = true;
        var Hy = Bc()(Ny.Z, My);
        const Wy = Ny.Z.locals || {};
        var qy = n(3553);
        var jy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        jy.insert = "head";
        jy.singleton = true;
        var $y = Bc()(qy.Z, jy);
        const Uy = qy.Z.locals || {};
        const Gy = hl("px");

        class Ky extends Ac {
            static get pluginName() {
                return "ContextualBalloon"
            }

            constructor(t) {
                super(t);
                this.positionLimiter = () => {
                    const t = this.editor.editing.view;
                    const e = t.document;
                    const n = e.selection.editableElement;
                    if (n) {
                        return t.domConverter.mapViewToDom(n.root)
                    }
                    return null
                };
                this.set("visibleView", null);
                this.view = new vA(t.locale);
                t.ui.view.body.add(this.view);
                t.ui.focusTracker.add(this.view.element);
                this._viewToStack = new Map;
                this._idToStack = new Map;
                this.set("_numberOfStacks", 0);
                this.set("_singleViewMode", false);
                this._rotatorView = this._createRotatorView();
                this._fakePanelsView = this._createFakePanelsView()
            }

            destroy() {
                super.destroy();
                this.view.destroy();
                this._rotatorView.destroy();
                this._fakePanelsView.destroy()
            }

            hasView(t) {
                return Array.from(this._viewToStack.keys()).includes(t)
            }

            add(t) {
                if (this.hasView(t.view)) {
                    throw new P("contextualballoon-add-view-exist", [this, t])
                }
                const e = t.stackId || "main";
                if (!this._idToStack.has(e)) {
                    this._idToStack.set(e, new Map([[t.view, t]]));
                    this._viewToStack.set(t.view, this._idToStack.get(e));
                    this._numberOfStacks = this._idToStack.size;
                    if (!this._visibleStack || t.singleViewMode) {
                        this.showStack(e)
                    }
                    return
                }
                const n = this._idToStack.get(e);
                if (t.singleViewMode) {
                    this.showStack(e)
                }
                n.set(t.view, t);
                this._viewToStack.set(t.view, n);
                if (n === this._visibleStack) {
                    this._showView(t)
                }
            }

            remove(t) {
                if (!this.hasView(t)) {
                    throw new P("contextualballoon-remove-view-not-exist", [this, t])
                }
                const e = this._viewToStack.get(t);
                if (this._singleViewMode && this.visibleView === t) {
                    this._singleViewMode = false
                }
                if (this.visibleView === t) {
                    if (e.size === 1) {
                        if (this._idToStack.size > 1) {
                            this._showNextStack()
                        } else {
                            this.view.hide();
                            this.visibleView = null;
                            this._rotatorView.hideView()
                        }
                    } else {
                        this._showView(Array.from(e.values())[e.size - 2])
                    }
                }
                if (e.size === 1) {
                    this._idToStack.delete(this._getStackId(e));
                    this._numberOfStacks = this._idToStack.size
                } else {
                    e.delete(t)
                }
                this._viewToStack.delete(t)
            }

            updatePosition(t) {
                if (t) {
                    this._visibleStack.get(this.visibleView).position = t
                }
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition()
            }

            showStack(t) {
                this.visibleStack = t;
                const e = this._idToStack.get(t);
                if (!e) {
                    throw new P("contextualballoon-showstack-stack-not-exist", this)
                }
                if (this._visibleStack === e) {
                    return
                }
                this._showView(Array.from(e.values()).pop())
            }

            get _visibleStack() {
                return this._viewToStack.get(this.visibleView)
            }

            _getStackId(t) {
                const e = Array.from(this._idToStack.entries()).find((e => e[1] === t));
                return e[0]
            }

            _showNextStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) + 1;
                if (!t[e]) {
                    e = 0
                }
                this.showStack(this._getStackId(t[e]))
            }

            _showPrevStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) - 1;
                if (!t[e]) {
                    e = t.length - 1
                }
                this.showStack(this._getStackId(t[e]))
            }

            _createRotatorView() {
                const t = new Zy(this.editor.locale);
                const e = this.editor.locale.t;
                this.view.content.add(t);
                t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1));
                t.on("change:isNavigationVisible", (() => this.updatePosition()), {priority: "low"});
                t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => {
                    if (n < 2) {
                        return ""
                    }
                    const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                    return e("%0 of %1", [i, n])
                }));
                t.buttonNextView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showNextStack()
                }));
                t.buttonPrevView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showPrevStack()
                }));
                return t
            }

            _createFakePanelsView() {
                const t = new Jy(this.editor.locale, this.view);
                t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => {
                    const n = !e && t >= 2;
                    return n ? Math.min(t - 1, 2) : 0
                }));
                t.listenTo(this.view, "change:top", (() => t.updatePosition()));
                t.listenTo(this.view, "change:left", (() => t.updatePosition()));
                this.editor.ui.view.body.add(t);
                return t
            }

            _showView({view: t, balloonClassName: e = "", withArrow: n = true, singleViewMode: i = false}) {
                this.view.class = e;
                this.view.withArrow = n;
                this._rotatorView.showView(t);
                this.visibleView = t;
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition();
                if (i) {
                    this._singleViewMode = true
                }
            }

            _getBalloonPosition() {
                let t = Array.from(this._visibleStack.values()).pop().position;
                if (t) {
                    if (!t.limiter) {
                        t = Object.assign({}, t, {limiter: this.positionLimiter})
                    }
                    t = Object.assign({}, t, {viewportOffsetConfig: this.editor.ui.viewportOffset})
                }
                return t
            }
        }

        class Zy extends pA {
            constructor(t) {
                super(t);
                const e = t.t;
                const n = this.bindTemplate;
                this.set("isNavigationVisible", true);
                this.focusTracker = new ac;
                this.buttonPrevView = this._createButtonView(e("Previous"), Ly);
                this.buttonNextView = this._createButtonView(e("Next"), Oy);
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-balloon-rotator"], "z-index": "-1"},
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))]},
                        children: [this.buttonPrevView, {
                            tag: "span",
                            attributes: {class: ["ck-balloon-rotator__counter"]},
                            children: [{text: n.to("counter")}]
                        }, this.buttonNextView]
                    }, {tag: "div", attributes: {class: "ck-balloon-rotator__content"}, children: this.content}]
                })
            }

            render() {
                super.render();
                this.focusTracker.add(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy()
            }

            showView(t) {
                this.hideView();
                this.content.add(t)
            }

            hideView() {
                this.content.clear()
            }

            _createButtonView(t, e) {
                const n = new LC(this.locale);
                n.set({label: t, icon: e, tooltip: true});
                return n
            }
        }

        class Jy extends pA {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("height", 0);
                this.set("width", 0);
                this.set("numberOfPanels", 0);
                this.content = this.createCollection();
                this._balloonPanelView = e;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))],
                        style: {
                            top: n.to("top", Gy),
                            left: n.to("left", Gy),
                            width: n.to("width", Gy),
                            height: n.to("height", Gy)
                        }
                    },
                    children: this.content
                });
                this.on("change:numberOfPanels", ((t, e, n, i) => {
                    if (n > i) {
                        this._addPanels(n - i)
                    } else {
                        this._removePanels(i - n)
                    }
                    this.updatePosition()
                }))
            }

            _addPanels(t) {
                while (t--) {
                    const t = new pA;
                    t.setTemplate({tag: "div"});
                    this.content.add(t);
                    this.registerChild(t)
                }
            }

            _removePanels(t) {
                while (t--) {
                    const t = this.content.last;
                    this.content.remove(t);
                    this.deregisterChild(t);
                    t.destroy()
                }
            }

            updatePosition() {
                if (this.numberOfPanels) {
                    const {top: t, left: e} = this._balloonPanelView;
                    const {width: n, height: i} = new sl(this._balloonPanelView.element);
                    Object.assign(this, {top: t, left: e, width: n, height: i})
                }
            }
        }

        var Yy = n(3609);
        var Qy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Qy.insert = "head";
        Qy.singleton = true;
        var Xy = Bc()(Yy.Z, Qy);
        const tx = Yy.Z.locals || {};
        const ex = hl("px");

        class nx extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isActive", false);
                this.set("isSticky", false);
                this.set("limiterElement", null);
                this.set("limiterBottomOffset", 50);
                this.set("viewportTopOffset", 0);
                this.set("_marginLeft", null);
                this.set("_isStickyToTheLimiter", false);
                this.set("_hasViewportTopOffset", false);
                this.content = this.createCollection();
                this._contentPanelPlaceholder = new N_({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__placeholder"],
                        style: {
                            display: e.to("isSticky", (t => t ? "block" : "none")),
                            height: e.to("isSticky", (t => t ? ex(this._panelRect.height) : null))
                        }
                    }
                }).render();
                this._contentPanel = new N_({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                        style: {
                            width: e.to("isSticky", (t => t ? ex(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)),
                            top: e.to("_hasViewportTopOffset", (t => t ? ex(this.viewportTopOffset) : null)),
                            bottom: e.to("_isStickyToTheLimiter", (t => t ? ex(this.limiterBottomOffset) : null)),
                            marginLeft: e.to("_marginLeft")
                        }
                    },
                    children: this.content
                }).render();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-sticky-panel"]},
                    children: [this._contentPanelPlaceholder, this._contentPanel]
                })
            }

            render() {
                super.render();
                this._checkIfShouldBeSticky();
                this.listenTo(Xa.window, "scroll", (() => {
                    this._checkIfShouldBeSticky()
                }));
                this.listenTo(this, "change:isActive", (() => {
                    this._checkIfShouldBeSticky()
                }))
            }

            _checkIfShouldBeSticky() {
                const t = this._panelRect = this._contentPanel.getBoundingClientRect();
                let e;
                if (!this.limiterElement) {
                    this.isSticky = false
                } else {
                    e = this._limiterRect = this.limiterElement.getBoundingClientRect();
                    this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height
                }
                if (this.isSticky) {
                    this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset;
                    this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
                    this._marginLeft = this._isStickyToTheLimiter ? null : ex(-Xa.window.scrollX)
                } else {
                    this._isStickyToTheLimiter = false;
                    this._hasViewportTopOffset = false;
                    this._marginLeft = null
                }
            }
        }

        const ix = hl("px");

        class ox extends (null && Plugin) {
            static get pluginName() {
                return "BalloonToolbar"
            }

            static get requires() {
                return [ContextualBalloon]
            }

            constructor(t) {
                super(t);
                this._balloonConfig = normalizeToolbarConfig(t.config.get("balloonToolbar"));
                this.toolbarView = this._createToolbarView();
                this.focusTracker = new FocusTracker;
                t.ui.once("ready", (() => {
                    this.focusTracker.add(t.ui.getEditableElement());
                    this.focusTracker.add(this.toolbarView.element)
                }));
                t.ui.addToolbar(this.toolbarView, {
                    beforeFocus: () => this.show(true),
                    afterBlur: () => this.hide(),
                    isContextual: true
                });
                this._resizeObserver = null;
                this._balloon = t.plugins.get(ContextualBalloon);
                this._fireSelectionChangeDebounced = debounce((() => this.fire("_selectionChangeDebounced")), 200);
                this.decorate("show")
            }

            init() {
                const t = this.editor;
                const e = t.model.document.selection;
                this.listenTo(this.focusTracker, "change:isFocused", ((t, e, n) => {
                    const i = this._balloon.visibleView === this.toolbarView;
                    if (!n && i) {
                        this.hide()
                    } else if (n) {
                        this.show()
                    }
                }));
                this.listenTo(e, "change:range", ((t, n) => {
                    if (n.directChange || e.isCollapsed) {
                        this.hide()
                    }
                    this._fireSelectionChangeDebounced()
                }));
                this.listenTo(this, "_selectionChangeDebounced", (() => {
                    if (this.editor.editing.view.document.isFocused) {
                        this.show()
                    }
                }));
                if (!this._balloonConfig.shouldNotGroupWhenFull) {
                    this.listenTo(t, "ready", (() => {
                        const e = t.ui.view.editable.element;
                        this._resizeObserver = new ResizeObserver(e, (() => {
                            this.toolbarView.maxWidth = ix(new Rect(e).width * .9)
                        }))
                    }))
                }
                this.listenTo(this.toolbarView, "groupedItemsUpdate", (() => {
                    this._updatePosition()
                }))
            }

            afterInit() {
                const t = this.editor.ui.componentFactory;
                this.toolbarView.fillFromConfig(this._balloonConfig, t)
            }

            _createToolbarView() {
                const t = this.editor.locale.t;
                const e = !this._balloonConfig.shouldNotGroupWhenFull;
                const n = new ToolbarView(this.editor.locale, {shouldGroupWhenFull: e, isFloating: true});
                n.ariaLabel = t("Editor contextual toolbar");
                n.render();
                return n
            }

            show(t = false) {
                const e = this.editor;
                const n = e.model.document.selection;
                const i = e.model.schema;
                if (this._balloon.hasView(this.toolbarView)) {
                    return
                }
                if (n.isCollapsed && !t) {
                    return
                }
                if (rx(n, i)) {
                    return
                }
                if (Array.from(this.toolbarView.items).every((t => t.isEnabled !== undefined && !t.isEnabled))) {
                    return
                }
                this.listenTo(this.editor.ui, "update", (() => {
                    this._updatePosition()
                }));
                this._balloon.add({
                    view: this.toolbarView,
                    position: this._getBalloonPositionData(),
                    balloonClassName: "ck-toolbar-container"
                })
            }

            hide() {
                if (this._balloon.hasView(this.toolbarView)) {
                    this.stopListening(this.editor.ui, "update");
                    this._balloon.remove(this.toolbarView)
                }
            }

            _getBalloonPositionData() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                const i = n.selection;
                const o = n.selection.isBackward;
                return {
                    target: () => {
                        const t = o ? i.getFirstRange() : i.getLastRange();
                        const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t));
                        if (o) {
                            return n[0]
                        } else {
                            if (n.length > 1 && n[n.length - 1].width === 0) {
                                n.pop()
                            }
                            return n[n.length - 1]
                        }
                    }, positions: this._getBalloonPositions(o)
                }
            }

            _updatePosition() {
                this._balloon.updatePosition(this._getBalloonPositionData())
            }

            destroy() {
                super.destroy();
                this.stopListening();
                this._fireSelectionChangeDebounced.cancel();
                this.toolbarView.destroy();
                this.focusTracker.destroy();
                if (this._resizeObserver) {
                    this._resizeObserver.destroy()
                }
            }

            _getBalloonPositions(t) {
                const e = env.isSafari && env.isiOS;
                const n = e ? generatePositions({heightOffset: Math.max(BalloonPanelView.arrowHeightOffset, Math.round(20 / global.window.visualViewport.scale))}) : BalloonPanelView.defaultPositions;
                return t ? [n.northWestArrowSouth, n.northWestArrowSouthWest, n.northWestArrowSouthEast, n.northWestArrowSouthMiddleEast, n.northWestArrowSouthMiddleWest, n.southWestArrowNorth, n.southWestArrowNorthWest, n.southWestArrowNorthEast, n.southWestArrowNorthMiddleWest, n.southWestArrowNorthMiddleEast] : [n.southEastArrowNorth, n.southEastArrowNorthEast, n.southEastArrowNorthWest, n.southEastArrowNorthMiddleEast, n.southEastArrowNorthMiddleWest, n.northEastArrowSouth, n.northEastArrowSouthEast, n.northEastArrowSouthWest, n.northEastArrowSouthMiddleEast, n.northEastArrowSouthMiddleWest]
            }
        }

        function rx(t, e) {
            if (t.rangeCount === 1) {
                return false
            }
            return [...t.getRanges()].every((t => {
                const n = t.getContainedElement();
                return n && e.isSelectable(n)
            }))
        }

        var sx = n(6706);
        var ax = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        ax.insert = "head";
        ax.singleton = true;
        var lx = Bc()(sx.Z, ax);
        const cx = sx.Z.locals || {};
        const dx = hl("px");

        class ux extends (null && ButtonView) {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.isVisible = false;
                this.isToggleable = true;
                this.set("top", 0);
                this.set("left", 0);
                this.extendTemplate({
                    attributes: {
                        class: "ck-block-toolbar-button",
                        style: {top: e.to("top", (t => dx(t))), left: e.to("left", (t => dx(t)))}
                    }
                })
            }
        }

        const hx = hl("px");
        const {pilcrow: fx} = CC;

        class gx extends (null && Plugin) {
            static get pluginName() {
                return "BlockToolbar"
            }

            constructor(t) {
                super(t);
                this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar"));
                this.toolbarView = this._createToolbarView();
                this.panelView = this._createPanelView();
                this.buttonView = this._createButtonView();
                this._resizeObserver = null;
                clickOutsideHandler({
                    emitter: this.panelView,
                    contextElements: [this.panelView.element, this.buttonView.element],
                    activator: () => this.panelView.isVisible,
                    callback: () => this._hidePanel()
                })
            }

            init() {
                const t = this.editor;
                this.listenTo(t.model.document.selection, "change:range", ((t, e) => {
                    if (e.directChange) {
                        this._hidePanel()
                    }
                }));
                this.listenTo(t.ui, "update", (() => this._updateButton()));
                this.listenTo(t, "change:isReadOnly", (() => this._updateButton()), {priority: "low"});
                this.listenTo(t.ui.focusTracker, "change:isFocused", (() => this._updateButton()));
                this.listenTo(this.buttonView, "change:isVisible", ((t, e, n) => {
                    if (n) {
                        this.buttonView.listenTo(window, "resize", (() => this._updateButton()))
                    } else {
                        this.buttonView.stopListening(window, "resize");
                        this._hidePanel()
                    }
                }));
                t.ui.addToolbar(this.toolbarView, {
                    beforeFocus: () => this._showPanel(),
                    afterBlur: () => this._hidePanel()
                })
            }

            afterInit() {
                const t = this.editor.ui.componentFactory;
                const e = this._blockToolbarConfig;
                this.toolbarView.fillFromConfig(e, t);
                for (const t of this.toolbarView.items) {
                    t.on("execute", (() => this._hidePanel(true)), {priority: "high"})
                }
                if (!e.shouldNotGroupWhenFull) {
                    this.listenTo(this.editor, "ready", (() => {
                        const t = this.editor.ui.view.editable.element;
                        this._resizeObserver = new ResizeObserver(t, (() => {
                            this.toolbarView.maxWidth = this._getToolbarMaxWidth()
                        }))
                    }))
                }
            }

            destroy() {
                super.destroy();
                this.panelView.destroy();
                this.buttonView.destroy();
                this.toolbarView.destroy();
                if (this._resizeObserver) {
                    this._resizeObserver.destroy()
                }
            }

            _createToolbarView() {
                const t = this.editor.locale.t;
                const e = !this._blockToolbarConfig.shouldNotGroupWhenFull;
                const n = new ToolbarView(this.editor.locale, {shouldGroupWhenFull: e, isFloating: true});
                n.ariaLabel = t("Editor block content toolbar");
                n.focusTracker.on("change:isFocused", ((t, e, n) => {
                    if (!n) {
                        this._hidePanel()
                    }
                }));
                return n
            }

            _createPanelView() {
                const t = this.editor;
                const e = new BalloonPanelView(t.locale);
                e.content.add(this.toolbarView);
                e.class = "ck-toolbar-container";
                t.ui.view.body.add(e);
                t.ui.focusTracker.add(e.element);
                this.toolbarView.keystrokes.set("Esc", ((t, e) => {
                    this._hidePanel(true);
                    e()
                }));
                return e
            }

            _createButtonView() {
                const t = this.editor;
                const e = t.t;
                const n = new BlockButtonView(t.locale);
                const i = n.bindTemplate;
                n.set({label: e("Edit block"), icon: fx, withText: false});
                n.extendTemplate({
                    on: {
                        mousedown: i.to((t => {
                            if (env.isSafari && this.panelView.isVisible) {
                                this.toolbarView.focus()
                            }
                            t.preventDefault()
                        }))
                    }
                });
                n.bind("isOn").to(this.panelView, "isVisible");
                n.bind("tooltip").to(this.panelView, "isVisible", (t => !t));
                this.listenTo(n, "execute", (() => {
                    if (!this.panelView.isVisible) {
                        this._showPanel()
                    } else {
                        this._hidePanel(true)
                    }
                }));
                t.ui.view.body.add(n);
                t.ui.focusTracker.add(n.element);
                return n
            }

            _updateButton() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                if (!t.ui.focusTracker.isFocused) {
                    this._hideButton();
                    return
                }
                if (t.isReadOnly) {
                    this._hideButton();
                    return
                }
                const i = Array.from(e.document.selection.getSelectedBlocks())[0];
                if (!i || Array.from(this.toolbarView.items).every((t => !t.isEnabled))) {
                    this._hideButton();
                    return
                }
                const o = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(i));
                this.buttonView.isVisible = true;
                this._attachButtonToElement(o);
                if (this.panelView.isVisible) {
                    this._showPanel()
                }
            }

            _hideButton() {
                this.buttonView.isVisible = false
            }

            _showPanel() {
                if (!this.buttonView.isVisible) {
                    return
                }
                const t = this.panelView.isVisible;
                this.panelView.show();
                this.toolbarView.maxWidth = this._getToolbarMaxWidth();
                this.panelView.pin({target: this.buttonView.element, limiter: this.editor.ui.getEditableElement()});
                if (!t) {
                    this.toolbarView.items.get(0).focus()
                }
            }

            _hidePanel(t) {
                this.panelView.isVisible = false;
                if (t) {
                    this.editor.editing.view.focus()
                }
            }

            _attachButtonToElement(t) {
                const e = window.getComputedStyle(t);
                const n = new Rect(this.editor.ui.getEditableElement());
                const i = parseInt(e.paddingTop, 10);
                const o = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2;
                const r = getOptimalPosition({
                    element: this.buttonView.element, target: t, positions: [(t, e) => {
                        let r;
                        if (this.editor.locale.uiLanguageDirection === "ltr") {
                            r = n.left - e.width
                        } else {
                            r = n.right
                        }
                        return {top: t.top + i + (o - e.height) / 2, left: r}
                    }]
                });
                this.buttonView.top = r.top;
                this.buttonView.left = r.left
            }

            _getToolbarMaxWidth() {
                const t = this.editor.ui.view.editable.element;
                const e = new Rect(t);
                const n = new Rect(this.buttonView.element);
                const i = this.editor.locale.uiLanguageDirection === "rtl";
                const o = i ? n.left - e.right + n.width : e.left - n.left;
                return hx(e.width + o)
            }
        }

        class mx extends zA {
            constructor(t, e) {
                super(t);
                this.view = e;
                this._toolbarConfig = bv(t.config.get("toolbar"));
                this._elementReplacer = new At
            }

            get element() {
                return this.view.element
            }

            init(t) {
                const e = this.editor;
                const n = this.view;
                const i = e.editing.view;
                const o = n.editable;
                const r = i.document.getRoot();
                o.name = r.rootName;
                n.render();
                const s = o.element;
                this.setEditableElement(o.name, s);
                n.editable.bind("isFocused").to(this.focusTracker);
                i.attachDomRoot(s);
                if (t) {
                    this._elementReplacer.replace(t, this.element)
                }
                this._initPlaceholder();
                this._initToolbar();
                this.fire("ready")
            }

            destroy() {
                super.destroy();
                const t = this.view;
                const e = this.editor.editing.view;
                this._elementReplacer.restore();
                e.detachDomRoot(t.editable.name);
                t.destroy()
            }

            _initToolbar() {
                const t = this.view;
                t.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
                t.stickyPanel.limiterElement = t.element;
                t.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", (({top: t}) => t || 0));
                t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
                this.addToolbar(t.toolbar)
            }

            _initPlaceholder() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document.getRoot();
                const i = t.sourceElement;
                const o = t.config.get("placeholder") || i && i.tagName.toLowerCase() === "textarea" && i.getAttribute("placeholder");
                if (o) {
                    Fc({view: e, element: n, text: o, isDirectHost: false, keepOnFocus: true})
                }
            }
        }

        var px = n(3638);
        var bx = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        bx.insert = "head";
        bx.singleton = true;
        var kx = Bc()(px.Z, bx);
        const wx = px.Z.locals || {};

        class _x extends dy {
            constructor(t, e, n = {}) {
                super(t);
                this.stickyPanel = new nx(t);
                this.toolbar = new yv(t, {shouldGroupWhenFull: n.shouldToolbarGroupWhenFull});
                this.editable = new hy(t, e)
            }

            render() {
                super.render();
                this.stickyPanel.content.add(this.toolbar);
                this.top.add(this.stickyPanel);
                this.main.add(this.editable)
            }
        }

        class Ax extends (OA(NA(R_))) {
            constructor(t, e = {}) {
                if (!vx(t) && e.initialData !== undefined) {
                    throw new P("editor-create-initial-data", null)
                }
                super(e);
                if (this.config.get("initialData") === undefined) {
                    this.config.set("initialData", Cx(t))
                }
                if (vx(t)) {
                    this.sourceElement = t
                }
                this.model.document.createRoot();
                const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
                const i = new _x(this.locale, this.editing.view, {shouldToolbarGroupWhenFull: n});
                this.ui = new mx(this, i);
                FA(this)
            }

            destroy() {
                if (this.sourceElement) {
                    this.updateSourceElement()
                }
                this.ui.destroy();
                return super.destroy()
            }

            static create(t, e = {}) {
                return new Promise((n => {
                    const i = new this(t, e);
                    n(i.initPlugins().then((() => i.ui.init(vx(t) ? t : null))).then((() => i.data.init(i.config.get("initialData")))).then((() => i.fire("ready"))).then((() => i)))
                }))
            }
        }

        function Cx(t) {
            return vx(t) ? el(t) : t
        }

        function vx(t) {
            return Ha(t)
        }

        const yx = ["left", "right", "center", "justify"];

        function xx(t) {
            return yx.includes(t)
        }

        function Ex(t, e) {
            if (e.contentLanguageDirection == "rtl") {
                return t === "right"
            } else {
                return t === "left"
            }
        }

        function Sx(t) {
            const e = t.map((t => {
                let e;
                if (typeof t == "string") {
                    e = {name: t}
                } else {
                    e = t
                }
                return e
            })).filter((t => {
                const e = !!yx.includes(t.name);
                if (!e) {
                    I("alignment-config-name-not-recognized", {option: t})
                }
                return e
            }));
            const n = e.filter((t => !!t.className)).length;
            if (n && n < e.length) {
                throw new P("alignment-config-classnames-are-missing", {configuredOptions: t})
            }
            e.forEach(((e, n, i) => {
                const o = i.slice(n + 1);
                const r = o.some((t => t.name == e.name));
                if (r) {
                    throw new P("alignment-config-name-already-defined", {option: e, configuredOptions: t})
                }
                if (e.className) {
                    const n = o.some((t => t.className == e.className));
                    if (n) {
                        throw new P("alignment-config-classname-already-defined", {option: e, configuredOptions: t})
                    }
                }
            }));
            return e
        }

        const Dx = "alignment";

        class Tx extends vc {
            refresh() {
                const t = this.editor;
                const e = t.locale;
                const n = sc(this.editor.model.document.selection.getSelectedBlocks());
                this.isEnabled = !!n && this._canBeAligned(n);
                if (this.isEnabled && n.hasAttribute("alignment")) {
                    this.value = n.getAttribute("alignment")
                } else {
                    this.value = e.contentLanguageDirection === "rtl" ? "right" : "left"
                }
            }

            execute(t = {}) {
                const e = this.editor;
                const n = e.locale;
                const i = e.model;
                const o = i.document;
                const r = t.value;
                i.change((t => {
                    const e = Array.from(o.selection.getSelectedBlocks()).filter((t => this._canBeAligned(t)));
                    const i = e[0].getAttribute("alignment");
                    const s = Ex(r, n) || i === r || !r;
                    if (s) {
                        Bx(e, t)
                    } else {
                        Px(e, t, r)
                    }
                }))
            }

            _canBeAligned(t) {
                return this.editor.model.schema.checkAttribute(t, Dx)
            }
        }

        function Bx(t, e) {
            for (const n of t) {
                e.removeAttribute(Dx, n)
            }
        }

        function Px(t, e, n) {
            for (const i of t) {
                e.setAttribute(Dx, n, i)
            }
        }

        class Ix extends Ac {
            static get pluginName() {
                return "AlignmentEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("alignment", {options: [...yx.map((t => ({name: t})))]})
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.model.schema;
                const i = Sx(t.config.get("alignment.options"));
                const o = i.filter((t => xx(t.name) && !Ex(t.name, e)));
                const r = o.some((t => !!t.className));
                n.extend("$block", {allowAttributes: "alignment"});
                t.model.schema.setAttributeProperties("alignment", {isFormatting: true});
                if (r) {
                    t.conversion.attributeToAttribute(Fx(o))
                } else {
                    t.conversion.for("downcast").attributeToAttribute(Rx(o))
                }
                const s = zx(o);
                for (const e of s) {
                    t.conversion.for("upcast").attributeToAttribute(e)
                }
                const a = Vx(o);
                for (const e of a) {
                    t.conversion.for("upcast").attributeToAttribute(e)
                }
                t.commands.add("alignment", new Tx(t))
            }
        }

        function Rx(t) {
            const e = {model: {key: "alignment", values: t.map((t => t.name))}, view: {}};
            for (const {name: n} of t) {
                e.view[n] = {key: "style", value: {"text-align": n}}
            }
            return e
        }

        function zx(t) {
            const e = [];
            for (const {name: n} of t) {
                e.push({view: {key: "style", value: {"text-align": n}}, model: {key: "alignment", value: n}})
            }
            return e
        }

        function Vx(t) {
            const e = [];
            for (const {name: n} of t) {
                e.push({view: {key: "align", value: n}, model: {key: "alignment", value: n}})
            }
            return e
        }

        function Fx(t) {
            const e = {model: {key: "alignment", values: t.map((t => t.name))}, view: {}};
            for (const n of t) {
                e.view[n.name] = {key: "class", value: n.className}
            }
            return e
        }

        const Lx = new Map([["left", CC.alignLeft], ["right", CC.alignRight], ["center", CC.alignCenter], ["justify", CC.alignJustify]]);

        class Ox extends Ac {
            get localizedOptionTitles() {
                const t = this.editor.t;
                return {
                    left: t("Align left"),
                    right: t("Align right"),
                    center: t("Align center"),
                    justify: t("Justify")
                }
            }

            static get pluginName() {
                return "AlignmentUI"
            }

            init() {
                const t = this.editor;
                const e = t.ui.componentFactory;
                const n = t.t;
                const i = Sx(t.config.get("alignment.options"));
                i.map((t => t.name)).filter(xx).forEach((t => this._addButton(t)));
                e.add("alignment", (o => {
                    const r = qv(o);
                    const s = i.map((t => e.create(`alignment:${t.name}`)));
                    jv(r, s, {enableActiveItemFocusOnDropdownOpen: true});
                    r.buttonView.set({label: n("Text alignment"), tooltip: true});
                    r.toolbarView.isVertical = true;
                    r.toolbarView.ariaLabel = n("Text alignment toolbar");
                    r.extendTemplate({attributes: {class: "ck-alignment-dropdown"}});
                    const a = o.contentLanguageDirection === "rtl" ? Lx.get("right") : Lx.get("left");
                    r.buttonView.bind("icon").toMany(s, "isOn", ((...t) => {
                        const e = t.findIndex((t => t));
                        if (e < 0) {
                            return a
                        }
                        return s[e].icon
                    }));
                    r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t))));
                    this.listenTo(r, "execute", (() => {
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }

            _addButton(t) {
                const e = this.editor;
                e.ui.componentFactory.add(`alignment:${t}`, (n => {
                    const i = e.commands.get("alignment");
                    const o = new LC(n);
                    o.set({label: this.localizedOptionTitles[t], icon: Lx.get(t), tooltip: true, isToggleable: true});
                    o.bind("isEnabled").to(i);
                    o.bind("isOn").to(i, "value", (e => e === t));
                    this.listenTo(o, "execute", (() => {
                        e.execute("alignment", {value: t});
                        e.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class Nx extends Ac {
            static get requires() {
                return [Ix, Ox]
            }

            static get pluginName() {
                return "Alignment"
            }
        }

        class Mx {
            constructor(t, e = 20) {
                this._batch = null;
                this.model = t;
                this._size = 0;
                this.limit = e;
                this._isLocked = false;
                this._changeCallback = (t, e) => {
                    if (e.isLocal && e.isUndoable && e !== this._batch) {
                        this._reset(true)
                    }
                };
                this._selectionChangeCallback = () => {
                    this._reset()
                };
                this.model.document.on("change", this._changeCallback);
                this.model.document.selection.on("change:range", this._selectionChangeCallback);
                this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
            }

            get batch() {
                if (!this._batch) {
                    this._batch = this.model.createBatch({isTyping: true})
                }
                return this._batch
            }

            get size() {
                return this._size
            }

            input(t) {
                this._size += t;
                if (this._size >= this.limit) {
                    this._reset(true)
                }
            }

            get isLocked() {
                return this._isLocked
            }

            lock() {
                this._isLocked = true
            }

            unlock() {
                this._isLocked = false
            }

            destroy() {
                this.model.document.off("change", this._changeCallback);
                this.model.document.selection.off("change:range", this._selectionChangeCallback);
                this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
            }

            _reset(t = false) {
                if (!this.isLocked || t) {
                    this._batch = null;
                    this._size = 0
                }
            }
        }

        class Hx extends vc {
            constructor(t, e) {
                super(t);
                this._buffer = new Mx(t.model, e)
            }

            get buffer() {
                return this._buffer
            }

            destroy() {
                super.destroy();
                this._buffer.destroy()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = t.text || "";
                const o = i.length;
                let r = n.selection;
                if (t.selection) {
                    r = t.selection
                } else if (t.range) {
                    r = e.createSelection(t.range)
                }
                const s = t.resultRange;
                e.enqueueChange(this._buffer.batch, (t => {
                    this._buffer.lock();
                    e.deleteContent(r);
                    if (i) {
                        e.insertContent(t.createText(i, n.selection.getAttributes()), r)
                    }
                    if (s) {
                        t.setSelection(s)
                    } else if (!r.is("documentSelection")) {
                        t.setSelection(r)
                    }
                    this._buffer.unlock();
                    this._buffer.input(o)
                }))
            }
        }

        const Wx = ["insertText", "insertReplacementText"];

        class qx extends Sf {
            constructor(t) {
                super(t);
                if (r.isAndroid) {
                    Wx.push("insertCompositionText")
                }
                const e = t.document;
                e.on("beforeinput", ((n, i) => {
                    if (!this.isEnabled) {
                        return
                    }
                    const {data: o, targetRanges: r, inputType: s, domEvent: a} = i;
                    if (!Wx.includes(s)) {
                        return
                    }
                    const l = new y(e, "insertText");
                    e.fire(l, new Bf(t, a, {text: o, selection: t.createSelection(r)}));
                    if (l.stop.called) {
                        n.stop()
                    }
                }));
                e.on("compositionend", ((n, {data: i, domEvent: o}) => {
                    if (!this.isEnabled || r.isAndroid) {
                        return
                    }
                    if (!i) {
                        return
                    }
                    e.fire("insertText", new Bf(t, o, {text: i, selection: e.selection}))
                }), {priority: "lowest"})
            }

            observe() {
            }
        }

        class jx extends Ac {
            static get pluginName() {
                return "Input"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = e.document.selection;
                n.addObserver(qx);
                const o = new Hx(t, t.config.get("typing.undoStep") || 20);
                t.commands.add("insertText", o);
                t.commands.add("input", o);
                this.listenTo(n.document, "insertText", ((i, o) => {
                    if (!n.document.isComposing) {
                        o.preventDefault()
                    }
                    const {text: s, selection: a, resultRange: l} = o;
                    const c = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                    let d = s;
                    if (r.isAndroid) {
                        const t = Array.from(c[0].getItems()).reduce(((t, e) => t + (e.is("$textProxy") ? e.data : "")), "");
                        if (t) {
                            if (t.length <= d.length) {
                                if (d.startsWith(t)) {
                                    d = d.substring(t.length);
                                    c[0].start = c[0].start.getShiftedBy(t.length)
                                }
                            } else {
                                if (t.startsWith(d)) {
                                    c[0].start = c[0].start.getShiftedBy(d.length);
                                    d = ""
                                }
                            }
                        }
                    }
                    const u = {text: d, selection: e.createSelection(c)};
                    if (l) {
                        u.resultRange = t.editing.mapper.toModelRange(l)
                    }
                    t.execute("insertText", u)
                }));
                if (r.isAndroid) {
                    this.listenTo(n.document, "keydown", ((t, r) => {
                        if (i.isCollapsed || r.keyCode != 229 || !n.document.isComposing) {
                            return
                        }
                        $x(e, o)
                    }))
                } else {
                    this.listenTo(n.document, "compositionstart", (() => {
                        if (i.isCollapsed) {
                            return
                        }
                        $x(e, o)
                    }))
                }
            }
        }

        function $x(t, e) {
            if (!e.isEnabled) {
                return
            }
            const n = e.buffer;
            n.lock();
            t.enqueueChange(n.batch, (() => {
                t.deleteContent(t.document.selection)
            }));
            n.unlock()
        }

        class Ux extends vc {
            constructor(t, e) {
                super(t);
                this.direction = e;
                this._buffer = new Mx(t.model, t.config.get("typing.undoStep"))
            }

            get buffer() {
                return this._buffer
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.enqueueChange(this._buffer.batch, (i => {
                    this._buffer.lock();
                    const o = i.createSelection(t.selection || n.selection);
                    const r = t.sequence || 1;
                    const s = o.isCollapsed;
                    if (o.isCollapsed) {
                        e.modifySelection(o, {direction: this.direction, unit: t.unit, treatEmojiAsSingleUnit: true})
                    }
                    if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
                        this._replaceEntireContentWithParagraph(i);
                        return
                    }
                    if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
                        this.editor.execute("paragraph", {selection: o});
                        return
                    }
                    if (o.isCollapsed) {
                        return
                    }
                    let a = 0;
                    o.getFirstRange().getMinimalFlatRanges().forEach((t => {
                        a += Ct(t.getWalker({singleCharacters: true, ignoreElementEnd: true, shallow: true}))
                    }));
                    e.deleteContent(o, {doNotResetEntireContent: s, direction: this.direction});
                    this._buffer.input(a);
                    i.setSelection(o);
                    this._buffer.unlock()
                }))
            }

            _shouldEntireContentBeReplacedWithParagraph(t) {
                if (t > 1) {
                    return false
                }
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = e.schema.getLimitElement(i);
                const r = i.isCollapsed && i.containsEntireContent(o);
                if (!r) {
                    return false
                }
                if (!e.schema.checkChild(o, "paragraph")) {
                    return false
                }
                const s = o.getChild(0);
                if (s && s.is("element", "paragraph")) {
                    return false
                }
                return true
            }

            _replaceEntireContentWithParagraph(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = e.schema.getLimitElement(i);
                const r = t.createElement("paragraph");
                t.remove(t.createRangeIn(o));
                t.insert(r, o);
                t.setSelection(r, 0)
            }

            _shouldReplaceFirstBlockWithParagraph(t, e) {
                const n = this.editor.model;
                if (e > 1 || this.direction != "backward") {
                    return false
                }
                if (!t.isCollapsed) {
                    return false
                }
                const i = t.getFirstPosition();
                const o = n.schema.getLimitElement(i);
                const r = o.getChild(0);
                if (i.parent != r) {
                    return false
                }
                if (!t.containsEntireContent(r)) {
                    return false
                }
                if (!n.schema.checkChild(o, "paragraph")) {
                    return false
                }
                if (r.name == "paragraph") {
                    return false
                }
                return true
            }
        }

        const Gx = "character";
        const Kx = "word";
        const Zx = "codePoint";
        const Jx = "selection";
        const Yx = "backward";
        const Qx = "forward";
        const Xx = {
            deleteContent: {unit: Jx, direction: Yx},
            deleteContentBackward: {unit: Zx, direction: Yx},
            deleteWordBackward: {unit: Kx, direction: Yx},
            deleteHardLineBackward: {unit: Jx, direction: Yx},
            deleteSoftLineBackward: {unit: Jx, direction: Yx},
            deleteContentForward: {unit: Gx, direction: Qx},
            deleteWordForward: {unit: Kx, direction: Qx},
            deleteHardLineForward: {unit: Jx, direction: Qx},
            deleteSoftLineForward: {unit: Jx, direction: Qx}
        };

        class tE extends Sf {
            constructor(t) {
                super(t);
                const e = t.document;
                let n = 0;
                e.on("keydown", (() => {
                    n++
                }));
                e.on("keyup", (() => {
                    n = 0
                }));
                e.on("beforeinput", ((i, o) => {
                    if (!this.isEnabled) {
                        return
                    }
                    const {targetRanges: s, domEvent: a, inputType: l} = o;
                    const c = Xx[l];
                    if (!c) {
                        return
                    }
                    const d = {direction: c.direction, unit: c.unit, sequence: n};
                    if (d.unit == Jx) {
                        d.selectionToRemove = t.createSelection(s[0])
                    }
                    if (r.isAndroid && l === "deleteContentBackward") {
                        d.sequence = 1;
                        if (s.length == 1 && (s[0].start.parent != s[0].end.parent || s[0].start.offset + 1 != s[0].end.offset)) {
                            d.unit = Jx;
                            d.selectionToRemove = t.createSelection(s)
                        }
                    }
                    const u = new dh(e, "delete", s[0]);
                    e.fire(u, new Bf(t, a, d));
                    if (u.stop.called) {
                        i.stop()
                    }
                }));
                if (r.isBlink) {
                    eE(this)
                }
            }

            observe() {
            }
        }

        function eE(t) {
            const e = t.view;
            const n = e.document;
            let i = null;
            let o = false;
            n.on("keydown", ((t, {keyCode: e}) => {
                i = e;
                o = false
            }));
            n.on("keyup", ((a, {keyCode: l, domEvent: c}) => {
                const d = n.selection;
                const u = t.isEnabled && l == i && r(l) && !d.isCollapsed && !o;
                i = null;
                if (u) {
                    const t = d.getFirstRange();
                    const i = new dh(n, "delete", t);
                    const o = {unit: Jx, direction: s(l), selectionToRemove: d};
                    n.fire(i, new Bf(e, c, o))
                }
            }));
            n.on("beforeinput", ((t, {inputType: e}) => {
                const n = Xx[e];
                const a = r(i) && n && n.direction == s(i);
                if (a) {
                    o = true
                }
            }), {priority: "high"});
            n.on("beforeinput", ((t, {inputType: e, data: n}) => {
                const o = i == Ol["delete"] && e == "insertText" && n == "";
                if (o) {
                    t.stop()
                }
            }), {priority: "high"});

            function r(t) {
                return t == Ol.backspace || t == Ol["delete"]
            }

            function s(t) {
                return t == Ol.backspace ? Yx : Qx
            }
        }

        class nE extends Ac {
            static get pluginName() {
                return "Delete"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                const i = t.model.document;
                e.addObserver(tE);
                this._undoOnBackspace = false;
                const o = new Ux(t, "forward");
                t.commands.add("deleteForward", o);
                t.commands.add("forwardDelete", o);
                t.commands.add("delete", new Ux(t, "backward"));
                this.listenTo(n, "delete", ((i, o) => {
                    if (!n.isComposing) {
                        o.preventDefault()
                    }
                    const {direction: r, sequence: s, selectionToRemove: a, unit: l} = o;
                    const c = r === "forward" ? "deleteForward" : "delete";
                    const d = {sequence: s};
                    if (l == "selection") {
                        const e = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                        d.selection = t.model.createSelection(e)
                    } else {
                        d.unit = l
                    }
                    t.execute(c, d);
                    e.scrollToTheSelection()
                }), {priority: "low"});
                if (this.editor.plugins.has("UndoEditing")) {
                    this.listenTo(n, "delete", ((e, n) => {
                        if (this._undoOnBackspace && n.direction == "backward" && n.sequence == 1 && n.unit == "codePoint") {
                            this._undoOnBackspace = false;
                            t.execute("undo");
                            n.preventDefault();
                            e.stop()
                        }
                    }), {context: "$capture"});
                    this.listenTo(i, "change", (() => {
                        this._undoOnBackspace = false
                    }))
                }
            }

            requestUndoOnBackspace() {
                if (this.editor.plugins.has("UndoEditing")) {
                    this._undoOnBackspace = true
                }
            }
        }

        class iE extends Ac {
            static get requires() {
                return [jx, nE]
            }

            static get pluginName() {
                return "Typing"
            }
        }

        function oE(t, e) {
            let n = t.start;
            const i = Array.from(t.getItems()).reduce(((t, i) => {
                if (!(i.is("$text") || i.is("$textProxy"))) {
                    n = e.createPositionAfter(i);
                    return ""
                }
                return t + i.data
            }), "");
            return {text: i, range: e.createRange(n, t.end)}
        }

        class rE extends (dt()) {
            constructor(t, e) {
                super();
                this.model = t;
                this.testCallback = e;
                this._hasMatch = false;
                this.set("isEnabled", true);
                this.on("change:isEnabled", (() => {
                    if (this.isEnabled) {
                        this._startListening()
                    } else {
                        this.stopListening(t.document.selection);
                        this.stopListening(t.document)
                    }
                }));
                this._startListening()
            }

            get hasMatch() {
                return this._hasMatch
            }

            _startListening() {
                const t = this.model;
                const e = t.document;
                this.listenTo(e.selection, "change:range", ((t, {directChange: n}) => {
                    if (!n) {
                        return
                    }
                    if (!e.selection.isCollapsed) {
                        if (this.hasMatch) {
                            this.fire("unmatched");
                            this._hasMatch = false
                        }
                        return
                    }
                    this._evaluateTextBeforeSelection("selection")
                }));
                this.listenTo(e, "change:data", ((t, e) => {
                    if (e.isUndo || !e.isLocal) {
                        return
                    }
                    this._evaluateTextBeforeSelection("data", {batch: e})
                }))
            }

            _evaluateTextBeforeSelection(t, e = {}) {
                const n = this.model;
                const i = n.document;
                const o = i.selection;
                const r = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus);
                const {text: s, range: a} = oE(r, n);
                const l = this.testCallback(s);
                if (!l && this.hasMatch) {
                    this.fire("unmatched")
                }
                this._hasMatch = !!l;
                if (l) {
                    const n = Object.assign(e, {text: s, range: a});
                    if (typeof l == "object") {
                        Object.assign(n, l)
                    }
                    this.fire(`matched:${t}`, n)
                }
            }
        }

        class sE extends Ac {
            static get pluginName() {
                return "TwoStepCaretMovement"
            }

            constructor(t) {
                super(t);
                this.attributes = new Set;
                this._overrideUid = null
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = t.locale;
                const o = e.document.selection;
                this.listenTo(n.document, "arrowKey", ((t, e) => {
                    if (!o.isCollapsed) {
                        return
                    }
                    if (e.shiftKey || e.altKey || e.ctrlKey) {
                        return
                    }
                    const n = e.keyCode == Ol.arrowright;
                    const r = e.keyCode == Ol.arrowleft;
                    if (!n && !r) {
                        return
                    }
                    const s = i.contentLanguageDirection;
                    let a = false;
                    if (s === "ltr" && n || s === "rtl" && r) {
                        a = this._handleForwardMovement(e)
                    } else {
                        a = this._handleBackwardMovement(e)
                    }
                    if (a === true) {
                        t.stop()
                    }
                }), {context: "$text", priority: "highest"});
                this._isNextGravityRestorationSkipped = false;
                this.listenTo(o, "change:range", ((t, e) => {
                    if (this._isNextGravityRestorationSkipped) {
                        this._isNextGravityRestorationSkipped = false;
                        return
                    }
                    if (!this._isGravityOverridden) {
                        return
                    }
                    if (!e.directChange && uE(o.getFirstPosition(), this.attributes)) {
                        return
                    }
                    this._restoreGravity()
                }))
            }

            registerAttribute(t) {
                this.attributes.add(t)
            }

            _handleForwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const i = n.document.selection;
                const o = i.getFirstPosition();
                if (this._isGravityOverridden) {
                    return false
                }
                if (o.isAtStart && aE(i, e)) {
                    return false
                }
                if (uE(o, e)) {
                    cE(t);
                    this._overrideGravity();
                    return true
                }
                return false
            }

            _handleBackwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const i = n.document.selection;
                const o = i.getFirstPosition();
                if (this._isGravityOverridden) {
                    cE(t);
                    this._restoreGravity();
                    lE(n, e, o);
                    return true
                } else {
                    if (o.isAtStart) {
                        if (aE(i, e)) {
                            cE(t);
                            lE(n, e, o);
                            return true
                        }
                        return false
                    }
                    if (dE(o, e)) {
                        if (o.isAtEnd && !aE(i, e) && uE(o, e)) {
                            cE(t);
                            lE(n, e, o);
                            return true
                        }
                        this._isNextGravityRestorationSkipped = true;
                        this._overrideGravity();
                        return false
                    }
                }
                return false
            }

            get _isGravityOverridden() {
                return !!this._overrideUid
            }

            _overrideGravity() {
                this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity()))
            }

            _restoreGravity() {
                this.editor.model.change((t => {
                    t.restoreSelectionGravity(this._overrideUid);
                    this._overrideUid = null
                }))
            }
        }

        function aE(t, e) {
            for (const n of e) {
                if (t.hasAttribute(n)) {
                    return true
                }
            }
            return false
        }

        function lE(t, e, n) {
            const i = n.nodeBefore;
            t.change((t => {
                if (i) {
                    t.setSelectionAttribute(i.getAttributes())
                } else {
                    t.removeSelectionAttribute(e)
                }
            }))
        }

        function cE(t) {
            t.preventDefault()
        }

        function dE(t, e) {
            const n = t.getShiftedBy(-1);
            return uE(n, e)
        }

        function uE(t, e) {
            const {nodeBefore: n, nodeAfter: i} = t;
            for (const t of e) {
                const e = n ? n.getAttribute(t) : undefined;
                const o = i ? i.getAttribute(t) : undefined;
                if (o !== e) {
                    return true
                }
            }
            return false
        }

        var hE = /[\\^$.*+?()[\]{}|]/g, fE = RegExp(hE.source);

        function gE(t) {
            t = Id(t);
            return t && fE.test(t) ? t.replace(hE, "\\$&") : t
        }

        const mE = gE;
        const pE = {
            copyright: {from: "(c)", to: "©"},
            registeredTrademark: {from: "(r)", to: "®"},
            trademark: {from: "(tm)", to: "™"},
            oneHalf: {from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null]},
            oneThird: {from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null]},
            twoThirds: {from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null]},
            oneForth: {from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null]},
            threeQuarters: {from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null]},
            lessThanOrEqual: {from: "<=", to: "≤"},
            greaterThanOrEqual: {from: ">=", to: "≥"},
            notEqual: {from: "!=", to: "≠"},
            arrowLeft: {from: "<-", to: "←"},
            arrowRight: {from: "->", to: "→"},
            horizontalEllipsis: {from: "...", to: "…"},
            enDash: {from: /(^| )(--)( )$/, to: [null, "–", null]},
            emDash: {from: /(^| )(---)( )$/, to: [null, "—", null]},
            quotesPrimary: {from: vE('"'), to: [null, "“", null, "”"]},
            quotesSecondary: {from: vE("'"), to: [null, "‘", null, "’"]},
            quotesPrimaryEnGb: {from: vE("'"), to: [null, "‘", null, "’"]},
            quotesSecondaryEnGb: {from: vE('"'), to: [null, "“", null, "”"]},
            quotesPrimaryPl: {from: vE('"'), to: [null, "„", null, "”"]},
            quotesSecondaryPl: {from: vE("'"), to: [null, "‚", null, "’"]}
        };
        const bE = {
            symbols: ["copyright", "registeredTrademark", "trademark"],
            mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
            typography: ["horizontalEllipsis", "enDash", "emDash"],
            quotes: ["quotesPrimary", "quotesSecondary"]
        };
        const kE = ["symbols", "mathematical", "typography", "quotes"];

        class wE extends Ac {
            static get requires() {
                return ["Delete", "Input"]
            }

            static get pluginName() {
                return "TextTransformation"
            }

            constructor(t) {
                super(t);
                t.config.define("typing", {transformations: {include: kE}})
            }

            init() {
                const t = this.editor.model;
                const e = t.document.selection;
                e.on("change:range", (() => {
                    this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                }));
                this._enableTransformationWatchers()
            }

            _enableTransformationWatchers() {
                const t = this.editor;
                const e = t.model;
                const n = t.plugins.get("Delete");
                const i = yE(t.config.get("typing.transformations"));
                const o = t => {
                    for (const e of i) {
                        const n = e.from;
                        const i = n.test(t);
                        if (i) {
                            return {normalizedTransformation: e}
                        }
                    }
                };
                const r = new rE(t.model, o);
                r.on("matched:data", ((t, i) => {
                    if (!i.batch.isTyping) {
                        return
                    }
                    const {from: o, to: r} = i.normalizedTransformation;
                    const s = o.exec(i.text);
                    const a = r(s.slice(1));
                    const l = i.range;
                    let c = s.index;
                    e.enqueueChange((t => {
                        for (let n = 1; n < s.length; n++) {
                            const i = s[n];
                            const o = a[n - 1];
                            if (o == null) {
                                c += i.length;
                                continue
                            }
                            const r = l.start.getShiftedBy(c);
                            const d = e.createRange(r, r.getShiftedBy(i.length));
                            const u = CE(r);
                            e.insertContent(t.createText(o, u), d);
                            c += o.length
                        }
                        e.enqueueChange((() => {
                            n.requestUndoOnBackspace()
                        }))
                    }))
                }));
                r.bind("isEnabled").to(this)
            }
        }

        function _E(t) {
            if (typeof t == "string") {
                return new RegExp(`(${mE(t)})$`)
            }
            return t
        }

        function AE(t) {
            if (typeof t == "string") {
                return () => [t]
            } else if (t instanceof Array) {
                return () => t
            }
            return t
        }

        function CE(t) {
            const e = t.textNode ? t.textNode : t.nodeAfter;
            return e.getAttributes()
        }

        function vE(t) {
            return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
        }

        function yE(t) {
            const e = t.extra || [];
            const n = t.remove || [];
            const i = t => !n.includes(t);
            const o = t.include.concat(e).filter(i);
            return xE(o).filter(i).map((t => typeof t == "string" && pE[t] ? pE[t] : t)).filter((t => typeof t === "object")).map((t => ({
                from: _E(t.from),
                to: AE(t.to)
            })))
        }

        function xE(t) {
            const e = new Set;
            for (const n of t) {
                if (typeof n == "string" && bE[n]) {
                    for (const t of bE[n]) {
                        e.add(t)
                    }
                } else {
                    e.add(n)
                }
            }
            return Array.from(e)
        }

        function EE(t, e, n, i) {
            return i.createRange(SE(t, e, n, true, i), SE(t, e, n, false, i))
        }

        function SE(t, e, n, i, o) {
            let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter);
            let s = null;
            while (r && r.getAttribute(e) == n) {
                s = r;
                r = i ? r.previousSibling : r.nextSibling
            }
            return s ? o.createPositionAt(s, i ? "before" : "after") : t
        }

        function DE(t, e, n, i) {
            const o = t.editing.view;
            const r = new Set;
            o.document.registerPostFixer((o => {
                const s = t.model.document.selection;
                let a = false;
                if (s.hasAttribute(e)) {
                    const l = EE(s.getFirstPosition(), e, s.getAttribute(e), t.model);
                    const c = t.editing.mapper.toViewRange(l);
                    for (const t of c.getItems()) {
                        if (t.is("element", n) && !t.hasClass(i)) {
                            o.addClass(i, t);
                            r.add(t);
                            a = true
                        }
                    }
                }
                return a
            }));
            t.conversion.for("editingDowncast").add((t => {
                t.on("insert", e, {priority: "highest"});
                t.on("remove", e, {priority: "highest"});
                t.on("attribute", e, {priority: "highest"});
                t.on("selection", e, {priority: "highest"});

                function e() {
                    o.change((t => {
                        for (const e of r.values()) {
                            t.removeClass(i, e);
                            r.delete(e)
                        }
                    }))
                }
            }))
        }

        function TE(t, e, n, i) {
            let o;
            let r = null;
            if (typeof i == "function") {
                o = i
            } else {
                r = t.commands.get(i);
                o = () => {
                    t.execute(i)
                }
            }
            t.model.document.on("change:data", ((s, a) => {
                if (r && !r.isEnabled || !e.isEnabled) {
                    return
                }
                const l = sc(t.model.document.selection.getRanges());
                if (!l.isCollapsed) {
                    return
                }
                if (a.isUndo || !a.isLocal) {
                    return
                }
                const c = Array.from(t.model.document.differ.getChanges());
                const d = c[0];
                if (c.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1) {
                    return
                }
                const u = d.position.parent;
                if (u.is("element", "codeBlock")) {
                    return
                }
                if (u.is("element", "listItem") && typeof i !== "function" && !["numberedList", "bulletedList", "todoList"].includes(i)) {
                    return
                }
                if (r && r.value === true) {
                    return
                }
                const h = u.getChild(0);
                const f = t.model.createRangeOn(h);
                if (!f.containsRange(l) && !l.end.isEqual(f.end)) {
                    return
                }
                const g = n.exec(h.data.substr(0, l.end.offset));
                if (!g) {
                    return
                }
                t.model.enqueueChange((e => {
                    const n = e.createPositionAt(u, 0);
                    const i = e.createPositionAt(u, g[0].length);
                    const r = new Mm(n, i);
                    const s = o({match: g});
                    if (s !== false) {
                        e.remove(r);
                        const n = t.model.document.selection.getFirstRange();
                        const i = e.createRangeIn(u);
                        if (u.isEmpty && !i.isEqual(n) && !i.containsRange(n, true)) {
                            e.remove(u)
                        }
                    }
                    r.detach();
                    t.model.enqueueChange((() => {
                        t.plugins.get("Delete").requestUndoOnBackspace()
                    }))
                }))
            }))
        }

        function BE(t, e, n, i) {
            let o;
            let r;
            if (n instanceof RegExp) {
                o = n
            } else {
                r = n
            }
            r = r || (t => {
                let e;
                const n = [];
                const i = [];
                while ((e = o.exec(t)) !== null) {
                    if (e && e.length < 4) {
                        break
                    }
                    let {index: t, 1: o, 2: r, 3: s} = e;
                    const a = o + r + s;
                    t += e[0].length - a.length;
                    const l = [t, t + o.length];
                    const c = [t + o.length + r.length, t + o.length + r.length + s.length];
                    n.push(l);
                    n.push(c);
                    i.push([t + o.length, t + o.length + r.length])
                }
                return {remove: n, format: i}
            });
            t.model.document.on("change:data", ((n, o) => {
                if (o.isUndo || !o.isLocal || !e.isEnabled) {
                    return
                }
                const s = t.model;
                const a = s.document.selection;
                if (!a.isCollapsed) {
                    return
                }
                const l = Array.from(s.document.differ.getChanges());
                const c = l[0];
                if (l.length != 1 || c.type !== "insert" || c.name != "$text" || c.length != 1) {
                    return
                }
                const d = a.focus;
                const u = d.parent;
                const {text: h, range: f} = IE(s.createRange(s.createPositionAt(u, 0), d), s);
                const g = r(h);
                const m = PE(f.start, g.format, s);
                const p = PE(f.start, g.remove, s);
                if (!(m.length && p.length)) {
                    return
                }
                s.enqueueChange((e => {
                    const n = i(e, m);
                    if (n === false) {
                        return
                    }
                    for (const t of p.reverse()) {
                        e.remove(t)
                    }
                    s.enqueueChange((() => {
                        t.plugins.get("Delete").requestUndoOnBackspace()
                    }))
                }))
            }))
        }

        function PE(t, e, n) {
            return e.filter((t => t[0] !== undefined && t[1] !== undefined)).map((e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))))
        }

        function IE(t, e) {
            let n = t.start;
            const i = Array.from(t.getItems()).reduce(((t, i) => {
                if (!(i.is("$text") || i.is("$textProxy")) || i.getAttribute("code")) {
                    n = e.createPositionAfter(i);
                    return ""
                }
                return t + i.data
            }), "");
            return {text: i, range: e.createRange(n, t.end)}
        }

        class RE extends Ac {
            static get requires() {
                return [nE]
            }

            static get pluginName() {
                return "Autoformat"
            }

            afterInit() {
                this._addListAutoformats();
                this._addBasicStylesAutoformats();
                this._addHeadingAutoformats();
                this._addBlockQuoteAutoformats();
                this._addCodeBlockAutoformats();
                this._addHorizontalLineAutoformats()
            }

            _addListAutoformats() {
                const t = this.editor.commands;
                if (t.get("bulletedList")) {
                    TE(this.editor, this, /^[*-]\s$/, "bulletedList")
                }
                if (t.get("numberedList")) {
                    TE(this.editor, this, /^1[.|)]\s$/, "numberedList")
                }
                if (t.get("todoList")) {
                    TE(this.editor, this, /^\[\s?\]\s$/, "todoList")
                }
                if (t.get("checkTodoList")) {
                    TE(this.editor, this, /^\[\s?x\s?\]\s$/, (() => {
                        this.editor.execute("todoList");
                        this.editor.execute("checkTodoList")
                    }))
                }
            }

            _addBasicStylesAutoformats() {
                const t = this.editor.commands;
                if (t.get("bold")) {
                    const t = zE(this.editor, "bold");
                    BE(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t);
                    BE(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
                }
                if (t.get("italic")) {
                    const t = zE(this.editor, "italic");
                    BE(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t);
                    BE(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
                }
                if (t.get("code")) {
                    const t = zE(this.editor, "code");
                    BE(this.editor, this, /(`)([^`]+)(`)$/g, t)
                }
                if (t.get("strikethrough")) {
                    const t = zE(this.editor, "strikethrough");
                    BE(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
                }
            }

            _addHeadingAutoformats() {
                const t = this.editor.commands.get("heading");
                if (t) {
                    t.modelElements.filter((t => t.match(/^heading[1-6]$/))).forEach((e => {
                        const n = e[7];
                        const i = new RegExp(`^(#{${n}})\\s$`);
                        TE(this.editor, this, i, (() => {
                            if (!t.isEnabled || t.value === e) {
                                return false
                            }
                            this.editor.execute("heading", {value: e})
                        }))
                    }))
                }
            }

            _addBlockQuoteAutoformats() {
                if (this.editor.commands.get("blockQuote")) {
                    TE(this.editor, this, /^>\s$/, "blockQuote")
                }
            }

            _addCodeBlockAutoformats() {
                const t = this.editor;
                const e = t.model.document.selection;
                if (t.commands.get("codeBlock")) {
                    TE(t, this, /^```$/, (() => {
                        if (e.getFirstPosition().parent.is("element", "listItem")) {
                            return false
                        }
                        this.editor.execute("codeBlock", {usePreviousLanguageChoice: true})
                    }))
                }
            }

            _addHorizontalLineAutoformats() {
                if (this.editor.commands.get("horizontalLine")) {
                    TE(this.editor, this, /^---$/, "horizontalLine")
                }
            }
        }

        function zE(t, e) {
            return (n, i) => {
                const o = t.commands.get(e);
                if (!o.isEnabled) {
                    return false
                }
                const r = t.model.schema.getValidRanges(i, e);
                for (const t of r) {
                    n.setAttribute(e, true, t)
                }
                n.removeSelectionAttribute(e)
            }
        }

        function VE(t, e, n) {
            var i = t.length;
            n = n === undefined ? i : n;
            return !e && n >= i ? t : qd(t, e, n)
        }

        const FE = VE;
        var LE = "\\ud800-\\udfff", OE = "\\u0300-\\u036f", NE = "\\ufe20-\\ufe2f", ME = "\\u20d0-\\u20ff",
            HE = OE + NE + ME, WE = "\\ufe0e\\ufe0f";
        var qE = "\\u200d";
        var jE = RegExp("[" + qE + LE + HE + WE + "]");

        function $E(t) {
            return jE.test(t)
        }

        const UE = $E;

        function GE(t) {
            return t.split("")
        }

        const KE = GE;
        var ZE = "\\ud800-\\udfff", JE = "\\u0300-\\u036f", YE = "\\ufe20-\\ufe2f", QE = "\\u20d0-\\u20ff",
            XE = JE + YE + QE, tS = "\\ufe0e\\ufe0f";
        var eS = "[" + ZE + "]", nS = "[" + XE + "]", iS = "\\ud83c[\\udffb-\\udfff]", oS = "(?:" + nS + "|" + iS + ")",
            rS = "[^" + ZE + "]", sS = "(?:\\ud83c[\\udde6-\\uddff]){2}", aS = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            lS = "\\u200d";
        var cS = oS + "?", dS = "[" + tS + "]?",
            uS = "(?:" + lS + "(?:" + [rS, sS, aS].join("|") + ")" + dS + cS + ")*", hS = dS + cS + uS,
            fS = "(?:" + [rS + nS + "?", nS, sS, aS, eS].join("|") + ")";
        var gS = RegExp(iS + "(?=" + iS + ")|" + fS + hS, "g");

        function mS(t) {
            return t.match(gS) || []
        }

        const pS = mS;

        function bS(t) {
            return UE(t) ? pS(t) : KE(t)
        }

        const kS = bS;

        function wS(t) {
            return function (e) {
                e = Id(e);
                var n = UE(e) ? kS(e) : undefined;
                var i = n ? n[0] : e.charAt(0);
                var o = n ? FE(n, 1).join("") : e.slice(1);
                return i[t]() + o
            }
        }

        const _S = wS;
        var AS = _S("toUpperCase");
        const CS = AS;
        const vS = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
        const yS = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        const xS = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
        const ES = /^((\w+:(\/{2,})?)|(\W))/i;
        const SS = "Ctrl+K";

        function DS(t) {
            return t.is("attributeElement") && !!t.getCustomProperty("link")
        }

        function TS(t, {writer: e}) {
            const n = e.createAttributeElement("a", {href: t}, {priority: 5});
            e.setCustomProperty("link", true, n);
            return n
        }

        function BS(t) {
            t = String(t);
            return PS(t) ? t : "#"
        }

        function PS(t) {
            const e = t.replace(vS, "");
            return e.match(yS)
        }

        function IS(t, e) {
            const n = {"Open in a new tab": t("Open in a new tab"), Downloadable: t("Downloadable")};
            e.forEach((t => {
                if (t.label && n[t.label]) {
                    t.label = n[t.label]
                }
                return t
            }));
            return e
        }

        function RS(t) {
            const e = [];
            if (t) {
                for (const [n, i] of Object.entries(t)) {
                    const t = Object.assign({}, i, {id: `link${CS(n)}`});
                    e.push(t)
                }
            }
            return e
        }

        function zS(t, e) {
            if (!t) {
                return false
            }
            return e.checkAttribute(t.name, "linkHref")
        }

        function VS(t) {
            return xS.test(t)
        }

        function FS(t, e) {
            const n = VS(t) ? "mailto:" : e;
            const i = !!n && !LS(t);
            return t && i ? n + t : t
        }

        function LS(t) {
            return ES.test(t)
        }

        function OS(t) {
            window.open(t, "_blank", "noopener")
        }

        const NS = 4;
        const MS = new RegExp("(^|\\s)" + "(" + "(" + "(?:(?:(?:https?|ftp):)?\\/\\/)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(" + "((?!www\\.)|(www\\.))" + "(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + ")" + "|" + "(" + "(www.|(\\S+@))" + "((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")$", "i");
        const HS = 2;

        class WS extends Ac {
            static get requires() {
                return [nE]
            }

            static get pluginName() {
                return "AutoLink"
            }

            init() {
                const t = this.editor;
                const e = t.model.document.selection;
                e.on("change:range", (() => {
                    this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                }));
                this._enableTypingHandling()
            }

            afterInit() {
                this._enableEnterHandling();
                this._enableShiftEnterHandling()
            }

            _enableTypingHandling() {
                const t = this.editor;
                const e = new rE(t.model, (t => {
                    if (!qS(t)) {
                        return
                    }
                    const e = jS(t.substr(0, t.length - 1));
                    if (e) {
                        return {url: e}
                    }
                }));
                e.on("matched:data", ((e, n) => {
                    const {batch: i, range: o, url: r} = n;
                    if (!i.isTyping) {
                        return
                    }
                    const s = o.end.getShiftedBy(-1);
                    const a = s.getShiftedBy(-r.length);
                    const l = t.model.createRange(a, s);
                    this._applyAutoLink(r, l)
                }));
                e.bind("isEnabled").to(this)
            }

            _enableEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("enter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    if (!t.parent.previousSibling) {
                        return
                    }
                    const n = e.createRangeIn(t.parent.previousSibling);
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }

            _enableShiftEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("shiftEnter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }

            _checkAndApplyAutoLinkOnRange(t) {
                const e = this.editor.model;
                const {text: n, range: i} = oE(t, e);
                const o = jS(n);
                if (o) {
                    const t = e.createRange(i.end.getShiftedBy(-o.length), i.end);
                    this._applyAutoLink(o, t)
                }
            }

            _applyAutoLink(t, e) {
                const n = this.editor.model;
                const i = this.editor.config.get("link.defaultProtocol");
                const o = FS(t, i);
                if (!this.isEnabled || !$S(e, n) || !LS(o) || US(e)) {
                    return
                }
                this._persistAutoLink(o, e)
            }

            _persistAutoLink(t, e) {
                const n = this.editor.model;
                const i = this.editor.plugins.get("Delete");
                n.enqueueChange((o => {
                    o.setAttribute("linkHref", t, e);
                    n.enqueueChange((() => {
                        i.requestUndoOnBackspace()
                    }))
                }))
            }
        }

        function qS(t) {
            return t.length > NS && t[t.length - 1] === " " && t[t.length - 2] !== " "
        }

        function jS(t) {
            const e = MS.exec(t);
            return e ? e[HS] : null
        }

        function $S(t, e) {
            return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref")
        }

        function US(t) {
            const e = t.start.nodeAfter;
            return e && e.hasAttribute("linkHref")
        }

        class GS extends (dt()) {
            constructor() {
                super();
                const t = new window.FileReader;
                this._reader = t;
                this._data = undefined;
                this.set("loaded", 0);
                t.onprogress = t => {
                    this.loaded = t.loaded
                }
            }

            get error() {
                return this._reader.error
            }

            get data() {
                return this._data
            }

            read(t) {
                const e = this._reader;
                this.total = t.size;
                return new Promise(((n, i) => {
                    e.onload = () => {
                        const t = e.result;
                        this._data = t;
                        n(t)
                    };
                    e.onerror = () => {
                        i("error")
                    };
                    e.onabort = () => {
                        i("aborted")
                    };
                    this._reader.readAsDataURL(t)
                }))
            }

            abort() {
                this._reader.abort()
            }
        }

        class KS extends Ac {
            static get pluginName() {
                return "FileRepository"
            }

            static get requires() {
                return [HA]
            }

            init() {
                this.loaders = new rc;
                this.loaders.on("change", (() => this._updatePendingAction()));
                this._loadersMap = new Map;
                this._pendingAction = null;
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0))
            }

            getLoader(t) {
                return this._loadersMap.get(t) || null
            }

            createLoader(t) {
                if (!this.createUploadAdapter) {
                    I("filerepository-no-upload-adapter");
                    return null
                }
                const e = new ZS(Promise.resolve(t), this.createUploadAdapter);
                this.loaders.add(e);
                this._loadersMap.set(t, e);
                if (t instanceof Promise) {
                    e.file.then((t => {
                        this._loadersMap.set(t, e)
                    })).catch((() => {
                    }))
                }
                e.on("change:uploaded", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        t += e.uploaded
                    }
                    this.uploaded = t
                }));
                e.on("change:uploadTotal", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        if (e.uploadTotal) {
                            t += e.uploadTotal
                        }
                    }
                    this.uploadTotal = t
                }));
                return e
            }

            destroyLoader(t) {
                const e = t instanceof ZS ? t : this.getLoader(t);
                e._destroy();
                this.loaders.remove(e);
                this._loadersMap.forEach(((t, n) => {
                    if (t === e) {
                        this._loadersMap.delete(n)
                    }
                }))
            }

            _updatePendingAction() {
                const t = this.editor.plugins.get(HA);
                if (this.loaders.length) {
                    if (!this._pendingAction) {
                        const e = this.editor.t;
                        const n = t => `${e("Upload in progress")} ${parseInt(t)}%.`;
                        this._pendingAction = t.add(n(this.uploadedPercent));
                        this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                    }
                } else {
                    t.remove(this._pendingAction);
                    this._pendingAction = null
                }
            }
        }

        class ZS extends (dt()) {
            constructor(t, e) {
                super();
                this.id = E();
                this._filePromiseWrapper = this._createFilePromiseWrapper(t);
                this._adapter = e(this);
                this._reader = new GS;
                this.set("status", "idle");
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0));
                this.set("uploadResponse", null)
            }

            get file() {
                if (!this._filePromiseWrapper) {
                    return Promise.resolve(null)
                } else {
                    return this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null))
                }
            }

            get data() {
                return this._reader.data
            }

            read() {
                if (this.status != "idle") {
                    throw new P("filerepository-read-wrong-status", this)
                }
                this.status = "reading";
                return this.file.then((t => this._reader.read(t))).then((t => {
                    if (this.status !== "reading") {
                        throw this.status
                    }
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (t === "aborted") {
                        this.status = "aborted";
                        throw"aborted"
                    }
                    this.status = "error";
                    throw this._reader.error ? this._reader.error : t
                }))
            }

            upload() {
                if (this.status != "idle") {
                    throw new P("filerepository-upload-wrong-status", this)
                }
                this.status = "uploading";
                return this.file.then((() => this._adapter.upload())).then((t => {
                    this.uploadResponse = t;
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (this.status === "aborted") {
                        throw"aborted"
                    }
                    this.status = "error";
                    throw t
                }))
            }

            abort() {
                const t = this.status;
                this.status = "aborted";
                if (!this._filePromiseWrapper.isFulfilled) {
                    this._filePromiseWrapper.promise.catch((() => {
                    }));
                    this._filePromiseWrapper.rejecter("aborted")
                } else if (t == "reading") {
                    this._reader.abort()
                } else if (t == "uploading" && this._adapter.abort) {
                    this._adapter.abort()
                }
                this._destroy()
            }

            _destroy() {
                this._filePromiseWrapper = undefined;
                this._reader = undefined;
                this._adapter = undefined;
                this.uploadResponse = undefined
            }

            _createFilePromiseWrapper(t) {
                const e = {};
                e.promise = new Promise(((n, i) => {
                    e.rejecter = i;
                    e.isFulfilled = false;
                    t.then((t => {
                        e.isFulfilled = true;
                        n(t)
                    })).catch((t => {
                        e.isFulfilled = true;
                        i(t)
                    }))
                }));
                return e
            }
        }

        class JS extends Ac {
            static get requires() {
                return [KS]
            }

            static get pluginName() {
                return "Base64UploadAdapter"
            }

            init() {
                this.editor.plugins.get(KS).createUploadAdapter = t => new YS(t)
            }
        }

        class YS {
            constructor(t) {
                this.loader = t
            }

            upload() {
                return new Promise(((t, e) => {
                    const n = this.reader = new window.FileReader;
                    n.addEventListener("load", (() => {
                        t({default: n.result})
                    }));
                    n.addEventListener("error", (t => {
                        e(t)
                    }));
                    n.addEventListener("abort", (() => {
                        e()
                    }));
                    this.loader.file.then((t => {
                        n.readAsDataURL(t)
                    }))
                }))
            }

            abort() {
                this.reader.abort()
            }
        }

        function* QS(t, e) {
            for (const n of e) {
                if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
                    yield n
                }
            }
        }

        class XS extends vc {
            execute() {
                this.editor.model.change((t => {
                    this.enterBlock(t);
                    this.fire("afterExecute", {writer: t})
                }))
            }

            enterBlock(t) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = e.schema;
                const o = n.isCollapsed;
                const r = n.getFirstRange();
                const s = r.start.parent;
                const a = r.end.parent;
                if (i.isLimit(s) || i.isLimit(a)) {
                    if (!o && s == a) {
                        e.deleteContent(n)
                    }
                    return false
                }
                if (o) {
                    const e = QS(t.model.schema, n.getAttributes());
                    tD(t, r.start);
                    t.setSelectionAttribute(e);
                    return true
                } else {
                    const i = !(r.start.isAtStart && r.end.isAtEnd);
                    const o = s == a;
                    e.deleteContent(n, {leaveUnmerged: i});
                    if (i) {
                        if (o) {
                            tD(t, n.focus);
                            return true
                        } else {
                            t.setSelection(a, 0)
                        }
                    }
                }
                return false
            }
        }

        function tD(t, e) {
            t.split(e);
            t.setSelection(e.parent.nextSibling, 0)
        }

        const eD = {insertParagraph: {isSoft: false}, insertLineBreak: {isSoft: true}};

        class nD extends Sf {
            constructor(t) {
                super(t);
                const e = this.document;
                e.on("beforeinput", ((n, i) => {
                    if (!this.isEnabled) {
                        return
                    }
                    const o = i.domEvent;
                    const r = eD[i.inputType];
                    if (!r) {
                        return
                    }
                    const s = new dh(e, "enter", i.targetRanges[0]);
                    e.fire(s, new Bf(t, o, {isSoft: r.isSoft}));
                    if (s.stop.called) {
                        n.stop()
                    }
                }))
            }

            observe() {
            }
        }

        class iD extends Ac {
            static get pluginName() {
                return "Enter"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                e.addObserver(nD);
                t.commands.add("enter", new XS(t));
                this.listenTo(n, "enter", ((i, o) => {
                    if (!n.isComposing) {
                        o.preventDefault()
                    }
                    if (o.isSoft) {
                        return
                    }
                    t.execute("enter");
                    e.scrollToTheSelection()
                }), {priority: "low"})
            }
        }

        class oD extends vc {
            execute() {
                const t = this.editor.model;
                const e = t.document;
                t.change((n => {
                    sD(t, n, e.selection);
                    this.fire("afterExecute", {writer: n})
                }))
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.isEnabled = rD(t.schema, e.selection)
            }
        }

        function rD(t, e) {
            if (e.rangeCount > 1) {
                return false
            }
            const n = e.anchor;
            if (!n || !t.checkChild(n, "softBreak")) {
                return false
            }
            const i = e.getFirstRange();
            const o = i.start.parent;
            const r = i.end.parent;
            if ((lD(o, t) || lD(r, t)) && o !== r) {
                return false
            }
            return true
        }

        function sD(t, e, n) {
            const i = n.isCollapsed;
            const o = n.getFirstRange();
            const r = o.start.parent;
            const s = o.end.parent;
            const a = r == s;
            if (i) {
                const i = QS(t.schema, n.getAttributes());
                aD(t, e, o.end);
                e.removeSelectionAttribute(n.getAttributeKeys());
                e.setSelectionAttribute(i)
            } else {
                const i = !(o.start.isAtStart && o.end.isAtEnd);
                t.deleteContent(n, {leaveUnmerged: i});
                if (a) {
                    aD(t, e, n.focus)
                } else {
                    if (i) {
                        e.setSelection(s, 0)
                    }
                }
            }
        }

        function aD(t, e, n) {
            const i = e.createElement("softBreak");
            t.insertContent(i, n);
            e.setSelection(i, "after")
        }

        function lD(t, e) {
            if (t.is("rootElement")) {
                return false
            }
            return e.isLimit(t) || lD(t.parent, e)
        }

        class cD extends Ac {
            static get pluginName() {
                return "ShiftEnter"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                const i = t.editing.view;
                const o = i.document;
                e.register("softBreak", {allowWhere: "$text", isInline: true});
                n.for("upcast").elementToElement({model: "softBreak", view: "br"});
                n.for("downcast").elementToElement({
                    model: "softBreak",
                    view: (t, {writer: e}) => e.createEmptyElement("br")
                });
                i.addObserver(nD);
                t.commands.add("shiftEnter", new oD(t));
                this.listenTo(o, "enter", ((e, n) => {
                    if (!o.isComposing) {
                        n.preventDefault()
                    }
                    if (!n.isSoft) {
                        return
                    }
                    t.execute("shiftEnter");
                    i.scrollToTheSelection()
                }), {priority: "low"})
            }
        }

        class dD extends vc {
            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.schema;
                const i = e.document.selection;
                const o = Array.from(i.getSelectedBlocks());
                const r = t.forceValue === undefined ? !this.value : t.forceValue;
                e.change((t => {
                    if (!r) {
                        this._removeQuote(t, o.filter(uD))
                    } else {
                        const e = o.filter((t => uD(t) || fD(n, t)));
                        this._applyQuote(t, e)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model.document.selection;
                const e = sc(t.getSelectedBlocks());
                return !!(e && uD(e))
            }

            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = sc(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return fD(e, n)
            }

            _removeQuote(t, e) {
                hD(t, e).reverse().forEach((e => {
                    if (e.start.isAtStart && e.end.isAtEnd) {
                        t.unwrap(e.start.parent);
                        return
                    }
                    if (e.start.isAtStart) {
                        const n = t.createPositionBefore(e.start.parent);
                        t.move(e, n);
                        return
                    }
                    if (!e.end.isAtEnd) {
                        t.split(e.end)
                    }
                    const n = t.createPositionAfter(e.end.parent);
                    t.move(e, n)
                }))
            }

            _applyQuote(t, e) {
                const n = [];
                hD(t, e).reverse().forEach((e => {
                    let i = uD(e.start);
                    if (!i) {
                        i = t.createElement("blockQuote");
                        t.wrap(e, i)
                    }
                    n.push(i)
                }));
                n.reverse().reduce(((e, n) => {
                    if (e.nextSibling == n) {
                        t.merge(t.createPositionAfter(e));
                        return e
                    }
                    return n
                }))
            }
        }

        function uD(t) {
            return t.parent.name == "blockQuote" ? t.parent : null
        }

        function hD(t, e) {
            let n;
            let i = 0;
            const o = [];
            while (i < e.length) {
                const r = e[i];
                const s = e[i + 1];
                if (!n) {
                    n = t.createPositionBefore(r)
                }
                if (!s || r.nextSibling != s) {
                    o.push(t.createRange(n, t.createPositionAfter(r)));
                    n = null
                }
                i++
            }
            return o
        }

        function fD(t, e) {
            const n = t.checkChild(e.parent, "blockQuote");
            const i = t.checkChild(["$root", "blockQuote"], e);
            return n && i
        }

        class gD extends Ac {
            static get pluginName() {
                return "BlockQuoteEditing"
            }

            static get requires() {
                return [iD, nE]
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                t.commands.add("blockQuote", new dD(t));
                e.register("blockQuote", {inheritAllFrom: "$container"});
                t.conversion.elementToElement({model: "blockQuote", view: "blockquote"});
                t.model.document.registerPostFixer((n => {
                    const i = t.model.document.differ.getChanges();
                    for (const t of i) {
                        if (t.type == "insert") {
                            const i = t.position.nodeAfter;
                            if (!i) {
                                continue
                            }
                            if (i.is("element", "blockQuote") && i.isEmpty) {
                                n.remove(i);
                                return true
                            } else if (i.is("element", "blockQuote") && !e.checkChild(t.position, i)) {
                                n.unwrap(i);
                                return true
                            } else if (i.is("element")) {
                                const t = n.createRangeIn(i);
                                for (const i of t.getItems()) {
                                    if (i.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(i), i)) {
                                        n.unwrap(i);
                                        return true
                                    }
                                }
                            }
                        } else if (t.type == "remove") {
                            const e = t.position.parent;
                            if (e.is("element", "blockQuote") && e.isEmpty) {
                                n.remove(e);
                                return true
                            }
                        }
                    }
                    return false
                }));
                const n = this.editor.editing.view.document;
                const i = t.model.document.selection;
                const o = t.commands.get("blockQuote");
                this.listenTo(n, "enter", ((e, n) => {
                    if (!i.isCollapsed || !o.value) {
                        return
                    }
                    const r = i.getLastPosition().parent;
                    if (r.isEmpty) {
                        t.execute("blockQuote");
                        t.editing.view.scrollToTheSelection();
                        n.preventDefault();
                        e.stop()
                    }
                }), {context: "blockquote"});
                this.listenTo(n, "delete", ((e, n) => {
                    if (n.direction != "backward" || !i.isCollapsed || !o.value) {
                        return
                    }
                    const r = i.getLastPosition().parent;
                    if (r.isEmpty && !r.previousSibling) {
                        t.execute("blockQuote");
                        t.editing.view.scrollToTheSelection();
                        n.preventDefault();
                        e.stop()
                    }
                }), {context: "blockquote"})
            }
        }

        var mD = n(636);
        var pD = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        pD.insert = "head";
        pD.singleton = true;
        var bD = Bc()(mD.Z, pD);
        const kD = mD.Z.locals || {};

        class wD extends Ac {
            static get pluginName() {
                return "BlockQuoteUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("blockQuote", (n => {
                    const i = t.commands.get("blockQuote");
                    const o = new LC(n);
                    o.set({label: e("Block quote"), icon: CC.quote, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("blockQuote");
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class _D extends Ac {
            static get requires() {
                return [gD, wD]
            }

            static get pluginName() {
                return "BlockQuote"
            }
        }

        class AD extends vc {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = this._getValueFromFirstAllowedNode();
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.forceValue === undefined ? !this.value : t.forceValue;
                e.change((t => {
                    if (i.isCollapsed) {
                        if (o) {
                            t.setSelectionAttribute(this.attributeKey, true)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (o) {
                                t.setAttribute(this.attributeKey, o, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }

            _getValueFromFirstAllowedNode() {
                const t = this.editor.model;
                const e = t.schema;
                const n = t.document.selection;
                if (n.isCollapsed) {
                    return n.hasAttribute(this.attributeKey)
                }
                for (const t of n.getRanges()) {
                    for (const n of t.getItems()) {
                        if (e.checkAttribute(n, this.attributeKey)) {
                            return n.hasAttribute(this.attributeKey)
                        }
                    }
                }
                return false
            }
        }

        const CD = "bold";

        class vD extends Ac {
            static get pluginName() {
                return "BoldEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: CD});
                t.model.schema.setAttributeProperties(CD, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: CD, view: "strong", upcastAlso: ["b", t => {
                        const e = t.getStyle("font-weight");
                        if (!e) {
                            return null
                        }
                        if (e == "bold" || Number(e) >= 600) {
                            return {name: true, styles: ["font-weight"]}
                        }
                    }]
                });
                t.commands.add(CD, new AD(t, CD));
                t.keystrokes.set("CTRL+B", CD)
            }
        }

        const yD = "bold";

        class xD extends Ac {
            static get pluginName() {
                return "BoldUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(yD, (n => {
                    const i = t.commands.get(yD);
                    const o = new LC(n);
                    o.set({label: e("Bold"), icon: CC.bold, keystroke: "CTRL+B", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(yD);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class ED extends Ac {
            static get requires() {
                return [vD, xD]
            }

            static get pluginName() {
                return "Bold"
            }
        }

        const SD = "code";
        const DD = "ck-code_selected";

        class TD extends Ac {
            static get pluginName() {
                return "CodeEditing"
            }

            static get requires() {
                return [sE]
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: SD});
                t.model.schema.setAttributeProperties(SD, {isFormatting: true, copyOnEnter: false});
                t.conversion.attributeToElement({
                    model: SD,
                    view: "code",
                    upcastAlso: {styles: {"word-wrap": "break-word"}}
                });
                t.commands.add(SD, new AD(t, SD));
                t.plugins.get(sE).registerAttribute(SD);
                DE(t, SD, "code", DD)
            }
        }

        const BD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
        var PD = n(8180);
        var ID = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        ID.insert = "head";
        ID.singleton = true;
        var RD = Bc()(PD.Z, ID);
        const zD = PD.Z.locals || {};
        const VD = "code";

        class FD extends Ac {
            static get pluginName() {
                return "CodeUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(VD, (n => {
                    const i = t.commands.get(VD);
                    const o = new LC(n);
                    o.set({label: e("Code"), icon: BD, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(VD);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class LD extends Ac {
            static get requires() {
                return [TD, FD]
            }

            static get pluginName() {
                return "Code"
            }
        }

        function OD(t) {
            const e = t.t;
            const n = t.config.get("codeBlock.languages");
            for (const t of n) {
                if (t.label === "Plain text") {
                    t.label = e("Plain text")
                }
                if (t.class === undefined) {
                    t.class = `language-${t.language}`
                }
            }
            return n
        }

        function ND(t, e, n) {
            const i = {};
            for (const o of t) {
                if (e === "class") {
                    i[o[e].split(" ").shift()] = o[n]
                } else {
                    i[o[e]] = o[n]
                }
            }
            return i
        }

        function MD(t) {
            return t.data.match(/^(\s*)/)[0]
        }

        function HD(t, e) {
            const n = t.createDocumentFragment();
            const i = e.split("\n");
            const o = i.reduce(((e, n, o) => {
                e.push(n);
                if (o < i.length - 1) {
                    e.push(t.createElement("br"))
                }
                return e
            }), []);
            t.appendChild(o, n);
            return n
        }

        function WD(t) {
            const e = t.document.selection;
            const n = [];
            if (e.isCollapsed) {
                n.push(e.anchor)
            } else {
                const i = e.getFirstRange().getWalker({ignoreElementEnd: true, direction: "backward"});
                for (const {item: e} of i) {
                    if (e.is("$textProxy") && e.parent.is("element", "codeBlock")) {
                        const i = MD(e.textNode);
                        const {parent: o, startOffset: r} = e.textNode;
                        const s = t.createPositionAt(o, r + i.length);
                        n.push(s)
                    }
                }
            }
            return n
        }

        function qD(t) {
            const e = sc(t.getSelectedBlocks());
            return e && e.is("element", "codeBlock")
        }

        function jD(t, e) {
            if (e.is("rootElement") || t.isLimit(e)) {
                return false
            }
            return t.checkChild(e.parent, "codeBlock")
        }

        class $D extends vc {
            constructor(t) {
                super(t);
                this._lastLanguage = null
            }

            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor;
                const n = e.model;
                const i = n.document.selection;
                const o = OD(e);
                const r = o[0];
                const s = Array.from(i.getSelectedBlocks());
                const a = t.forceValue === undefined ? !this.value : t.forceValue;
                const l = UD(t, this._lastLanguage, r.language);
                n.change((t => {
                    if (a) {
                        this._applyCodeBlock(t, s, l)
                    } else {
                        this._removeCodeBlock(t, s)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model.document.selection;
                const e = sc(t.getSelectedBlocks());
                const n = !!(e && e.is("element", "codeBlock"));
                return n ? e.getAttribute("language") : false
            }

            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = sc(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return jD(e, n)
            }

            _applyCodeBlock(t, e, n) {
                this._lastLanguage = n;
                const i = this.editor.model.schema;
                const o = e.filter((t => jD(i, t)));
                for (const e of o) {
                    t.rename(e, "codeBlock");
                    t.setAttribute("language", n, e);
                    i.removeDisallowedAttributes([e], t);
                    Array.from(e.getChildren()).filter((t => !i.checkChild(e, t))).forEach((e => t.remove(e)))
                }
                o.reverse().forEach(((e, n) => {
                    const i = o[n + 1];
                    if (e.previousSibling === i) {
                        t.appendElement("softBreak", i);
                        t.merge(t.createPositionBefore(e))
                    }
                }))
            }

            _removeCodeBlock(t, e) {
                const n = e.filter((t => t.is("element", "codeBlock")));
                for (const e of n) {
                    const n = t.createRangeOn(e);
                    for (const e of Array.from(n.getItems()).reverse()) {
                        if (e.is("element", "softBreak") && e.parent.is("element", "codeBlock")) {
                            const {position: n} = t.split(t.createPositionBefore(e));
                            t.rename(n.nodeAfter, "paragraph");
                            t.removeAttribute("language", n.nodeAfter);
                            t.remove(e)
                        }
                    }
                    t.rename(e, "paragraph");
                    t.removeAttribute("language", e)
                }
            }
        }

        function UD(t, e, n) {
            if (t.language) {
                return t.language
            }
            if (t.usePreviousLanguageChoice && e) {
                return e
            }
            return n
        }

        class GD extends vc {
            constructor(t) {
                super(t);
                this._indentSequence = t.config.get("codeBlock.indentSequence")
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor;
                const e = t.model;
                e.change((t => {
                    const n = WD(e);
                    for (const i of n) {
                        const n = t.createText(this._indentSequence);
                        e.insertContent(n, i)
                    }
                }))
            }

            _checkEnabled() {
                if (!this._indentSequence) {
                    return false
                }
                return qD(this.editor.model.document.selection)
            }
        }

        class KD extends vc {
            constructor(t) {
                super(t);
                this._indentSequence = t.config.get("codeBlock.indentSequence")
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor;
                const e = t.model;
                e.change((() => {
                    const t = WD(e);
                    for (const n of t) {
                        const t = ZD(e, n, this._indentSequence);
                        if (t) {
                            e.deleteContent(e.createSelection(t))
                        }
                    }
                }))
            }

            _checkEnabled() {
                if (!this._indentSequence) {
                    return false
                }
                const t = this.editor.model;
                if (!qD(t.document.selection)) {
                    return false
                }
                return WD(t).some((e => ZD(t, e, this._indentSequence)))
            }
        }

        function ZD(t, e, n) {
            const i = JD(e);
            if (!i) {
                return null
            }
            const o = MD(i);
            const r = o.lastIndexOf(n);
            if (r + n.length !== o.length) {
                return null
            }
            if (r === -1) {
                return null
            }
            const {parent: s, startOffset: a} = i;
            return t.createRange(t.createPositionAt(s, a + r), t.createPositionAt(s, a + r + n.length))
        }

        function JD(t) {
            let e = t.parent.getChild(t.index);
            if (!e || e.is("element", "softBreak")) {
                e = t.nodeBefore
            }
            if (!e || e.is("element", "softBreak")) {
                return null
            }
            return e
        }

        function YD(t, e, n = false) {
            const i = ND(e, "language", "class");
            const o = ND(e, "language", "label");
            return (e, r, s) => {
                const {writer: a, mapper: l, consumable: c} = s;
                if (!c.consume(r.item, "insert")) {
                    return
                }
                const d = r.item.getAttribute("language");
                const u = l.toViewPosition(t.createPositionBefore(r.item));
                const h = {};
                if (n) {
                    h["data-language"] = o[d];
                    h.spellcheck = "false"
                }
                const f = a.createContainerElement("code", {class: i[d] || null});
                const g = a.createContainerElement("pre", h, f);
                a.insert(u, g);
                l.bindElements(r.item, f)
            }
        }

        function QD(t) {
            return (e, n, i) => {
                if (n.item.parent.name !== "codeBlock") {
                    return
                }
                const {writer: o, mapper: r, consumable: s} = i;
                if (!s.consume(n.item, "insert")) {
                    return
                }
                const a = r.toViewPosition(t.createPositionBefore(n.item));
                o.insert(a, o.createText("\n"))
            }
        }

        function XD(t, e) {
            const n = ND(e, "class", "language");
            const i = e[0].language;
            return (t, e, o) => {
                const r = e.viewItem;
                const s = r.parent;
                if (!s || !s.is("element", "pre")) {
                    return
                }
                if (e.modelCursor.findAncestor("codeBlock")) {
                    return
                }
                const {consumable: a, writer: l} = o;
                if (!a.test(r, {name: true})) {
                    return
                }
                const c = l.createElement("codeBlock");
                const d = [...r.getClassNames()];
                if (!d.length) {
                    d.push("")
                }
                for (const t of d) {
                    const e = n[t];
                    if (e) {
                        l.setAttribute("language", e, c);
                        break
                    }
                }
                if (!c.hasAttribute("language")) {
                    l.setAttribute("language", i, c)
                }
                o.convertChildren(r, c);
                if (!o.safeInsert(c, e.modelCursor)) {
                    return
                }
                a.consume(r, {name: true});
                o.updateConversionResult(c, e)
            }
        }

        function tT() {
            return (t, e, {consumable: n, writer: i}) => {
                let o = e.modelCursor;
                if (!n.test(e.viewItem)) {
                    return
                }
                if (!o.findAncestor("codeBlock")) {
                    return
                }
                n.consume(e.viewItem);
                const r = e.viewItem.data;
                const s = r.split("\n").map((t => i.createText(t)));
                const a = s[s.length - 1];
                for (const t of s) {
                    i.insert(t, o);
                    o = o.getShiftedBy(t.offsetSize);
                    if (t !== a) {
                        const t = i.createElement("softBreak");
                        i.insert(t, o);
                        o = i.createPositionAfter(t)
                    }
                }
                e.modelRange = i.createRange(e.modelCursor, o);
                e.modelCursor = o
            }
        }

        function eT() {
            return (t, e, {consumable: n}) => {
                const i = e.viewItem;
                if (i.findAncestor("pre")) {
                    return
                }
                const o = Array.from(i.getChildren());
                const r = o.find((t => t.is("element", "code")));
                if (!r) {
                    return
                }
                for (const t of o) {
                    if (t === r || !t.is("$text")) {
                        continue
                    }
                    n.consume(t, {name: true})
                }
            }
        }

        const nT = "paragraph";

        class iT extends Ac {
            static get pluginName() {
                return "CodeBlockEditing"
            }

            static get requires() {
                return [cD]
            }

            constructor(t) {
                super(t);
                t.config.define("codeBlock", {
                    languages: [{language: "plaintext", label: "Plain text"}, {
                        language: "c",
                        label: "C"
                    }, {language: "cs", label: "C#"}, {language: "cpp", label: "C++"}, {
                        language: "css",
                        label: "CSS"
                    }, {language: "diff", label: "Diff"}, {language: "html", label: "HTML"}, {
                        language: "java",
                        label: "Java"
                    }, {language: "javascript", label: "JavaScript"}, {
                        language: "php",
                        label: "PHP"
                    }, {language: "python", label: "Python"}, {
                        language: "ruby",
                        label: "Ruby"
                    }, {language: "typescript", label: "TypeScript"}, {language: "xml", label: "XML"}],
                    indentSequence: "\t"
                })
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.model;
                const i = t.editing.view;
                const o = t.plugins.has("DocumentListEditing");
                const r = OD(t);
                t.commands.add("codeBlock", new $D(t));
                t.commands.add("indentCodeBlock", new GD(t));
                t.commands.add("outdentCodeBlock", new KD(t));
                this.listenTo(i.document, "tab", ((e, n) => {
                    const i = n.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
                    const o = t.commands.get(i);
                    if (!o.isEnabled) {
                        return
                    }
                    t.execute(i);
                    n.stopPropagation();
                    n.preventDefault();
                    e.stop()
                }), {context: "pre"});
                e.register("codeBlock", {
                    allowWhere: "$block",
                    allowChildren: "$text",
                    isBlock: true,
                    allowAttributes: ["language"]
                });
                e.addAttributeCheck(((t, e) => {
                    const n = t.endsWith("codeBlock") && e.startsWith("list") && e !== "list";
                    if (o && n) {
                        return true
                    }
                    if (t.endsWith("codeBlock $text")) {
                        return false
                    }
                }));
                t.model.schema.addChildCheck(((t, e) => {
                    if (t.endsWith("codeBlock") && e.isObject) {
                        return false
                    }
                }));
                t.editing.downcastDispatcher.on("insert:codeBlock", YD(n, r, true));
                t.data.downcastDispatcher.on("insert:codeBlock", YD(n, r));
                t.data.downcastDispatcher.on("insert:softBreak", QD(n), {priority: "high"});
                t.data.upcastDispatcher.on("element:code", XD(i, r));
                t.data.upcastDispatcher.on("text", tT());
                t.data.upcastDispatcher.on("element:pre", eT(), {priority: "high"});
                this.listenTo(t.editing.view.document, "clipboardInput", ((e, i) => {
                    let o = n.createRange(n.document.selection.anchor);
                    if (i.targetRanges) {
                        o = t.editing.mapper.toModelRange(i.targetRanges[0])
                    }
                    if (!o.start.parent.is("element", "codeBlock")) {
                        return
                    }
                    const r = i.dataTransfer.getData("text/plain");
                    const s = new Mw(t.editing.view.document);
                    i.content = HD(s, r)
                }));
                this.listenTo(n, "getSelectedContent", ((t, [i]) => {
                    const o = i.anchor;
                    if (i.isCollapsed || !o.parent.is("element", "codeBlock") || !o.hasSameParentAs(i.focus)) {
                        return
                    }
                    n.change((n => {
                        const r = t.return;
                        if (r.childCount > 1 || i.containsEntireContent(o.parent)) {
                            const e = n.createElement("codeBlock", o.parent.getAttributes());
                            n.append(r, e);
                            const i = n.createDocumentFragment();
                            n.append(e, i);
                            t.return = i
                        } else {
                            const t = r.getChild(0);
                            if (e.checkAttribute(t, "code")) {
                                n.setAttribute("code", true, t)
                            }
                        }
                    }))
                }))
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands;
                const n = e.get("indent");
                const i = e.get("outdent");
                if (n) {
                    n.registerChildCommand(e.get("indentCodeBlock"), {priority: "highest"})
                }
                if (i) {
                    i.registerChildCommand(e.get("outdentCodeBlock"))
                }
                this.listenTo(t.editing.view.document, "enter", ((e, n) => {
                    const i = t.model.document.selection.getLastPosition().parent;
                    if (!i.is("element", "codeBlock")) {
                        return
                    }
                    if (!rT(t, n.isSoft) && !sT(t, n.isSoft)) {
                        oT(t)
                    }
                    n.preventDefault();
                    e.stop()
                }), {context: "pre"})
            }
        }

        function oT(t) {
            const e = t.model;
            const n = e.document;
            const i = n.selection.getLastPosition();
            const o = i.nodeBefore || i.textNode;
            let r;
            if (o && o.is("$text")) {
                r = MD(o)
            }
            t.model.change((e => {
                t.execute("shiftEnter");
                if (r) {
                    e.insertText(r, n.selection.anchor)
                }
            }))
        }

        function rT(t, e) {
            const n = t.model;
            const i = n.document;
            const o = t.editing.view;
            const r = i.selection.getLastPosition();
            const s = r.nodeAfter;
            if (e || !i.selection.isCollapsed || !r.isAtStart) {
                return false
            }
            if (!lT(s)) {
                return false
            }
            t.model.change((e => {
                t.execute("enter");
                const n = i.selection.anchor.parent.previousSibling;
                e.rename(n, nT);
                e.setSelection(n, "in");
                t.model.schema.removeDisallowedAttributes([n], e);
                e.remove(s)
            }));
            o.scrollToTheSelection();
            return true
        }

        function sT(t, e) {
            const n = t.model;
            const i = n.document;
            const o = t.editing.view;
            const r = i.selection.getLastPosition();
            const s = r.nodeBefore;
            let a;
            if (e || !i.selection.isCollapsed || !r.isAtEnd || !s || !s.previousSibling) {
                return false
            }
            if (lT(s) && lT(s.previousSibling)) {
                a = n.createRange(n.createPositionBefore(s.previousSibling), n.createPositionAfter(s))
            } else if (aT(s) && lT(s.previousSibling) && lT(s.previousSibling.previousSibling)) {
                a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling), n.createPositionAfter(s))
            } else if (aT(s) && lT(s.previousSibling) && aT(s.previousSibling.previousSibling) && lT(s.previousSibling.previousSibling.previousSibling)) {
                a = n.createRange(n.createPositionBefore(s.previousSibling.previousSibling.previousSibling), n.createPositionAfter(s))
            } else {
                return false
            }
            t.model.change((e => {
                e.remove(a);
                t.execute("enter");
                const n = i.selection.anchor.parent;
                e.rename(n, nT);
                t.model.schema.removeDisallowedAttributes([n], e)
            }));
            o.scrollToTheSelection();
            return true
        }

        function aT(t) {
            return t && t.is("$text") && !t.data.match(/\S/)
        }

        function lT(t) {
            return t && t.is("element", "softBreak")
        }

        const cT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
        var dT = n(9085);
        var uT = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        uT.insert = "head";
        uT.singleton = true;
        var hT = Bc()(dT.Z, uT);
        const fT = dT.Z.locals || {};

        class gT extends Ac {
            static get pluginName() {
                return "CodeBlockUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = t.ui.componentFactory;
                const i = OD(t);
                n.add("codeBlock", (n => {
                    const o = t.commands.get("codeBlock");
                    const r = qv(n, rv);
                    const s = r.buttonView;
                    s.set({label: e("Insert code block"), tooltip: true, icon: cT, isToggleable: true});
                    s.bind("isOn").to(o, "value", (t => !!t));
                    s.on("execute", (() => {
                        t.execute("codeBlock", {usePreviousLanguageChoice: true});
                        t.editing.view.focus()
                    }));
                    r.on("execute", (e => {
                        t.execute("codeBlock", {language: e.source._codeBlockLanguage, forceValue: true});
                        t.editing.view.focus()
                    }));
                    r.class = "ck-code-block-dropdown";
                    r.bind("isEnabled").to(o);
                    $v(r, this._getLanguageListItemDefinitions(i));
                    return r
                }))
            }

            _getLanguageListItemDefinitions(t) {
                const e = this.editor;
                const n = e.commands.get("codeBlock");
                const i = new rc;
                for (const e of t) {
                    const t = {
                        type: "button",
                        model: new Fy({_codeBlockLanguage: e.language, label: e.label, withText: true})
                    };
                    t.model.bind("isOn").to(n, "value", (e => e === t.model._codeBlockLanguage));
                    i.add(t)
                }
                return i
            }
        }

        class mT extends Ac {
            static get requires() {
                return [iT, gT]
            }

            static get pluginName() {
                return "CodeBlock"
            }
        }

        const pT = {
            block: [{model: "codeBlock", view: "pre"}, {model: "paragraph", view: "p"}, {
                model: "blockQuote",
                view: "blockquote"
            }, {model: "listItem", view: "li"}, {model: "pageBreak", view: "div"}, {
                model: "rawHtml",
                view: "div"
            }, {model: "table", view: "table"}, {model: "tableRow", view: "tr"}, {
                model: "tableCell",
                view: "td"
            }, {model: "tableCell", view: "th"}, {model: "caption", view: "caption"}, {
                model: "caption",
                view: "figcaption"
            }, {model: "imageBlock", view: "img"}, {model: "imageInline", view: "img"}, {
                model: "htmlP",
                view: "p",
                modelSchema: {inheritAllFrom: "$block"}
            }, {
                model: "htmlBlockquote",
                view: "blockquote",
                modelSchema: {inheritAllFrom: "$container"}
            }, {
                model: "htmlTable",
                view: "table",
                modelSchema: {allowWhere: "$block", isBlock: true}
            }, {
                model: "htmlTbody",
                view: "tbody",
                modelSchema: {allowIn: "htmlTable", isBlock: false}
            }, {
                model: "htmlThead",
                view: "thead",
                modelSchema: {allowIn: "htmlTable", isBlock: false}
            }, {
                model: "htmlTfoot",
                view: "tfoot",
                modelSchema: {allowIn: "htmlTable", isBlock: false}
            }, {
                model: "htmlCaption",
                view: "caption",
                modelSchema: {allowIn: "htmlTable", allowChildren: "$text", isBlock: false}
            }, {
                model: "htmlColgroup",
                view: "colgroup",
                modelSchema: {allowIn: "htmlTable", allowChildren: "col", isBlock: false}
            }, {
                model: "htmlCol",
                view: "col",
                modelSchema: {allowIn: "htmlColgroup", isBlock: false}
            }, {
                model: "htmlTr",
                view: "tr",
                modelSchema: {allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: true}
            }, {
                model: "htmlTd",
                view: "td",
                modelSchema: {allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false}
            }, {
                model: "htmlTh",
                view: "th",
                modelSchema: {allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false}
            }, {
                model: "htmlFigure",
                view: "figure",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlFigcaption",
                view: "figcaption",
                modelSchema: {allowIn: "htmlFigure", allowChildren: "$text", isBlock: false}
            }, {
                model: "htmlAddress",
                view: "address",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlAside",
                view: "aside",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlMain",
                view: "main",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlDetails",
                view: "details",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlSummary",
                view: "summary",
                modelSchema: {allowChildren: "$text", allowIn: "htmlDetails", isBlock: false}
            }, {
                model: "htmlDiv",
                view: "div",
                paragraphLikeModel: "htmlDivParagraph",
                modelSchema: {inheritAllFrom: "$container"}
            }, {
                model: "htmlFieldset",
                view: "fieldset",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlLegend",
                view: "legend",
                modelSchema: {allowIn: "htmlFieldset", allowChildren: "$text"}
            }, {
                model: "htmlHeader",
                view: "header",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlFooter",
                view: "footer",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlForm",
                view: "form",
                modelSchema: {inheritAllFrom: "$container", isBlock: true}
            }, {
                model: "htmlHgroup",
                view: "hgroup",
                modelSchema: {
                    allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"],
                    isBlock: false
                }
            }, {model: "htmlH1", view: "h1", modelSchema: {inheritAllFrom: "$block"}}, {
                model: "htmlH2",
                view: "h2",
                modelSchema: {inheritAllFrom: "$block"}
            }, {model: "htmlH3", view: "h3", modelSchema: {inheritAllFrom: "$block"}}, {
                model: "htmlH4",
                view: "h4",
                modelSchema: {inheritAllFrom: "$block"}
            }, {model: "htmlH5", view: "h5", modelSchema: {inheritAllFrom: "$block"}}, {
                model: "htmlH6",
                view: "h6",
                modelSchema: {inheritAllFrom: "$block"}
            }, {
                model: "$htmlList",
                modelSchema: {allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: false}
            }, {model: "htmlDir", view: "dir", modelSchema: {inheritAllFrom: "$htmlList"}}, {
                model: "htmlMenu",
                view: "menu",
                modelSchema: {inheritAllFrom: "$htmlList"}
            }, {model: "htmlUl", view: "ul", modelSchema: {inheritAllFrom: "$htmlList"}}, {
                model: "htmlOl",
                view: "ol",
                modelSchema: {inheritAllFrom: "$htmlList"}
            }, {
                model: "htmlLi",
                view: "li",
                modelSchema: {allowIn: "$htmlList", allowChildren: "$text", isBlock: false}
            }, {model: "htmlPre", view: "pre", modelSchema: {inheritAllFrom: "$block"}}, {
                model: "htmlArticle",
                view: "article",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlSection",
                view: "section",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlNav",
                view: "nav",
                modelSchema: {inheritAllFrom: "$container", isBlock: false}
            }, {
                model: "htmlDl",
                view: "dl",
                modelSchema: {allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd"], isBlock: false}
            }, {model: "htmlDt", view: "dt", modelSchema: {allowChildren: "$block", isBlock: false}}, {
                model: "htmlDd",
                view: "dd",
                modelSchema: {allowChildren: "$block", isBlock: false}
            }, {model: "htmlCenter", view: "center", modelSchema: {inheritAllFrom: "$container", isBlock: false}}],
            inline: [{
                model: "htmlAcronym",
                view: "acronym",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlTt", view: "tt", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlFont",
                view: "font",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlTime", view: "time", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlVar",
                view: "var",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlBig", view: "big", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlSmall",
                view: "small",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlSamp", view: "samp", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlQ",
                view: "q",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlOutput", view: "output", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlKbd",
                view: "kbd",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlBdi", view: "bdi", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlBdo",
                view: "bdo",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlAbbr", view: "abbr", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlA",
                view: "a",
                priority: 5,
                coupledAttribute: "linkHref",
                attributeProperties: {copyOnEnter: true}
            }, {
                model: "htmlStrong",
                view: "strong",
                coupledAttribute: "bold",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlB",
                view: "b",
                coupledAttribute: "bold",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlI",
                view: "i",
                coupledAttribute: "italic",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlEm",
                view: "em",
                coupledAttribute: "italic",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlS",
                view: "s",
                coupledAttribute: "strikethrough",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlDel",
                view: "del",
                coupledAttribute: "strikethrough",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlIns", view: "ins", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlU",
                view: "u",
                coupledAttribute: "underline",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlSub",
                view: "sub",
                coupledAttribute: "subscript",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlSup",
                view: "sup",
                coupledAttribute: "superscript",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {
                model: "htmlCode",
                view: "code",
                coupledAttribute: "code",
                attributeProperties: {copyOnEnter: true, isFormatting: true}
            }, {model: "htmlMark", view: "mark", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlSpan",
                view: "span",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlCite", view: "cite", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlLabel",
                view: "label",
                attributeProperties: {copyOnEnter: true}
            }, {model: "htmlDfn", view: "dfn", attributeProperties: {copyOnEnter: true}}, {
                model: "htmlObject",
                view: "object",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlIframe",
                view: "iframe",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlInput",
                view: "input",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlButton",
                view: "button",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlTextarea",
                view: "textarea",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlSelect",
                view: "select",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlVideo",
                view: "video",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlEmbed",
                view: "embed",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlOembed",
                view: "oembed",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlAudio",
                view: "audio",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlImg",
                view: "img",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlCanvas",
                view: "canvas",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlMeter",
                view: "meter",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlProgress",
                view: "progress",
                isObject: true,
                modelSchema: {inheritAllFrom: "$inlineObject"}
            }, {
                model: "htmlScript",
                view: "script",
                modelSchema: {allowWhere: ["$text", "$block"], isInline: true}
            }, {
                model: "htmlStyle",
                view: "style",
                modelSchema: {allowWhere: ["$text", "$block"], isInline: true}
            }, {
                model: "htmlCustomElement",
                view: "$customElement",
                modelSchema: {allowWhere: ["$text", "$block"], isInline: true}
            }]
        };
        var bT = Lu((function (t, e, n, i) {
            fu(t, e, n, i)
        }));
        const kT = bT;

        class wT extends Ac {
            constructor(t) {
                super(t);
                this._definitions = new Map
            }

            static get pluginName() {
                return "DataSchema"
            }

            init() {
                for (const t of pT.block) {
                    this.registerBlockElement(t)
                }
                for (const t of pT.inline) {
                    this.registerInlineElement(t)
                }
            }

            registerBlockElement(t) {
                this._definitions.set(t.model, {...t, isBlock: true})
            }

            registerInlineElement(t) {
                this._definitions.set(t.model, {...t, isInline: true})
            }

            extendBlockElement(t) {
                this._extendDefinition({...t, isBlock: true})
            }

            extendInlineElement(t) {
                this._extendDefinition({...t, isInline: true})
            }

            getDefinitionsForView(t, e) {
                const n = new Set;
                for (const i of this._getMatchingViewDefinitions(t)) {
                    if (e) {
                        for (const t of this._getReferences(i.model)) {
                            n.add(t)
                        }
                    }
                    n.add(i)
                }
                return n
            }

            _getMatchingViewDefinitions(t) {
                return Array.from(this._definitions.values()).filter((e => e.view && _T(t, e.view)))
            }

            * _getReferences(t) {
                const {modelSchema: e} = this._definitions.get(t);
                if (!e) {
                    return
                }
                const n = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"];
                for (const i of n) {
                    for (const n of Zl(e[i] || [])) {
                        const e = this._definitions.get(n);
                        if (n !== t && e) {
                            yield* this._getReferences(e.model);
                            yield e
                        }
                    }
                }
            }

            _extendDefinition(t) {
                const e = this._definitions.get(t.model);
                const n = kT({}, e, t, ((t, e) => Array.isArray(t) ? t.concat(e) : undefined));
                this._definitions.set(t.model, n)
            }
        }

        function _T(t, e) {
            if (typeof t === "string") {
                return t === e
            }
            if (t instanceof RegExp) {
                return t.test(e)
            }
            return false
        }

        class AT {
            constructor(t, e) {
                this._startElement = t;
                this._referenceIndent = t.getAttribute("listIndent");
                this._isForward = e.direction == "forward";
                this._includeSelf = !!e.includeSelf;
                this._sameAttributes = Zl(e.sameAttributes || []);
                this._sameIndent = !!e.sameIndent;
                this._lowerIndent = !!e.lowerIndent;
                this._higherIndent = !!e.higherIndent
            }

            static first(t, e) {
                const n = new this(t, e);
                const i = n[Symbol.iterator]();
                return sc(i)
            }

            * [Symbol.iterator]() {
                const t = [];
                for (const {node: e} of CT(this._getStartNode(), this._isForward ? "forward" : "backward")) {
                    const n = e.getAttribute("listIndent");
                    if (n < this._referenceIndent) {
                        if (!this._lowerIndent) {
                            break
                        }
                        this._referenceIndent = n
                    } else if (n > this._referenceIndent) {
                        if (!this._higherIndent) {
                            continue
                        }
                        if (!this._isForward) {
                            t.push(e);
                            continue
                        }
                    } else {
                        if (!this._sameIndent) {
                            if (this._higherIndent) {
                                if (t.length) {
                                    yield* t;
                                    t.length = 0
                                }
                                break
                            }
                            continue
                        }
                        if (this._sameAttributes.some((t => e.getAttribute(t) !== this._startElement.getAttribute(t)))) {
                            break
                        }
                    }
                    if (t.length) {
                        yield* t;
                        t.length = 0
                    }
                    yield e
                }
            }

            _getStartNode() {
                if (this._includeSelf) {
                    return this._startElement
                }
                return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling
            }
        }

        function* CT(t, e = "forward") {
            const n = e == "forward";
            let i = null;
            while (xT(t)) {
                yield{node: t, previous: i};
                i = t;
                t = n ? t.nextSibling : t.previousSibling
            }
        }

        class vT {
            constructor(t) {
                this._listHead = t
            }

            [Symbol.iterator]() {
                return CT(this._listHead, "forward")
            }
        }

        class yT {
            static next() {
                return E()
            }
        }

        function xT(t) {
            return !!t && t.is("element") && t.hasAttribute("listItemId")
        }

        function ET(t, e = {}) {
            return [...ST(t, {...e, direction: "backward"}), ...ST(t, {...e, direction: "forward"})]
        }

        function ST(t, e = {}) {
            const n = e.direction == "forward";
            const i = Array.from(new AT(t, {...e, includeSelf: n, sameIndent: true, sameAttributes: "listItemId"}));
            return n ? i : i.reverse()
        }

        function DT(t) {
            return Array.from(new AT(t, {direction: "forward", higherIndent: true}))
        }

        function TT(t) {
            const e = new AT(t, {sameIndent: true, sameAttributes: "listType"});
            const n = new AT(t, {
                sameIndent: true,
                sameAttributes: "listType",
                includeSelf: true,
                direction: "forward"
            });
            return [...Array.from(e).reverse(), ...n]
        }

        function BT(t) {
            const e = AT.first(t, {sameIndent: true, sameAttributes: "listItemId"});
            if (!e) {
                return true
            }
            return false
        }

        function PT(t) {
            const e = AT.first(t, {direction: "forward", sameIndent: true, sameAttributes: "listItemId"});
            if (!e) {
                return true
            }
            return false
        }

        function IT(t, e = {}) {
            t = Zl(t);
            const n = e.withNested !== false;
            const i = new Set;
            for (const e of t) {
                for (const t of ET(e, {higherIndent: n})) {
                    i.add(t)
                }
            }
            return HT(i)
        }

        function RT(t) {
            t = Zl(t);
            const e = new Set;
            for (const n of t) {
                for (const t of TT(n)) {
                    e.add(t)
                }
            }
            return HT(e)
        }

        function zT(t, e) {
            const n = ST(t, {direction: "forward"});
            const i = yT.next();
            for (const t of n) {
                e.setAttribute("listItemId", i, t)
            }
            return n
        }

        function VT(t, e, n) {
            const i = {};
            for (const [t, n] of e.getAttributes()) {
                if (t.startsWith("list")) {
                    i[t] = n
                }
            }
            const o = ST(t, {direction: "forward"});
            for (const t of o) {
                n.setAttributes(i, t)
            }
            return o
        }

        function FT(t, e, {expand: n, indentBy: i = 1} = {}) {
            t = Zl(t);
            const o = n ? IT(t) : t;
            for (const t of o) {
                const n = t.getAttribute("listIndent") + i;
                if (n < 0) {
                    OT(t, e)
                } else {
                    e.setAttribute("listIndent", n, t)
                }
            }
            return o
        }

        function LT(t, e) {
            t = Zl(t);
            const n = IT(t);
            const i = new Set;
            const o = Math.min(...n.map((t => t.getAttribute("listIndent"))));
            const r = new Map;
            for (const t of n) {
                r.set(t, AT.first(t, {lowerIndent: true}))
            }
            for (const t of n) {
                if (i.has(t)) {
                    continue
                }
                i.add(t);
                const n = t.getAttribute("listIndent") - 1;
                if (n < 0) {
                    OT(t, e);
                    continue
                }
                if (t.getAttribute("listIndent") == o) {
                    const n = qT(t, r.get(t), e);
                    for (const t of n) {
                        i.add(t)
                    }
                    if (n.length) {
                        continue
                    }
                }
                e.setAttribute("listIndent", n, t)
            }
            return HT(i)
        }

        function OT(t, e) {
            t = Zl(t);
            for (const n of t) {
                for (const t of n.getAttributeKeys()) {
                    if (t.startsWith("list")) {
                        e.removeAttribute(t, n)
                    }
                }
            }
            return t
        }

        function NT(t) {
            if (!t.length) {
                return false
            }
            const e = t[0].getAttribute("listItemId");
            if (!e) {
                return false
            }
            return !t.some((t => t.getAttribute("listItemId") != e))
        }

        function MT(t, e) {
            const n = [];
            let i = Number.POSITIVE_INFINITY;
            for (const {node: o} of CT(t.nextSibling, "forward")) {
                const t = o.getAttribute("listIndent");
                if (t == 0) {
                    break
                }
                if (t < i) {
                    i = t
                }
                const r = t - i;
                e.setAttribute("listIndent", r, o);
                n.push(o)
            }
            return n
        }

        function HT(t) {
            return Array.from(t).filter((t => t.root.rootName !== "$graveyard")).sort(((t, e) => t.index - e.index))
        }

        function WT(t) {
            const e = t.document.selection.getSelectedElement();
            if (!e) {
                return null
            }
            if (t.schema.isObject(e) && t.schema.isBlock(e)) {
                return e
            }
            return null
        }

        function qT(t, e, n) {
            const i = ST(e, {direction: "forward"});
            if (i.pop().index > t.index) {
                return VT(t, e, n)
            }
            return []
        }

        class jT extends vc {
            constructor(t, e) {
                super(t);
                this._direction = e
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor.model;
                const e = $T(t.document.selection);
                t.change((t => {
                    const n = [];
                    if (NT(e) && !BT(e[0])) {
                        if (this._direction == "forward") {
                            n.push(...FT(e, t))
                        }
                        n.push(...zT(e[0], t))
                    } else {
                        if (this._direction == "forward") {
                            n.push(...FT(e, t, {expand: true}))
                        } else {
                            n.push(...LT(e, t))
                        }
                    }
                    for (const e of n) {
                        if (!e.hasAttribute("listType")) {
                            continue
                        }
                        const n = AT.first(e, {sameIndent: true});
                        if (n) {
                            t.setAttribute("listType", n.getAttribute("listType"), e)
                        }
                    }
                    this._fireAfterExecute(n)
                }))
            }

            _fireAfterExecute(t) {
                this.fire("afterExecute", HT(new Set(t)))
            }

            _checkEnabled() {
                let t = $T(this.editor.model.document.selection);
                let e = t[0];
                if (!e) {
                    return false
                }
                if (this._direction == "backward") {
                    return true
                }
                if (NT(t) && !BT(t[0])) {
                    return true
                }
                t = IT(t);
                e = t[0];
                const n = AT.first(e, {sameIndent: true});
                if (!n) {
                    return false
                }
                if (n.getAttribute("listType") == e.getAttribute("listType")) {
                    return true
                }
                return false
            }
        }

        function $T(t) {
            const e = Array.from(t.getSelectedBlocks());
            const n = e.findIndex((t => !xT(t)));
            if (n != -1) {
                e.length = n
            }
            return e
        }

        class UT extends vc {
            constructor(t, e) {
                super(t);
                this.type = e
            }

            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = WT(e);
                const o = Array.from(n.selection.getSelectedBlocks()).filter((t => e.schema.checkAttribute(t, "listType")));
                const r = t.forceValue !== undefined ? !t.forceValue : this.value;
                e.change((t => {
                    if (r) {
                        const e = o[o.length - 1];
                        const n = ST(e, {direction: "forward"});
                        const i = [];
                        if (n.length > 1) {
                            i.push(...zT(n[1], t))
                        }
                        i.push(...OT(o, t));
                        i.push(...MT(e, t));
                        this._fireAfterExecute(i)
                    } else if ((i || n.selection.isCollapsed) && xT(o[0])) {
                        const e = TT(i || o[0]);
                        for (const n of e) {
                            t.setAttribute("listType", this.type, n)
                        }
                        this._fireAfterExecute(e)
                    } else {
                        const e = [];
                        for (const n of o) {
                            if (!n.hasAttribute("listType")) {
                                t.setAttributes({listIndent: 0, listItemId: yT.next(), listType: this.type}, n);
                                e.push(n)
                            } else {
                                for (const i of IT(n, {withNested: false})) {
                                    if (i.getAttribute("listType") != this.type) {
                                        t.setAttribute("listType", this.type, i);
                                        e.push(i)
                                    }
                                }
                            }
                        }
                        this._fireAfterExecute(e)
                    }
                }))
            }

            _fireAfterExecute(t) {
                this.fire("afterExecute", HT(new Set(t)))
            }

            _getValue() {
                const t = this.editor.model.document.selection;
                const e = Array.from(t.getSelectedBlocks());
                if (!e.length) {
                    return false
                }
                for (const t of e) {
                    if (t.getAttribute("listType") != this.type) {
                        return false
                    }
                }
                return true
            }

            _checkEnabled() {
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = Array.from(t.getSelectedBlocks());
                if (!n.length) {
                    return false
                }
                if (this.value) {
                    return true
                }
                for (const t of n) {
                    if (e.checkAttribute(t, "listType")) {
                        return true
                    }
                }
                return false
            }
        }

        class GT extends vc {
            constructor(t, e) {
                super(t);
                this._direction = e
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute({shouldMergeOnBlocksContentLevel: t = false} = {}) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = [];
                e.change((o => {
                    const {firstElement: r, lastElement: s} = this._getMergeSubjectElements(n, t);
                    const a = r.getAttribute("listIndent") || 0;
                    const l = s.getAttribute("listIndent");
                    const c = s.getAttribute("listItemId");
                    if (a != l) {
                        const t = DT(s);
                        i.push(...FT([s, ...t], o, {indentBy: a - l, expand: a < l}))
                    }
                    if (t) {
                        let t = n;
                        if (n.isCollapsed) {
                            t = o.createSelection(o.createRange(o.createPositionAt(r, "end"), o.createPositionAt(s, 0)))
                        }
                        e.deleteContent(t, {doNotResetEntireContent: n.isCollapsed});
                        const a = t.getLastPosition().parent;
                        const l = a.nextSibling;
                        i.push(a);
                        if (l && l !== s && l.getAttribute("listItemId") == c) {
                            i.push(...VT(l, a, o))
                        }
                    } else {
                        i.push(...VT(s, r, o))
                    }
                    this._fireAfterExecute(i)
                }))
            }

            _fireAfterExecute(t) {
                this.fire("afterExecute", HT(new Set(t)))
            }

            _checkEnabled() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = WT(t);
                if (e.isCollapsed || n) {
                    const t = n || e.getFirstPosition().parent;
                    if (!xT(t)) {
                        return false
                    }
                    const i = this._direction == "backward" ? t.previousSibling : t.nextSibling;
                    if (!i) {
                        return false
                    }
                    if (NT([t, i])) {
                        return false
                    }
                } else {
                    const t = e.getLastPosition();
                    const n = e.getFirstPosition();
                    if (t.parent === n.parent) {
                        return false
                    }
                    if (!xT(t.parent)) {
                        return false
                    }
                }
                return true
            }

            _getMergeSubjectElements(t, e) {
                const n = this.editor.model;
                const i = WT(n);
                let o, r;
                if (t.isCollapsed || i) {
                    const n = i || t.getFirstPosition().parent;
                    const s = BT(n);
                    if (this._direction == "backward") {
                        r = n;
                        if (s && !e) {
                            o = AT.first(n, {sameIndent: true, lowerIndent: true})
                        } else {
                            o = n.previousSibling
                        }
                    } else {
                        o = n;
                        r = n.nextSibling
                    }
                } else {
                    o = t.getFirstPosition().parent;
                    r = t.getLastPosition().parent
                }
                return {firstElement: o, lastElement: r}
            }
        }

        class KT extends vc {
            constructor(t, e) {
                super(t);
                this._direction = e
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor;
                t.model.change((t => {
                    const e = zT(this._getStartBlock(), t);
                    this._fireAfterExecute(e)
                }))
            }

            _fireAfterExecute(t) {
                this.fire("afterExecute", HT(new Set(t)))
            }

            _checkEnabled() {
                const t = this.editor.model.document.selection;
                const e = this._getStartBlock();
                return t.isCollapsed && xT(e) && !BT(e)
            }

            _getStartBlock() {
                const t = this.editor.model.document;
                const e = t.selection.getFirstPosition().parent;
                return this._direction == "before" ? e : e.nextSibling
            }
        }

        class ZT extends Ac {
            static get pluginName() {
                return "DocumentListUtils"
            }

            expandListBlocksToCompleteList(t) {
                return RT(t)
            }

            isFirstBlockOfListItem(t) {
                return BT(t)
            }

            isListItemBlock(t) {
                return xT(t)
            }
        }

        function JT(t) {
            return t.is("element", "ol") || t.is("element", "ul")
        }

        function YT(t) {
            return t.is("element", "li")
        }

        function QT(t) {
            let e = 0;
            let n = t.parent;
            while (n) {
                if (YT(n)) {
                    e++
                } else {
                    const t = n.previousSibling;
                    if (t && YT(t)) {
                        e++
                    }
                }
                n = n.parent
            }
            return e
        }

        function XT(t, e, n, i = nB(n, e)) {
            return t.createAttributeElement(eB(n), null, {priority: 2 * e / 100 - 100, id: i})
        }

        function tB(t, e, n) {
            return t.createAttributeElement("li", null, {priority: (2 * e + 1) / 100 - 100, id: n})
        }

        function eB(t) {
            return t == "numbered" ? "ol" : "ul"
        }

        function nB(t, e) {
            return `list-${t}-${e}`
        }

        function iB(t, e) {
            const n = t.nodeBefore;
            if (!xT(n)) {
                const n = t.nodeAfter;
                if (xT(n)) {
                    e.set(n, n)
                }
            } else {
                let t = n;
                for (const {node: n} of CT(t, "backward")) {
                    t = n;
                    if (e.has(t)) {
                        return
                    }
                }
                e.set(n, t)
            }
        }

        function oB(t, e) {
            let n = 0;
            let i = -1;
            let o = null;
            let r = false;
            for (const {node: s} of t) {
                const t = s.getAttribute("listIndent");
                if (t > n) {
                    let a;
                    if (o === null) {
                        o = t - n;
                        a = n
                    } else {
                        if (o > t) {
                            o = t
                        }
                        a = t - o
                    }
                    if (a > i + 1) {
                        a = i + 1
                    }
                    e.setAttribute("listIndent", a, s);
                    r = true;
                    i = a
                } else {
                    o = null;
                    n = t + 1;
                    i = t
                }
            }
            return r
        }

        function rB(t, e, n) {
            const i = new Set;
            let o = false;
            for (const {node: r} of t) {
                if (i.has(r)) {
                    continue
                }
                let t = r.getAttribute("listType");
                let s = r.getAttribute("listItemId");
                if (e.has(s)) {
                    s = yT.next()
                }
                e.add(s);
                for (const e of ST(r, {direction: "forward"})) {
                    i.add(e);
                    if (e.getAttribute("listType") != t) {
                        s = yT.next();
                        t = e.getAttribute("listType")
                    }
                    if (e.getAttribute("listItemId") != s) {
                        n.setAttribute("listItemId", s, e);
                        o = true
                    }
                }
            }
            return o
        }

        function sB() {
            return (t, e, n) => {
                const {writer: i, schema: o} = n;
                if (!e.modelRange) {
                    return
                }
                const r = Array.from(e.modelRange.getItems({shallow: true})).filter((t => o.checkAttribute(t, "listItemId")));
                if (!r.length) {
                    return
                }
                const s = {
                    listItemId: yT.next(),
                    listIndent: QT(e.viewItem),
                    listType: e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted"
                };
                for (const t of r) {
                    if (!xT(t)) {
                        i.setAttributes(s, t)
                    }
                }
                if (r.length > 1) {
                    if (r[1].getAttribute("listItemId") != s.listItemId) {
                        n.keepEmptyElement(r[0])
                    }
                }
            }
        }

        function aB() {
            return (t, e, n) => {
                if (!n.consumable.test(e.viewItem, {name: true})) {
                    return
                }
                const i = new Mw(e.viewItem.document);
                for (const t of Array.from(e.viewItem.getChildren())) {
                    if (!YT(t) && !JT(t)) {
                        i.remove(t)
                    }
                }
            }
        }

        function lB(t, e, n, i) {
            return () => {
                const i = t.document.differ.getChanges();
                const s = [];
                const a = new Map;
                const l = new Set;
                for (const t of i) {
                    if (t.type == "insert" && t.name != "$text") {
                        iB(t.position, a);
                        if (!t.attributes.has("listItemId")) {
                            iB(t.position.getShiftedBy(t.length), a)
                        } else {
                            l.add(t.position.nodeAfter)
                        }
                    } else if (t.type == "remove" && t.attributes.has("listItemId")) {
                        iB(t.position, a)
                    } else if (t.type == "attribute") {
                        const e = t.range.start.nodeAfter;
                        if (n.includes(t.attributeKey)) {
                            iB(t.range.start, a);
                            if (t.attributeNewValue === null) {
                                iB(t.range.start.getShiftedBy(1), a);
                                if (r(e)) {
                                    s.push(e)
                                }
                            } else {
                                l.add(e)
                            }
                        } else if (xT(e)) {
                            if (r(e)) {
                                s.push(e)
                            }
                        }
                    }
                }
                for (const t of a.values()) {
                    s.push(...o(t, l))
                }
                for (const t of new Set(s)) {
                    e.reconvertItem(t)
                }
            };

            function o(t, e) {
                const i = [];
                const o = new Set;
                const a = [];
                for (const {node: l, previous: c} of CT(t, "forward")) {
                    if (o.has(l)) {
                        continue
                    }
                    const t = l.getAttribute("listIndent");
                    if (c && t < c.getAttribute("listIndent")) {
                        a.length = t + 1
                    }
                    a[t] = Object.fromEntries(Array.from(l.getAttributes()).filter((([t]) => n.includes(t))));
                    const d = ST(l, {direction: "forward"});
                    for (const t of d) {
                        o.add(t);
                        if (r(t, d)) {
                            i.push(t)
                        } else if (s(t, a, e)) {
                            i.push(t)
                        }
                    }
                }
                return i
            }

            function r(t, i) {
                if (!t.is("element", "paragraph")) {
                    return false
                }
                const o = e.mapper.toViewElement(t);
                if (!o) {
                    return false
                }
                const r = mB(t, n, i);
                if (r && o.is("element", "p")) {
                    return true
                } else if (!r && o.is("element", "span")) {
                    return true
                }
                return false
            }

            function s(t, n, o) {
                if (o.has(t)) {
                    return false
                }
                const r = e.mapper.toViewElement(t);
                let s = n.length - 1;
                for (let t = r.parent; !t.is("editableElement"); t = t.parent) {
                    const e = YT(t);
                    const o = JT(t);
                    if (!o && !e) {
                        continue
                    }
                    const r = `checkAttributes:${e ? "item" : "list"}`;
                    const a = i.fire(r, {viewElement: t, modelAttributes: n[s]});
                    if (a) {
                        break
                    }
                    if (o) {
                        s--;
                        if (s < 0) {
                            return false
                        }
                    }
                }
                return true
            }
        }

        function cB(t, e, n) {
            const i = gB(t);
            return (o, r, s) => {
                const {writer: a, mapper: l, consumable: c} = s;
                const d = r.item;
                if (!t.includes(r.attributeKey)) {
                    return
                }
                if (!i(d, c)) {
                    return
                }
                const u = uB(d, l, n);
                hB(u, a);
                fB(d, a.createRangeOn(u), e, a)
            }
        }

        function dB(t, {dataPipeline: e} = {}) {
            return (n, {writer: i}) => {
                if (!mB(n, t)) {
                    return
                }
                const o = i.createContainerElement("span", {class: "ck-list-bogus-paragraph"});
                if (e) {
                    i.setCustomProperty("dataPipeline:transparentRendering", true, o)
                }
                return o
            }
        }

        function uB(t, e, n) {
            const i = n.createRangeOn(t);
            const o = e.toViewRange(i).getTrimmed();
            return o.getContainedElement()
        }

        function hB(t, e) {
            let n = t.parent;
            while (n.is("attributeElement") && ["ul", "ol", "li"].includes(n.name)) {
                const i = n.parent;
                e.unwrap(e.createRangeOn(t), n);
                n = i
            }
        }

        function fB(t, e, n, i) {
            if (!t.hasAttribute("listIndent")) {
                return
            }
            const o = t.getAttribute("listIndent");
            let r = t;
            for (let t = o; t >= 0; t--) {
                const o = tB(i, t, r.getAttribute("listItemId"));
                const s = XT(i, t, r.getAttribute("listType"));
                for (const t of n) {
                    if (r.hasAttribute(t.attributeName)) {
                        t.setAttributeOnDowncast(i, r.getAttribute(t.attributeName), t.scope == "list" ? s : o)
                    }
                }
                e = i.wrap(e, o);
                e = i.wrap(e, s);
                if (t == 0) {
                    break
                }
                r = AT.first(r, {lowerIndent: true});
                if (!r) {
                    break
                }
            }
        }

        function gB(t) {
            return (e, n) => {
                const i = [];
                for (const n of t) {
                    if (e.hasAttribute(n)) {
                        i.push(`attribute:${n}`)
                    }
                }
                if (!i.every((t => n.test(e, t) !== false))) {
                    return false
                }
                i.forEach((t => n.consume(e, t)));
                return true
            }
        }

        function mB(t, e, n = ET(t)) {
            if (!xT(t)) {
                return false
            }
            for (const n of t.getAttributeKeys()) {
                if (n.startsWith("selection:")) {
                    continue
                }
                if (!e.includes(n)) {
                    return false
                }
            }
            return n.length < 2
        }

        var pB = n(8676);
        var bB = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        bB.insert = "head";
        bB.singleton = true;
        var kB = Bc()(pB.Z, bB);
        const wB = pB.Z.locals || {};
        const _B = ["listType", "listIndent", "listItemId"];

        class AB extends Ac {
            static get pluginName() {
                return "DocumentListEditing"
            }

            static get requires() {
                return [iD, nE, ZT]
            }

            constructor(t) {
                super(t);
                this._downcastStrategies = []
            }

            init() {
                const t = this.editor;
                const e = t.model;
                if (t.plugins.has("ListEditing")) {
                    throw new P("document-list-feature-conflict", this, {conflictPlugin: "ListEditing"})
                }
                e.schema.extend("$container", {allowAttributes: _B});
                e.schema.extend("$block", {allowAttributes: _B});
                e.schema.extend("$blockObject", {allowAttributes: _B});
                for (const t of _B) {
                    e.schema.setAttributeProperties(t, {copyOnReplace: true})
                }
                t.commands.add("numberedList", new UT(t, "numbered"));
                t.commands.add("bulletedList", new UT(t, "bulleted"));
                t.commands.add("indentList", new jT(t, "forward"));
                t.commands.add("outdentList", new jT(t, "backward"));
                t.commands.add("mergeListItemBackward", new GT(t, "backward"));
                t.commands.add("mergeListItemForward", new GT(t, "forward"));
                t.commands.add("splitListItemBefore", new KT(t, "before"));
                t.commands.add("splitListItemAfter", new KT(t, "after"));
                this._setupDeleteIntegration();
                this._setupEnterIntegration();
                this._setupTabIntegration();
                this._setupClipboardIntegration()
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands;
                const n = e.get("indent");
                const i = e.get("outdent");
                if (n) {
                    n.registerChildCommand(e.get("indentList"), {priority: "high"})
                }
                if (i) {
                    i.registerChildCommand(e.get("outdentList"), {priority: "lowest"})
                }
                this._setupModelPostFixing();
                this._setupConversion()
            }

            registerDowncastStrategy(t) {
                this._downcastStrategies.push(t)
            }

            _getListAttributeNames() {
                return [..._B, ...this._downcastStrategies.map((t => t.attributeName))]
            }

            _setupDeleteIntegration() {
                const t = this.editor;
                const e = t.commands.get("mergeListItemBackward");
                const n = t.commands.get("mergeListItemForward");
                this.listenTo(t.editing.view.document, "delete", ((i, o) => {
                    const r = t.model.document.selection;
                    if (WT(t.model)) {
                        return
                    }
                    t.model.change((() => {
                        const s = r.getFirstPosition();
                        if (r.isCollapsed && o.direction == "backward") {
                            if (!s.isAtStart) {
                                return
                            }
                            const n = s.parent;
                            if (!xT(n)) {
                                return
                            }
                            const r = AT.first(n, {sameAttributes: "listType", sameIndent: true});
                            if (!r && n.getAttribute("listIndent") === 0) {
                                if (!PT(n)) {
                                    t.execute("splitListItemAfter")
                                }
                                t.execute("outdentList")
                            } else {
                                if (!e.isEnabled) {
                                    return
                                }
                                e.execute({shouldMergeOnBlocksContentLevel: yB(t.model, "backward")})
                            }
                            o.preventDefault();
                            i.stop()
                        } else {
                            if (r.isCollapsed && !r.getLastPosition().isAtEnd) {
                                return
                            }
                            if (!n.isEnabled) {
                                return
                            }
                            n.execute({shouldMergeOnBlocksContentLevel: yB(t.model, "forward")});
                            o.preventDefault();
                            i.stop()
                        }
                    }))
                }), {context: "li"})
            }

            _setupEnterIntegration() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands;
                const i = n.get("enter");
                this.listenTo(t.editing.view.document, "enter", ((n, i) => {
                    const o = e.document;
                    const r = o.selection.getFirstPosition().parent;
                    if (o.selection.isCollapsed && xT(r) && r.isEmpty && !i.isSoft) {
                        const e = BT(r);
                        const o = PT(r);
                        if (e && o) {
                            t.execute("outdentList");
                            i.preventDefault();
                            n.stop()
                        } else if (e && !o) {
                            t.execute("splitListItemAfter");
                            i.preventDefault();
                            n.stop()
                        } else if (o) {
                            t.execute("splitListItemBefore");
                            i.preventDefault();
                            n.stop()
                        }
                    }
                }), {context: "li"});
                this.listenTo(i, "afterExecute", (() => {
                    const e = n.get("splitListItemBefore");
                    e.refresh();
                    if (!e.isEnabled) {
                        return
                    }
                    const i = t.model.document;
                    const o = i.selection.getLastPosition().parent;
                    const r = ET(o);
                    if (r.length === 2) {
                        e.execute()
                    }
                }))
            }

            _setupTabIntegration() {
                const t = this.editor;
                this.listenTo(t.editing.view.document, "tab", ((e, n) => {
                    const i = n.shiftKey ? "outdentList" : "indentList";
                    const o = this.editor.commands.get(i);
                    if (o.isEnabled) {
                        t.execute(i);
                        n.stopPropagation();
                        n.preventDefault();
                        e.stop()
                    }
                }), {context: "li"})
            }

            _setupConversion() {
                const t = this.editor;
                const e = t.model;
                const n = this._getListAttributeNames();
                t.conversion.for("upcast").elementToElement({view: "li", model: "paragraph"}).add((t => {
                    t.on("element:li", sB());
                    t.on("element:ul", aB(), {priority: "high"});
                    t.on("element:ol", aB(), {priority: "high"})
                }));
                t.conversion.for("editingDowncast").elementToElement({
                    model: "paragraph",
                    view: dB(n),
                    converterPriority: "high"
                });
                t.conversion.for("dataDowncast").elementToElement({
                    model: "paragraph",
                    view: dB(n, {dataPipeline: true}),
                    converterPriority: "high"
                });
                t.conversion.for("downcast").add((t => {
                    t.on("attribute", cB(n, this._downcastStrategies, e))
                }));
                this.listenTo(e.document, "change:data", lB(e, t.editing, n, this));
                this.on("checkAttributes:item", ((t, {viewElement: e, modelAttributes: n}) => {
                    if (e.id != n.listItemId) {
                        t.return = true;
                        t.stop()
                    }
                }));
                this.on("checkAttributes:list", ((t, {viewElement: e, modelAttributes: n}) => {
                    if (e.name != eB(n.listType) || e.id != nB(n.listType, n.listIndent)) {
                        t.return = true;
                        t.stop()
                    }
                }))
            }

            _setupModelPostFixing() {
                const t = this.editor.model;
                const e = this._getListAttributeNames();
                t.document.registerPostFixer((n => CB(t, n, e, this)));
                this.on("postFixer", ((t, {listNodes: e, writer: n}) => {
                    t.return = oB(e, n) || t.return
                }), {priority: "high"});
                this.on("postFixer", ((t, {listNodes: e, writer: n, seenIds: i}) => {
                    t.return = rB(e, i, n) || t.return
                }), {priority: "high"})
            }

            _setupClipboardIntegration() {
                const t = this.editor.model;
                this.listenTo(t, "insertContent", vB(t), {priority: "high"});
                this.listenTo(t, "getSelectedContent", ((e, [n]) => {
                    const i = NT(Array.from(n.getSelectedBlocks()));
                    if (i) {
                        t.change((t => OT(Array.from(e.return.getChildren()), t)))
                    }
                }))
            }
        }

        function CB(t, e, n, i) {
            const o = t.document.differ.getChanges();
            const r = new Map;
            let s = false;
            for (const i of o) {
                if (i.type == "insert" && i.name != "$text") {
                    const o = i.position.nodeAfter;
                    if (!t.schema.checkAttribute(o, "listItemId")) {
                        for (const t of Array.from(o.getAttributeKeys())) {
                            if (n.includes(t)) {
                                e.removeAttribute(t, o);
                                s = true
                            }
                        }
                    }
                    iB(i.position, r);
                    if (!i.attributes.has("listItemId")) {
                        iB(i.position.getShiftedBy(i.length), r)
                    }
                    for (const {item: e, previousPosition: n} of t.createRangeIn(o)) {
                        if (xT(e)) {
                            iB(n, r)
                        }
                    }
                } else if (i.type == "remove") {
                    iB(i.position, r)
                } else if (i.type == "attribute" && n.includes(i.attributeKey)) {
                    iB(i.range.start, r);
                    if (i.attributeNewValue === null) {
                        iB(i.range.start.getShiftedBy(1), r)
                    }
                }
            }
            const a = new Set;
            for (const t of r.values()) {
                s = i.fire("postFixer", {listNodes: new vT(t), listHead: t, writer: e, seenIds: a}) || s
            }
            return s
        }

        function vB(t) {
            return (e, [n, i]) => {
                const o = n.is("documentFragment") ? n.getChild(0) : n;
                if (!xT(o)) {
                    return
                }
                let r;
                if (!i) {
                    r = t.document.selection
                } else {
                    r = t.createSelection(i)
                }
                const s = r.getFirstPosition();
                let a = null;
                if (xT(s.parent)) {
                    a = s.parent
                } else if (xT(s.nodeBefore)) {
                    a = s.nodeBefore
                }
                if (!a) {
                    return
                }
                const l = a.getAttribute("listIndent") - o.getAttribute("listIndent");
                if (l <= 0) {
                    return
                }
                t.change((t => {
                    for (const {node: e} of CT(o, "forward")) {
                        t.setAttribute("listIndent", e.getAttribute("listIndent") + l, e)
                    }
                }))
            }
        }

        function yB(t, e) {
            const n = t.document.selection;
            if (!n.isCollapsed) {
                return !WT(t)
            }
            if (e === "forward") {
                return true
            }
            const i = n.getFirstPosition();
            const o = i.parent;
            const r = o.previousSibling;
            if (t.schema.isObject(r)) {
                return false
            }
            if (r.isEmpty) {
                return true
            }
            return NT([o, r])
        }

        function xB(t) {
            const e = t.createContainerElement("li");
            e.getFillerOffset = OB;
            return e
        }

        function EB(t, e) {
            const n = e.mapper;
            const i = e.writer;
            const o = t.getAttribute("listType") == "numbered" ? "ol" : "ul";
            const r = xB(i);
            const s = i.createContainerElement(o, null);
            i.insert(i.createPositionAt(s, 0), r);
            n.bindElements(t, r);
            return r
        }

        function SB(t, e, n, i) {
            const o = e.parent;
            const r = n.mapper;
            const s = n.writer;
            let a = r.toViewPosition(i.createPositionBefore(t));
            const l = BB(t.previousSibling, {
                sameIndent: true,
                smallerIndent: true,
                listIndent: t.getAttribute("listIndent")
            });
            const c = t.previousSibling;
            if (l && l.getAttribute("listIndent") == t.getAttribute("listIndent")) {
                const t = r.toViewElement(l);
                a = s.breakContainer(s.createPositionAfter(t))
            } else {
                if (c && c.name == "listItem") {
                    a = r.toViewPosition(i.createPositionAt(c, "end"));
                    const t = r.findMappedViewAncestor(a);
                    const e = IB(t);
                    if (e) {
                        a = s.createPositionBefore(e)
                    } else {
                        a = s.createPositionAt(t, "end")
                    }
                } else {
                    a = r.toViewPosition(i.createPositionBefore(t))
                }
            }
            a = TB(a);
            s.insert(a, o);
            if (c && c.name == "listItem") {
                const t = r.toViewElement(c);
                const n = s.createRange(s.createPositionAt(t, 0), a);
                const i = n.getWalker({ignoreElementEnd: true});
                for (const t of i) {
                    if (t.item.is("element", "li")) {
                        const n = s.breakContainer(s.createPositionBefore(t.item));
                        const o = t.item.parent;
                        const r = s.createPositionAt(e, "end");
                        DB(s, r.nodeBefore, r.nodeAfter);
                        s.move(s.createRangeOn(o), r);
                        i.position = n
                    }
                }
            } else {
                const n = o.nextSibling;
                if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                    let i = null;
                    for (const e of n.getChildren()) {
                        const n = r.toModelElement(e);
                        if (n && n.getAttribute("listIndent") > t.getAttribute("listIndent")) {
                            i = e
                        } else {
                            break
                        }
                    }
                    if (i) {
                        s.breakContainer(s.createPositionAfter(i));
                        s.move(s.createRangeOn(i.parent), s.createPositionAt(e, "end"))
                    }
                }
            }
            DB(s, o, o.nextSibling);
            DB(s, o.previousSibling, o)
        }

        function DB(t, e, n) {
            if (!e || !n || e.name != "ul" && e.name != "ol") {
                return null
            }
            if (e.name != n.name || e.getAttribute("class") !== n.getAttribute("class")) {
                return null
            }
            return t.mergeContainers(t.createPositionAfter(e))
        }

        function TB(t) {
            return t.getLastMatchingPosition((t => t.item.is("uiElement")))
        }

        function BB(t, e) {
            const n = !!e.sameIndent;
            const i = !!e.smallerIndent;
            const o = e.listIndent;
            let r = t;
            while (r && r.name == "listItem") {
                const t = r.getAttribute("listIndent");
                if (n && o == t || i && o > t) {
                    return r
                }
                if (e.direction === "forward") {
                    r = r.nextSibling
                } else {
                    r = r.previousSibling
                }
            }
            return null
        }

        function PB(t, e, n, i) {
            t.ui.componentFactory.add(e, (o => {
                const r = t.commands.get(e);
                const s = new LC(o);
                s.set({label: n, icon: i, tooltip: true, isToggleable: true});
                s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
                s.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                return s
            }))
        }

        function IB(t) {
            for (const e of t.getChildren()) {
                if (e.name == "ul" || e.name == "ol") {
                    return e
                }
            }
            return null
        }

        function RB(t, e) {
            const n = [];
            const i = t.parent;
            const o = {ignoreElementEnd: false, startPosition: t, shallow: true, direction: e};
            const r = i.getAttribute("listIndent");
            const s = [...new TreeWalker(o)].filter((t => t.item.is("element"))).map((t => t.item));
            for (const t of s) {
                if (!t.is("element", "listItem")) {
                    break
                }
                if (t.getAttribute("listIndent") < r) {
                    break
                }
                if (t.getAttribute("listIndent") > r) {
                    continue
                }
                if (t.getAttribute("listType") !== i.getAttribute("listType")) {
                    break
                }
                if (t.getAttribute("listStyle") !== i.getAttribute("listStyle")) {
                    break
                }
                if (t.getAttribute("listReversed") !== i.getAttribute("listReversed")) {
                    break
                }
                if (t.getAttribute("listStart") !== i.getAttribute("listStart")) {
                    break
                }
                if (e === "backward") {
                    n.unshift(t)
                } else {
                    n.push(t)
                }
            }
            return n
        }

        function zB(t) {
            const e = t.document;
            let n = [...e.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((e => {
                const n = t.change((t => t.createPositionAt(e, 0)));
                return [...RB(n, "backward"), ...RB(n, "forward")]
            })).flat();
            n = [...new Set(n)];
            return n
        }

        const VB = null && ["disc", "circle", "square"];
        const FB = null && ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];

        function LB(t) {
            if (VB.includes(t)) {
                return "bulleted"
            }
            if (FB.includes(t)) {
                return "numbered"
            }
            return null
        }

        function OB() {
            const t = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
            if (this.isEmpty || t) {
                return 0
            }
            return getFillerOffset.call(this)
        }

        const NB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
        const MB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';

        class HB extends Ac {
            static get pluginName() {
                return "ListUI"
            }

            init() {
                const t = this.editor.t;
                PB(this.editor, "numberedList", t("Numbered List"), NB);
                PB(this.editor, "bulletedList", t("Bulleted List"), MB)
            }
        }

        class WB extends Ac {
            static get requires() {
                return [AB, HB]
            }

            static get pluginName() {
                return "DocumentList"
            }
        }

        class qB extends vc {
            refresh() {
                const t = this._getValue();
                this.value = t;
                this.isEnabled = t != null
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                let i = Array.from(n.selection.getSelectedBlocks()).filter((t => xT(t) && t.getAttribute("listType") == "numbered"));
                i = RT(i);
                e.change((e => {
                    for (const n of i) {
                        e.setAttribute("listStart", t.startIndex >= 0 ? t.startIndex : 1, n)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model;
                const e = t.document;
                const n = sc(e.selection.getSelectedBlocks());
                if (n && xT(n) && n.getAttribute("listType") == "numbered") {
                    return n.getAttribute("listStart")
                }
                return null
            }
        }

        const jB = {};
        const $B = {};
        const UB = {};
        const GB = [{listStyle: "disc", typeAttribute: "disc", listType: "bulleted"}, {
            listStyle: "circle",
            typeAttribute: "circle",
            listType: "bulleted"
        }, {listStyle: "square", typeAttribute: "square", listType: "bulleted"}, {
            listStyle: "decimal",
            typeAttribute: "1",
            listType: "numbered"
        }, {listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered"}, {
            listStyle: "lower-roman",
            typeAttribute: "i",
            listType: "numbered"
        }, {listStyle: "upper-roman", typeAttribute: "I", listType: "numbered"}, {
            listStyle: "lower-alpha",
            typeAttribute: "a",
            listType: "numbered"
        }, {listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered"}, {
            listStyle: "lower-latin",
            typeAttribute: "a",
            listType: "numbered"
        }, {listStyle: "upper-latin", typeAttribute: "A", listType: "numbered"}];
        for (const {listStyle: t, typeAttribute: e, listType: n} of GB) {
            jB[t] = n;
            $B[t] = e;
            if (e) {
                UB[e] = t
            }
        }

        function KB() {
            return GB.map((t => t.listStyle))
        }

        function ZB(t) {
            return jB[t] || null
        }

        function JB(t) {
            return UB[t] || null
        }

        function YB(t) {
            return $B[t] || null
        }

        class QB extends vc {
            constructor(t, e, n) {
                super(t);
                this._defaultType = e;
                this._supportedTypes = n
            }

            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.change((e => {
                    this._tryToConvertItemsToList(t);
                    let i = Array.from(n.selection.getSelectedBlocks()).filter((t => t.hasAttribute("listType")));
                    if (!i.length) {
                        return
                    }
                    i = RT(i);
                    for (const n of i) {
                        e.setAttribute("listStyle", t.type || this._defaultType, n)
                    }
                }))
            }

            isStyleTypeSupported(t) {
                if (!this._supportedTypes) {
                    return true
                }
                return this._supportedTypes.includes(t)
            }

            _getValue() {
                const t = sc(this.editor.model.document.selection.getSelectedBlocks());
                if (xT(t)) {
                    return t.getAttribute("listStyle")
                }
                return null
            }

            _checkEnabled() {
                const t = this.editor;
                const e = t.commands.get("numberedList");
                const n = t.commands.get("bulletedList");
                return e.isEnabled || n.isEnabled
            }

            _tryToConvertItemsToList(t) {
                if (!t.type) {
                    return
                }
                const e = ZB(t.type);
                if (!e) {
                    return
                }
                const n = this.editor;
                const i = e + "List";
                const o = n.commands.get(i);
                if (!o.value) {
                    n.execute(i)
                }
            }
        }

        class XB extends vc {
            refresh() {
                const t = this._getValue();
                this.value = t;
                this.isEnabled = t != null
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                let i = Array.from(n.selection.getSelectedBlocks()).filter((t => xT(t) && t.getAttribute("listType") == "numbered"));
                i = RT(i);
                e.change((e => {
                    for (const n of i) {
                        e.setAttribute("listReversed", !!t.reversed, n)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model;
                const e = t.document;
                const n = sc(e.selection.getSelectedBlocks());
                if (xT(n) && n.getAttribute("listType") == "numbered") {
                    return n.getAttribute("listReversed")
                }
                return null
            }
        }

        function tP(t) {
            return (e, n, i) => {
                const {writer: o, schema: r, consumable: s} = i;
                if (s.test(n.viewItem, t.viewConsumables) === false) {
                    return
                }
                if (!n.modelRange) {
                    Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor))
                }
                let a = false;
                for (const e of n.modelRange.getItems({shallow: true})) {
                    if (!r.checkAttribute(e, t.attributeName)) {
                        continue
                    }
                    if (!t.appliesToListItem(e)) {
                        continue
                    }
                    if (e.hasAttribute(t.attributeName)) {
                        continue
                    }
                    o.setAttribute(t.attributeName, t.getAttributeOnUpcast(n.viewItem), e);
                    a = true
                }
                if (a) {
                    s.consume(n.viewItem, t.viewConsumables)
                }
            }
        }

        class eP extends Ac {
            static get pluginName() {
                return "DocumentListPropertiesUtils"
            }

            getAllSupportedStyleTypes() {
                return KB()
            }

            getListTypeFromListStyleType(t) {
                return ZB(t)
            }

            getListStyleTypeFromTypeAttribute(t) {
                return JB(t)
            }

            getTypeAttributeFromListStyleType(t) {
                return YB(t)
            }
        }

        const nP = "default";

        class iP extends Ac {
            static get requires() {
                return [AB, eP]
            }

            static get pluginName() {
                return "DocumentListPropertiesEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("list", {properties: {styles: true, startIndex: false, reversed: false}})
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.plugins.get(AB);
                const i = t.config.get("list.properties");
                const o = oP(i);
                for (const i of o) {
                    i.addCommand(t);
                    e.schema.extend("$container", {allowAttributes: i.attributeName});
                    e.schema.extend("$block", {allowAttributes: i.attributeName});
                    e.schema.extend("$blockObject", {allowAttributes: i.attributeName});
                    n.registerDowncastStrategy({
                        scope: "list",
                        attributeName: i.attributeName,
                        setAttributeOnDowncast(t, e, n) {
                            i.setAttributeOnDowncast(t, e, n)
                        }
                    })
                }
                t.conversion.for("upcast").add((t => {
                    for (const e of o) {
                        t.on("element:ol", tP(e));
                        t.on("element:ul", tP(e))
                    }
                }));
                n.on("checkAttributes:list", ((t, {viewElement: e, modelAttributes: n}) => {
                    for (const i of o) {
                        if (i.getAttributeOnUpcast(e) != n[i.attributeName]) {
                            t.return = true;
                            t.stop()
                        }
                    }
                }));
                this.listenTo(t.commands.get("indentList"), "afterExecute", ((t, n) => {
                    e.change((t => {
                        for (const e of n) {
                            for (const n of o) {
                                if (n.appliesToListItem(e)) {
                                    t.setAttribute(n.attributeName, n.defaultValue, e)
                                }
                            }
                        }
                    }))
                }));
                n.on("postFixer", ((t, {listNodes: e, writer: n}) => {
                    for (const {node: i} of e) {
                        for (const e of o) {
                            if (e.hasValidAttribute(i)) {
                                continue
                            }
                            if (e.appliesToListItem(i)) {
                                n.setAttribute(e.attributeName, e.defaultValue, i)
                            } else {
                                n.removeAttribute(e.attributeName, i)
                            }
                            t.return = true
                        }
                    }
                }));
                n.on("postFixer", ((t, {listNodes: e, writer: n}) => {
                    const i = [];
                    for (const {node: r, previous: s} of e) {
                        if (!s) {
                            continue
                        }
                        const e = r.getAttribute("listIndent");
                        const a = s.getAttribute("listIndent");
                        let l = null;
                        if (e > a) {
                            i[a] = s
                        } else if (e < a) {
                            l = i[e];
                            i.length = e
                        } else {
                            l = s
                        }
                        if (!l) {
                            continue
                        }
                        if (l.getAttribute("listType") != r.getAttribute("listType")) {
                            continue
                        }
                        for (const e of o) {
                            const {attributeName: i} = e;
                            if (!e.appliesToListItem(r)) {
                                continue
                            }
                            const o = l.getAttribute(i);
                            if (r.getAttribute(i) != o) {
                                n.setAttribute(i, o, r);
                                t.return = true
                            }
                        }
                    }
                }))
            }
        }

        function oP(t) {
            const e = [];
            if (t.styles) {
                const n = typeof t.styles == "object" && t.styles.useAttribute;
                e.push({
                    attributeName: "listStyle",
                    defaultValue: nP,
                    viewConsumables: {styles: "list-style-type"},
                    addCommand(t) {
                        let e = KB();
                        if (n) {
                            e = e.filter((t => !!YB(t)))
                        }
                        t.commands.add("listStyle", new QB(t, nP, e))
                    },
                    appliesToListItem() {
                        return true
                    },
                    hasValidAttribute(t) {
                        if (!t.hasAttribute("listStyle")) {
                            return false
                        }
                        const e = t.getAttribute("listStyle");
                        if (e == nP) {
                            return true
                        }
                        return ZB(e) == t.getAttribute("listType")
                    },
                    setAttributeOnDowncast(t, e, i) {
                        if (e && e !== nP) {
                            if (n) {
                                const n = YB(e);
                                if (n) {
                                    t.setAttribute("type", n, i);
                                    return
                                }
                            } else {
                                t.setStyle("list-style-type", e, i);
                                return
                            }
                        }
                        t.removeStyle("list-style-type", i);
                        t.removeAttribute("type", i)
                    },
                    getAttributeOnUpcast(t) {
                        const e = t.getStyle("list-style-type");
                        if (e) {
                            return e
                        }
                        const n = t.getAttribute("type");
                        if (n) {
                            return JB(n)
                        }
                        return nP
                    }
                })
            }
            if (t.reversed) {
                e.push({
                    attributeName: "listReversed",
                    defaultValue: false,
                    viewConsumables: {attributes: "reversed"},
                    addCommand(t) {
                        t.commands.add("listReversed", new XB(t))
                    },
                    appliesToListItem(t) {
                        return t.getAttribute("listType") == "numbered"
                    },
                    hasValidAttribute(t) {
                        return this.appliesToListItem(t) == t.hasAttribute("listReversed")
                    },
                    setAttributeOnDowncast(t, e, n) {
                        if (e) {
                            t.setAttribute("reversed", "reversed", n)
                        } else {
                            t.removeAttribute("reversed", n)
                        }
                    },
                    getAttributeOnUpcast(t) {
                        return t.hasAttribute("reversed")
                    }
                })
            }
            if (t.startIndex) {
                e.push({
                    attributeName: "listStart",
                    defaultValue: 1,
                    viewConsumables: {attributes: "start"},
                    addCommand(t) {
                        t.commands.add("listStart", new qB(t))
                    },
                    appliesToListItem(t) {
                        return t.getAttribute("listType") == "numbered"
                    },
                    hasValidAttribute(t) {
                        return this.appliesToListItem(t) == t.hasAttribute("listStart")
                    },
                    setAttributeOnDowncast(t, e, n) {
                        if (e == 0 || e > 1) {
                            t.setAttribute("start", e, n)
                        } else {
                            t.removeAttribute("start", n)
                        }
                    },
                    getAttributeOnUpcast(t) {
                        const e = t.getAttribute("start");
                        return e >= 0 ? e : 1
                    }
                })
            }
            return e
        }

        var rP = n(3195);
        var sP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        sP.insert = "head";
        sP.singleton = true;
        var aP = Bc()(rP.Z, sP);
        const lP = rP.Z.locals || {};

        class cP extends pA {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("isCollapsed", false);
                this.set("label", "");
                this.buttonView = this._createButtonView();
                this.children = this.createCollection();
                this.set("_collapsibleAriaLabelUid");
                if (e) {
                    this.children.addMany(e)
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-collapsible", n.if("isCollapsed", "ck-collapsible_collapsed")]},
                    children: [this.buttonView, {
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-collapsible__children"],
                            role: "region",
                            hidden: n.if("isCollapsed", "hidden"),
                            "aria-labelledby": n.to("_collapsibleAriaLabelUid")
                        },
                        children: this.children
                    }]
                })
            }

            render() {
                super.render();
                this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
            }

            _createButtonView() {
                const t = new LC(this.locale);
                const e = t.bindTemplate;
                t.set({withText: true, icon: XC});
                t.extendTemplate({attributes: {"aria-expanded": e.to("isOn", (t => String(t)))}});
                t.bind("label").to(this);
                t.bind("isOn").to(this, "isCollapsed", (t => !t));
                t.on("execute", (() => {
                    this.isCollapsed = !this.isCollapsed
                }));
                return t
            }
        }

        var dP = n(7133);
        var uP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        uP.insert = "head";
        uP.singleton = true;
        var hP = Bc()(dP.Z, uP);
        const fP = dP.Z.locals || {};

        class gP extends pA {
            constructor(t, {enabledProperties: e, styleButtonViews: n, styleGridAriaLabel: i}) {
                super(t);
                const o = ["ck", "ck-list-properties"];
                this.children = this.createCollection();
                this.stylesView = null;
                this.additionalPropertiesCollapsibleView = null;
                this.startIndexFieldView = null;
                this.reversedSwitchButtonView = null;
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.focusables = new F_;
                this.focusCycler = new hv({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                if (e.styles) {
                    this.stylesView = this._createStylesView(n, i);
                    this.children.add(this.stylesView)
                } else {
                    o.push("ck-list-properties_without-styles")
                }
                if (e.startIndex || e.reversed) {
                    this._addNumberedListPropertyViews(e, n);
                    o.push("ck-list-properties_with-numbered-properties")
                }
                this.setTemplate({tag: "div", attributes: {class: o}, children: this.children})
            }

            render() {
                super.render();
                if (this.stylesView) {
                    this.focusables.add(this.stylesView);
                    this.focusTracker.add(this.stylesView.element);
                    if (this.startIndexFieldView || this.reversedSwitchButtonView) {
                        this.focusables.add(this.children.last.buttonView);
                        this.focusTracker.add(this.children.last.buttonView.element)
                    }
                    for (const t of this.stylesView.children) {
                        this.stylesView.focusTracker.add(t.element)
                    }
                    EC({
                        keystrokeHandler: this.stylesView.keystrokes,
                        focusTracker: this.stylesView.focusTracker,
                        gridItems: this.stylesView.children,
                        numberOfColumns: () => Xa.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length,
                        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                    })
                }
                if (this.startIndexFieldView) {
                    this.focusables.add(this.startIndexFieldView);
                    this.focusTracker.add(this.startIndexFieldView.element);
                    this.listenTo(this.startIndexFieldView.element, "selectstart", ((t, e) => {
                        e.stopPropagation()
                    }), {priority: "high"});
                    const t = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", t);
                    this.keystrokes.set("arrowleft", t);
                    this.keystrokes.set("arrowup", t);
                    this.keystrokes.set("arrowdown", t)
                }
                if (this.reversedSwitchButtonView) {
                    this.focusables.add(this.reversedSwitchButtonView);
                    this.focusTracker.add(this.reversedSwitchButtonView.element)
                }
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this.focusCycler.focusFirst()
            }

            focusLast() {
                this.focusCycler.focusLast()
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            _createStylesView(t, e) {
                const n = new pA(this.locale);
                n.children = n.createCollection(this.locale);
                n.children.addMany(t);
                n.setTemplate({
                    tag: "div",
                    attributes: {"aria-label": e, class: ["ck", "ck-list-styles-list"]},
                    children: n.children
                });
                n.children.delegate("execute").to(this);
                n.focus = function () {
                    this.children.first.focus()
                };
                n.focusTracker = new ac;
                n.keystrokes = new lc;
                n.render();
                n.keystrokes.listenTo(n.element);
                return n
            }

            _addNumberedListPropertyViews(t) {
                const e = this.locale.t;
                const n = [];
                if (t.startIndex) {
                    this.startIndexFieldView = this._createStartIndexField();
                    n.push(this.startIndexFieldView)
                }
                if (t.reversed) {
                    this.reversedSwitchButtonView = this._createReversedSwitchButton();
                    n.push(this.reversedSwitchButtonView)
                }
                if (t.styles) {
                    this.additionalPropertiesCollapsibleView = new cP(this.locale, n);
                    this.additionalPropertiesCollapsibleView.set({label: e("List properties"), isCollapsed: true});
                    this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(n, "isEnabled", ((...t) => t.some((t => t))));
                    this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", ((t, e, n) => {
                        if (!n) {
                            this.additionalPropertiesCollapsibleView.isCollapsed = true
                        }
                    }));
                    this.children.add(this.additionalPropertiesCollapsibleView)
                } else {
                    this.children.addMany(n)
                }
            }

            _createStartIndexField() {
                const t = this.locale.t;
                const e = new Py(this.locale, Ry);
                e.set({label: t("Start at"), class: "ck-numbered-list-properties__start-index"});
                e.fieldView.set({min: 0, step: 1, value: 1, inputMode: "numeric"});
                e.fieldView.on("input", (() => {
                    const n = e.fieldView.element;
                    const i = n.valueAsNumber;
                    if (Number.isNaN(i)) {
                        return
                    }
                    if (!n.checkValidity()) {
                        e.errorText = t("Start index must be greater than 0.")
                    } else {
                        this.fire("listStart", {startIndex: i})
                    }
                }));
                return e
            }

            _createReversedSwitchButton() {
                const t = this.locale.t;
                const e = new WC(this.locale);
                e.set({
                    withText: true,
                    label: t("Reversed order"),
                    class: "ck-numbered-list-properties__reversed-order"
                });
                e.delegate("execute").to(this, "listReversed");
                return e
            }
        }

        const mP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>';
        const pP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>';
        const bP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>';
        const kP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>';
        const wP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>';
        const _P = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>';
        const AP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>';
        const CP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>';
        const vP = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>';
        var yP = n(4553);
        var xP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        xP.insert = "head";
        xP.singleton = true;
        var EP = Bc()(yP.Z, xP);
        const SP = yP.Z.locals || {};

        class DP extends Ac {
            static get pluginName() {
                return "ListPropertiesUI"
            }

            init() {
                const t = this.editor;
                const e = t.locale.t;
                const n = t.config.get("list.properties");
                if (n.styles) {
                    t.ui.componentFactory.add("bulletedList", TP({
                        editor: t,
                        parentCommandName: "bulletedList",
                        buttonLabel: e("Bulleted List"),
                        buttonIcon: MB,
                        styleGridAriaLabel: e("Bulleted list styles toolbar"),
                        styleDefinitions: [{
                            label: e("Toggle the disc list style"),
                            tooltip: e("Disc"),
                            type: "disc",
                            icon: mP
                        }, {
                            label: e("Toggle the circle list style"),
                            tooltip: e("Circle"),
                            type: "circle",
                            icon: pP
                        }, {label: e("Toggle the square list style"), tooltip: e("Square"), type: "square", icon: bP}]
                    }))
                }
                if (n.styles || n.startIndex || n.reversed) {
                    t.ui.componentFactory.add("numberedList", TP({
                        editor: t,
                        parentCommandName: "numberedList",
                        buttonLabel: e("Numbered List"),
                        buttonIcon: NB,
                        styleGridAriaLabel: e("Numbered list styles toolbar"),
                        styleDefinitions: [{
                            label: e("Toggle the decimal list style"),
                            tooltip: e("Decimal"),
                            type: "decimal",
                            icon: kP
                        }, {
                            label: e("Toggle the decimal with leading zero list style"),
                            tooltip: e("Decimal with leading zero"),
                            type: "decimal-leading-zero",
                            icon: wP
                        }, {
                            label: e("Toggle the lower–roman list style"),
                            tooltip: e("Lower–roman"),
                            type: "lower-roman",
                            icon: _P
                        }, {
                            label: e("Toggle the upper–roman list style"),
                            tooltip: e("Upper-roman"),
                            type: "upper-roman",
                            icon: AP
                        }, {
                            label: e("Toggle the lower–latin list style"),
                            tooltip: e("Lower-latin"),
                            type: "lower-latin",
                            icon: CP
                        }, {
                            label: e("Toggle the upper–latin list style"),
                            tooltip: e("Upper-latin"),
                            type: "upper-latin",
                            icon: vP
                        }]
                    }))
                }
            }
        }

        function TP({
                        editor: t,
                        parentCommandName: e,
                        buttonLabel: n,
                        buttonIcon: i,
                        styleGridAriaLabel: o,
                        styleDefinitions: r
                    }) {
            const s = t.commands.get(e);
            return a => {
                const l = qv(a, rv);
                const c = l.buttonView;
                l.bind("isEnabled").to(s);
                l.class = "ck-list-styles-dropdown";
                c.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                c.set({label: n, icon: i, tooltip: true, isToggleable: true});
                c.bind("isOn").to(s, "value", (t => !!t));
                const d = PP({
                    editor: t,
                    dropdownView: l,
                    parentCommandName: e,
                    styleGridAriaLabel: o,
                    styleDefinitions: r
                });
                l.panelView.children.add(d);
                l.on("execute", (() => {
                    t.editing.view.focus()
                }));
                return l
            }
        }

        function BP({editor: t, listStyleCommand: e, parentCommandName: n}) {
            const i = t.locale;
            const o = t.commands.get(n);
            return ({label: n, type: r, icon: s, tooltip: a}) => {
                const l = new LC(i);
                l.set({label: n, icon: s, tooltip: a});
                e.on("change:value", (() => {
                    l.isOn = e.value === r
                }));
                l.on("execute", (() => {
                    if (o.value) {
                        if (e.value !== r) {
                            t.execute("listStyle", {type: r})
                        } else {
                            t.execute("listStyle", {type: e._defaultType})
                        }
                    } else {
                        t.model.change((() => {
                            t.execute("listStyle", {type: r})
                        }))
                    }
                }));
                return l
            }
        }

        function PP({editor: t, dropdownView: e, parentCommandName: n, styleDefinitions: i, styleGridAriaLabel: o}) {
            const r = t.locale;
            const s = t.config.get("list.properties");
            let a;
            if (n != "numberedList") {
                s.startIndex = false;
                s.reversed = false
            }
            if (s.styles) {
                const e = t.commands.get("listStyle");
                const o = BP({editor: t, parentCommandName: n, listStyleCommand: e});
                const r = typeof e.isStyleTypeSupported == "function" ? t => e.isStyleTypeSupported(t.type) : () => true;
                a = i.filter(r).map(o)
            }
            const l = new gP(r, {styleGridAriaLabel: o, enabledProperties: s, styleButtonViews: a});
            if (s.styles) {
                Uv(e, (() => l.stylesView.children.find((t => t.isOn))))
            }
            if (s.startIndex) {
                const e = t.commands.get("listStart");
                l.startIndexFieldView.bind("isEnabled").to(e);
                l.startIndexFieldView.fieldView.bind("value").to(e);
                l.on("listStart", ((e, n) => t.execute("listStart", n)))
            }
            if (s.reversed) {
                const e = t.commands.get("listReversed");
                l.reversedSwitchButtonView.bind("isEnabled").to(e);
                l.reversedSwitchButtonView.bind("isOn").to(e, "value");
                l.on("listReversed", (() => {
                    const n = e.value;
                    t.execute("listReversed", {reversed: !n})
                }))
            }
            l.delegate("execute").to(e);
            return l
        }

        class IP extends Ac {
            static get requires() {
                return [iP, DP]
            }

            static get pluginName() {
                return "DocumentListProperties"
            }
        }

        class RP extends Pf {
            constructor(t) {
                super(t);
                const e = this.document;
                this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
                this.listenTo(e, "paste", n("clipboardInput"), {priority: "low"});
                this.listenTo(e, "drop", n("clipboardInput"), {priority: "low"});
                this.listenTo(e, "dragover", n("dragging"), {priority: "low"});

                function n(t) {
                    return (n, i) => {
                        i.preventDefault();
                        const o = i.dropRange ? [i.dropRange] : null;
                        const r = new y(e, t);
                        e.fire(r, {dataTransfer: i.dataTransfer, method: n.name, targetRanges: o, target: i.target});
                        if (r.stop.called) {
                            i.stopPropagation()
                        }
                    }
                }
            }

            onDomEvent(t) {
                const e = {dataTransfer: new om("clipboardData" in t ? t.clipboardData : t.dataTransfer)};
                if (t.type == "drop" || t.type == "dragover") {
                    e.dropRange = zP(this.view, t)
                }
                this.fire(t.type, t, e)
            }
        }

        function zP(t, e) {
            const n = e.target.ownerDocument;
            const i = e.clientX;
            const o = e.clientY;
            let r;
            if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) {
                r = n.caretRangeFromPoint(i, o)
            } else if (e.rangeParent) {
                r = n.createRange();
                r.setStart(e.rangeParent, e.rangeOffset);
                r.collapse(true)
            }
            if (r) {
                return t.domConverter.domRangeToView(r)
            }
            return null
        }

        function VP(t) {
            t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
            if (t.includes("</p><p>") || t.includes("<br>")) {
                t = `<p>${t}</p>`
            }
            return t
        }

        function FP(t) {
            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => {
                if (e.length == 1) {
                    return " "
                }
                return e
            })).replace(/<!--[\s\S]*?-->/g, "")
        }

        const LP = ["figcaption", "li"];

        function OP(t) {
            let e = "";
            if (t.is("$text") || t.is("$textProxy")) {
                e = t.data
            } else if (t.is("element", "img") && t.hasAttribute("alt")) {
                e = t.getAttribute("alt")
            } else if (t.is("element", "br")) {
                e = "\n"
            } else {
                let n = null;
                for (const i of t.getChildren()) {
                    const t = OP(i);
                    if (n && (n.is("containerElement") || i.is("containerElement"))) {
                        if (LP.includes(n.name) || LP.includes(i.name)) {
                            e += "\n"
                        } else {
                            e += "\n\n"
                        }
                    }
                    e += t;
                    n = i
                }
            }
            return e
        }

        class NP extends Ac {
            static get pluginName() {
                return "ClipboardPipeline"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                e.addObserver(RP);
                this._setupPasteDrop();
                this._setupCopyCut()
            }

            _setupPasteDrop() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = n.document;
                this.listenTo(i, "clipboardInput", (e => {
                    if (t.isReadOnly) {
                        e.stop()
                    }
                }), {priority: "highest"});
                this.listenTo(i, "clipboardInput", ((t, e) => {
                    const i = e.dataTransfer;
                    let o;
                    if (e.content) {
                        o = e.content
                    } else {
                        let t = "";
                        if (i.getData("text/html")) {
                            t = FP(i.getData("text/html"))
                        } else if (i.getData("text/plain")) {
                            t = VP(i.getData("text/plain"))
                        }
                        o = this.editor.data.htmlProcessor.toView(t)
                    }
                    const r = new y(this, "inputTransformation");
                    this.fire(r, {content: o, dataTransfer: i, targetRanges: e.targetRanges, method: e.method});
                    if (r.stop.called) {
                        t.stop()
                    }
                    n.scrollToTheSelection()
                }), {priority: "low"});
                this.listenTo(this, "inputTransformation", ((t, n) => {
                    if (n.content.isEmpty) {
                        return
                    }
                    const i = this.editor.data;
                    const o = i.toModel(n.content, "$clipboardHolder");
                    if (o.childCount == 0) {
                        return
                    }
                    t.stop();
                    e.change((() => {
                        this.fire("contentInsertion", {
                            content: o,
                            method: n.method,
                            dataTransfer: n.dataTransfer,
                            targetRanges: n.targetRanges
                        })
                    }))
                }), {priority: "low"});
                this.listenTo(this, "contentInsertion", ((t, n) => {
                    n.resultRange = e.insertContent(n.content)
                }), {priority: "low"})
            }

            _setupCopyCut() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.editing.view;
                const i = n.document;
                const o = (n, o) => {
                    const r = o.dataTransfer;
                    o.preventDefault();
                    const s = t.data.toView(t.model.getSelectedContent(e.selection));
                    i.fire("clipboardOutput", {dataTransfer: r, content: s, method: n.name})
                };
                this.listenTo(i, "copy", o, {priority: "low"});
                this.listenTo(i, "cut", ((e, n) => {
                    if (t.isReadOnly) {
                        n.preventDefault()
                    } else {
                        o(e, n)
                    }
                }), {priority: "low"});
                this.listenTo(i, "clipboardOutput", ((n, i) => {
                    if (!i.content.isEmpty) {
                        i.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(i.content));
                        i.dataTransfer.setData("text/plain", OP(i.content))
                    }
                    if (i.method == "cut") {
                        t.model.deleteContent(e.selection)
                    }
                }), {priority: "low"})
            }
        }

        class MP extends (j()) {
            constructor() {
                super();
                this._stack = []
            }

            add(t, e) {
                const n = this._stack;
                const i = n[0];
                this._insertDescriptor(t);
                const o = n[0];
                if (i !== o && !HP(i, o)) {
                    this.fire("change:top", {oldDescriptor: i, newDescriptor: o, writer: e})
                }
            }

            remove(t, e) {
                const n = this._stack;
                const i = n[0];
                this._removeDescriptor(t);
                const o = n[0];
                if (i !== o && !HP(i, o)) {
                    this.fire("change:top", {oldDescriptor: i, newDescriptor: o, writer: e})
                }
            }

            _insertDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t.id));
                if (HP(t, e[n])) {
                    return
                }
                if (n > -1) {
                    e.splice(n, 1)
                }
                let i = 0;
                while (e[i] && WP(e[i], t)) {
                    i++
                }
                e.splice(i, 0, t)
            }

            _removeDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t));
                if (n > -1) {
                    e.splice(n, 1)
                }
            }
        }

        function HP(t, e) {
            return t && e && t.priority == e.priority && qP(t.classes) == qP(e.classes)
        }

        function WP(t, e) {
            if (t.priority > e.priority) {
                return true
            } else if (t.priority < e.priority) {
                return false
            }
            return qP(t.classes) > qP(e.classes)
        }

        function qP(t) {
            return Array.isArray(t) ? t.sort().join(",") : t
        }

        const jP = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
        const $P = "ck-widget";
        const UP = "ck-widget_selected";

        function GP(t) {
            if (!t.is("element")) {
                return false
            }
            return !!t.getCustomProperty("widget")
        }

        function KP(t, e, n = {}) {
            if (!t.is("containerElement")) {
                throw new P("widget-to-widget-wrong-element-type", null, {element: t})
            }
            e.setAttribute("contenteditable", "false", t);
            e.addClass($P, t);
            e.setCustomProperty("widget", true, t);
            t.getFillerOffset = iI;
            e.setCustomProperty("widgetLabel", [], t);
            if (n.label) {
                QP(t, n.label)
            }
            if (n.hasSelectionHandle) {
                oI(t, e)
            }
            YP(t, e);
            return t
        }

        function ZP(t, e, n) {
            if (e.classes) {
                n.addClass(Zl(e.classes), t)
            }
            if (e.attributes) {
                for (const i in e.attributes) {
                    n.setAttribute(i, e.attributes[i], t)
                }
            }
        }

        function JP(t, e, n) {
            if (e.classes) {
                n.removeClass(Zl(e.classes), t)
            }
            if (e.attributes) {
                for (const i in e.attributes) {
                    n.removeAttribute(i, t)
                }
            }
        }

        function YP(t, e, n = ZP, i = JP) {
            const o = new MP;
            o.on("change:top", ((e, o) => {
                if (o.oldDescriptor) {
                    i(t, o.oldDescriptor, o.writer)
                }
                if (o.newDescriptor) {
                    n(t, o.newDescriptor, o.writer)
                }
            }));
            const r = (t, e, n) => o.add(e, n);
            const s = (t, e, n) => o.remove(e, n);
            e.setCustomProperty("addHighlight", r, t);
            e.setCustomProperty("removeHighlight", s, t)
        }

        function QP(t, e) {
            const n = t.getCustomProperty("widgetLabel");
            n.push(e)
        }

        function XP(t) {
            const e = t.getCustomProperty("widgetLabel");
            return e.reduce(((t, e) => {
                if (typeof e === "function") {
                    return t ? t + ". " + e() : e()
                } else {
                    return t ? t + ". " + e : e
                }
            }), "")
        }

        function tI(t, e, n = {}) {
            e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
            e.setAttribute("role", "textbox", t);
            if (n.label) {
                e.setAttribute("aria-label", n.label, t)
            }
            e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
            t.on("change:isReadOnly", ((n, i, o) => {
                e.setAttribute("contenteditable", o ? "false" : "true", t)
            }));
            t.on("change:isFocused", ((n, i, o) => {
                if (o) {
                    e.addClass("ck-editor__nested-editable_focused", t)
                } else {
                    e.removeClass("ck-editor__nested-editable_focused", t)
                }
            }));
            YP(t, e);
            return t
        }

        function eI(t, e) {
            const n = t.getSelectedElement();
            if (n) {
                const i = dI(t);
                if (i) {
                    return e.createRange(e.createPositionAt(n, i))
                }
            }
            return Ew(t, e)
        }

        function nI(t, e) {
            return (n, i) => {
                const {mapper: o, viewPosition: r} = i;
                const s = o.findMappedViewAncestor(r);
                if (!e(s)) {
                    return
                }
                const a = o.toModelElement(s);
                i.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after")
            }
        }

        function iI() {
            return null
        }

        function oI(t, e) {
            const n = e.createUIElement("div", {class: "ck ck-widget__selection-handle"}, (function (t) {
                const e = this.toDomElement(t);
                const n = new IC;
                n.set("content", jP);
                n.render();
                e.appendChild(n.element);
                return e
            }));
            e.insert(e.createPositionAt(t, 0), n);
            e.addClass(["ck-widget_with-selection-handle"], t)
        }

        const rI = "widget-type-around";

        function sI(t, e, n) {
            return !!t && GP(t) && !n.isInline(e)
        }

        function aI(t) {
            return t.closest(".ck-widget__type-around__button")
        }

        function lI(t) {
            return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
        }

        function cI(t, e) {
            const n = t.closest(".ck-widget");
            return e.mapDomToView(n)
        }

        function dI(t) {
            return t.getAttribute(rI)
        }

        const uI = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
        var hI = n(5137);
        var fI = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        fI.insert = "head";
        fI.singleton = true;
        var gI = Bc()(hI.Z, fI);
        const mI = hI.Z.locals || {};
        const pI = ["before", "after"];
        const bI = (new DOMParser).parseFromString(uI, "image/svg+xml").firstChild;
        const kI = "ck-widget__type-around_disabled";

        class wI extends Ac {
            static get pluginName() {
                return "WidgetTypeAround"
            }

            static get requires() {
                return [iD, nE]
            }

            constructor(t) {
                super(t);
                this._currentFakeCaretModelElement = null
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                this.on("change:isEnabled", ((n, i, o) => {
                    e.change((t => {
                        for (const n of e.document.roots) {
                            if (o) {
                                t.removeClass(kI, n)
                            } else {
                                t.addClass(kI, n)
                            }
                        }
                    }));
                    if (!o) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(rI)
                        }))
                    }
                }));
                this._enableTypeAroundUIInjection();
                this._enableInsertingParagraphsOnButtonClick();
                this._enableInsertingParagraphsOnEnterKeypress();
                this._enableInsertingParagraphsOnTypingKeystroke();
                this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
                this._enableDeleteIntegration();
                this._enableInsertContentIntegration();
                this._enableInsertObjectIntegration();
                this._enableDeleteContentIntegration()
            }

            destroy() {
                super.destroy();
                this._currentFakeCaretModelElement = null
            }

            _insertParagraph(t, e) {
                const n = this.editor;
                const i = n.editing.view;
                const o = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", true);
                n.execute("insertParagraph", {position: n.model.createPositionAt(t, e), attributes: o});
                i.focus();
                i.scrollToTheSelection()
            }

            _listenToIfEnabled(t, e, n, i) {
                this.listenTo(t, e, ((...t) => {
                    if (this.isEnabled) {
                        n(...t)
                    }
                }), i)
            }

            _insertParagraphAccordingToFakeCaretPosition() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = dI(n);
                if (!i) {
                    return false
                }
                const o = n.getSelectedElement();
                this._insertParagraph(o, i);
                return true
            }

            _enableTypeAroundUIInjection() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.locale.t;
                const i = {before: n("Insert paragraph before block"), after: n("Insert paragraph after block")};
                t.editing.downcastDispatcher.on("insert", ((t, o, r) => {
                    const s = r.mapper.toViewElement(o.item);
                    if (!s) {
                        return
                    }
                    if (sI(s, o.item, e)) {
                        _I(r.writer, i, s);
                        const t = s.getCustomProperty("widgetLabel");
                        t.push((() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
                    }
                }), {priority: "low"})
            }

            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = e.schema;
                const o = t.editing.view;
                this._listenToIfEnabled(o.document, "arrowKey", ((t, e) => {
                    this._handleArrowKeyPress(t, e)
                }), {context: [GP, "$text"], priority: "high"});
                this._listenToIfEnabled(n, "change:range", ((e, n) => {
                    if (!n.directChange) {
                        return
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(rI)
                    }))
                }));
                this._listenToIfEnabled(e.document, "change:data", (() => {
                    const e = n.getSelectedElement();
                    if (e) {
                        const n = t.editing.mapper.toViewElement(e);
                        if (sI(n, e, i)) {
                            return
                        }
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(rI)
                    }))
                }));
                this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => {
                    const o = n.writer;
                    if (this._currentFakeCaretModelElement) {
                        const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                        if (t) {
                            o.removeClass(pI.map(r), t);
                            this._currentFakeCaretModelElement = null
                        }
                    }
                    const s = e.selection.getSelectedElement();
                    if (!s) {
                        return
                    }
                    const a = n.mapper.toViewElement(s);
                    if (!sI(a, s, i)) {
                        return
                    }
                    const l = dI(e.selection);
                    if (!l) {
                        return
                    }
                    o.addClass(r(l), a);
                    this._currentFakeCaretModelElement = s
                }));
                this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, i) => {
                    if (!i) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(rI)
                        }))
                    }
                }));

                function r(t) {
                    return `ck-widget_type-around_show-fake-caret_${t}`
                }
            }

            _handleArrowKeyPress(t, e) {
                const n = this.editor;
                const i = n.model;
                const o = i.document.selection;
                const r = i.schema;
                const s = n.editing.view;
                const a = e.keyCode;
                const l = Ul(a, n.locale.contentLanguageDirection);
                const c = s.document.selection.getSelectedElement();
                const d = n.editing.mapper.toModelElement(c);
                let u;
                if (sI(c, d, r)) {
                    u = this._handleArrowKeyPressOnSelectedWidget(l)
                } else if (o.isCollapsed) {
                    u = this._handleArrowKeyPressWhenSelectionNextToAWidget(l)
                } else if (!e.shiftKey) {
                    u = this._handleArrowKeyPressWhenNonCollapsedSelection(l)
                }
                if (u) {
                    e.preventDefault();
                    t.stop()
                }
            }

            _handleArrowKeyPressOnSelectedWidget(t) {
                const e = this.editor;
                const n = e.model;
                const i = n.document.selection;
                const o = dI(i);
                return n.change((e => {
                    if (o) {
                        const n = o === (t ? "after" : "before");
                        if (!n) {
                            e.removeSelectionAttribute(rI);
                            return true
                        }
                    } else {
                        e.setSelectionAttribute(rI, t ? "after" : "before");
                        return true
                    }
                    return false
                }))
            }

            _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
                const e = this.editor;
                const n = e.model;
                const i = n.schema;
                const o = e.plugins.get("Widget");
                const r = o._getObjectElementNextToSelection(t);
                const s = e.editing.mapper.toViewElement(r);
                if (sI(s, r, i)) {
                    n.change((e => {
                        o._setSelectionOverElement(r);
                        e.setSelectionAttribute(rI, t ? "before" : "after")
                    }));
                    return true
                }
                return false
            }

            _handleArrowKeyPressWhenNonCollapsedSelection(t) {
                const e = this.editor;
                const n = e.model;
                const i = n.schema;
                const o = e.editing.mapper;
                const r = n.document.selection;
                const s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter;
                const a = o.toViewElement(s);
                if (sI(a, s, i)) {
                    n.change((e => {
                        e.setSelection(s, "on");
                        e.setSelectionAttribute(rI, t ? "after" : "before")
                    }));
                    return true
                }
                return false
            }

            _enableInsertingParagraphsOnButtonClick() {
                const t = this.editor;
                const e = t.editing.view;
                this._listenToIfEnabled(e.document, "mousedown", ((n, i) => {
                    const o = aI(i.domTarget);
                    if (!o) {
                        return
                    }
                    const r = lI(o);
                    const s = cI(o, e.domConverter);
                    const a = t.editing.mapper.toModelElement(s);
                    this._insertParagraph(a, r);
                    i.preventDefault();
                    n.stop()
                }))
            }

            _enableInsertingParagraphsOnEnterKeypress() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = t.editing.view;
                this._listenToIfEnabled(n.document, "enter", ((n, i) => {
                    if (n.eventPhase != "atTarget") {
                        return
                    }
                    const o = e.getSelectedElement();
                    const r = t.editing.mapper.toViewElement(o);
                    const s = t.model.schema;
                    let a;
                    if (this._insertParagraphAccordingToFakeCaretPosition()) {
                        a = true
                    } else if (sI(r, o, s)) {
                        this._insertParagraph(o, i.isSoft ? "before" : "after");
                        a = true
                    }
                    if (a) {
                        i.preventDefault();
                        n.stop()
                    }
                }), {context: GP})
            }

            _enableInsertingParagraphsOnTypingKeystroke() {
                const t = this.editor;
                const e = t.editing.view.document;
                this._listenToIfEnabled(e, "insertText", ((t, n) => {
                    if (this._insertParagraphAccordingToFakeCaretPosition()) {
                        n.selection = e.selection
                    }
                }), {priority: "high"});
                if (r.isAndroid) {
                    this._listenToIfEnabled(e, "keydown", ((t, e) => {
                        if (e.keyCode == 229) {
                            this._insertParagraphAccordingToFakeCaretPosition()
                        }
                    }))
                } else {
                    this._listenToIfEnabled(e, "compositionstart", (() => {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }), {priority: "high"})
                }
            }

            _enableDeleteIntegration() {
                const t = this.editor;
                const e = t.editing.view;
                const n = t.model;
                const i = n.schema;
                this._listenToIfEnabled(e.document, "delete", ((e, o) => {
                    if (e.eventPhase != "atTarget") {
                        return
                    }
                    const r = dI(n.document.selection);
                    if (!r) {
                        return
                    }
                    const s = o.direction;
                    const a = n.document.selection.getSelectedElement();
                    const l = r === "before";
                    const c = s == "forward";
                    const d = l === c;
                    if (d) {
                        t.execute("delete", {selection: n.createSelection(a, "on")})
                    } else {
                        const e = i.getNearestSelectionRange(n.createPositionAt(a, r), s);
                        if (e) {
                            if (!e.isCollapsed) {
                                n.change((n => {
                                    n.setSelection(e);
                                    t.execute(c ? "deleteForward" : "delete")
                                }))
                            } else {
                                const o = n.createSelection(e.start);
                                n.modifySelection(o, {direction: s});
                                if (!o.focus.isEqual(e.start)) {
                                    n.change((n => {
                                        n.setSelection(e);
                                        t.execute(c ? "deleteForward" : "delete")
                                    }))
                                } else {
                                    const t = vI(i, e.start.parent);
                                    n.deleteContent(n.createSelection(t, "on"), {doNotAutoparagraph: true})
                                }
                            }
                        }
                    }
                    o.preventDefault();
                    e.stop()
                }), {context: GP})
            }

            _enableInsertContentIntegration() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                this._listenToIfEnabled(t.model, "insertContent", ((t, [i, o]) => {
                    if (o && !o.is("documentSelection")) {
                        return
                    }
                    const r = dI(n);
                    if (!r) {
                        return
                    }
                    t.stop();
                    return e.change((t => {
                        const o = n.getSelectedElement();
                        const s = e.createPositionAt(o, r);
                        const a = t.createSelection(s);
                        const l = e.insertContent(i, a);
                        t.setSelection(a);
                        return l
                    }))
                }), {priority: "high"})
            }

            _enableInsertObjectIntegration() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                this._listenToIfEnabled(t.model, "insertObject", ((t, e) => {
                    const [, i, , o = {}] = e;
                    if (i && !i.is("documentSelection")) {
                        return
                    }
                    const r = dI(n);
                    if (!r) {
                        return
                    }
                    o.findOptimalPosition = r;
                    e[3] = o
                }), {priority: "high"})
            }

            _enableDeleteContentIntegration() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                this._listenToIfEnabled(t.model, "deleteContent", ((t, [e]) => {
                    if (e && !e.is("documentSelection")) {
                        return
                    }
                    const i = dI(n);
                    if (i) {
                        t.stop()
                    }
                }), {priority: "high"})
            }
        }

        function _I(t, e, n) {
            const i = t.createUIElement("div", {class: "ck ck-reset_all ck-widget__type-around"}, (function (t) {
                const n = this.toDomElement(t);
                AI(n, e);
                CI(n);
                return n
            }));
            t.insert(t.createPositionAt(n, "end"), i)
        }

        function AI(t, e) {
            for (const n of pI) {
                const i = new N_({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`],
                        title: e[n],
                        "aria-hidden": "true"
                    },
                    children: [t.ownerDocument.importNode(bI, true)]
                });
                t.appendChild(i.render())
            }
        }

        function CI(t) {
            const e = new N_({tag: "div", attributes: {class: ["ck", "ck-widget__type-around__fake-caret"]}});
            t.appendChild(e.render())
        }

        function vI(t, e) {
            let n = e;
            for (const i of e.getAncestors({parentFirst: true})) {
                if (i.childCount > 1 || t.isLimit(i)) {
                    break
                }
                n = i
            }
            return n
        }

        function yI(t) {
            const e = t.model;
            return (n, i) => {
                const o = i.keyCode == Ol.arrowup;
                const r = i.keyCode == Ol.arrowdown;
                const s = i.shiftKey;
                const a = e.document.selection;
                if (!o && !r) {
                    return
                }
                const l = r;
                if (s && TI(a, l)) {
                    return
                }
                const c = xI(t, a, l);
                if (!c) {
                    return
                }
                if (c.isCollapsed) {
                    if (a.isCollapsed) {
                        return
                    } else if (s) {
                        return
                    }
                }
                if (c.isCollapsed || DI(t, c, l)) {
                    e.change((t => {
                        const n = l ? c.end : c.start;
                        if (s) {
                            const i = e.createSelection(a.anchor);
                            i.setFocus(n);
                            t.setSelection(i)
                        } else {
                            t.setSelection(n)
                        }
                    }));
                    n.stop();
                    i.preventDefault();
                    i.stopPropagation()
                }
            }
        }

        function xI(t, e, n) {
            const i = t.model;
            if (n) {
                const t = e.isCollapsed ? e.focus : e.getLastPosition();
                const n = EI(i, t, "forward");
                if (!n) {
                    return null
                }
                const o = i.createRange(t, n);
                const r = SI(i.schema, o, "backward");
                if (r) {
                    return i.createRange(t, r)
                }
                return null
            } else {
                const t = e.isCollapsed ? e.focus : e.getFirstPosition();
                const n = EI(i, t, "backward");
                if (!n) {
                    return null
                }
                const o = i.createRange(n, t);
                const r = SI(i.schema, o, "forward");
                if (r) {
                    return i.createRange(r, t)
                }
                return null
            }
        }

        function EI(t, e, n) {
            const i = t.schema;
            const o = t.createRangeIn(e.root);
            const r = n == "forward" ? "elementStart" : "elementEnd";
            for (const {previousPosition: t, item: s, type: a} of o.getWalker({startPosition: e, direction: n})) {
                if (i.isLimit(s) && !i.isInline(s)) {
                    return t
                }
                if (a == r && i.isBlock(s)) {
                    return null
                }
            }
            return null
        }

        function SI(t, e, n) {
            const i = n == "backward" ? e.end : e.start;
            if (t.checkChild(i, "$text")) {
                return i
            }
            for (const {nextPosition: i} of e.getWalker({direction: n})) {
                if (t.checkChild(i, "$text")) {
                    return i
                }
            }
            return null
        }

        function DI(t, e, n) {
            const i = t.model;
            const o = t.view.domConverter;
            if (n) {
                const t = i.createSelection(e.start);
                i.modifySelection(t);
                if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
                    e = i.createRange(t.focus, e.end)
                }
            }
            const r = t.mapper.toViewRange(e);
            const s = o.viewRangeToDom(r);
            const a = sl.getDomRangeRects(s);
            let l;
            for (const t of a) {
                if (l === undefined) {
                    l = Math.round(t.bottom);
                    continue
                }
                if (Math.round(t.top) >= l) {
                    return false
                }
                l = Math.max(l, Math.round(t.bottom))
            }
            return true
        }

        function TI(t, e) {
            return !t.isCollapsed && t.isBackward == e
        }

        var BI = n(6507);
        var PI = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        PI.insert = "head";
        PI.singleton = true;
        var II = Bc()(BI.Z, PI);
        const RI = BI.Z.locals || {};

        class zI extends Ac {
            static get pluginName() {
                return "Widget"
            }

            static get requires() {
                return [wI, nE]
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this._previouslySelected = new Set;
                this.editor.editing.downcastDispatcher.on("selection", ((e, n, i) => {
                    const o = i.writer;
                    const r = n.selection;
                    if (r.isCollapsed) {
                        return
                    }
                    const s = r.getSelectedElement();
                    if (!s) {
                        return
                    }
                    const a = t.editing.mapper.toViewElement(s);
                    if (!GP(a)) {
                        return
                    }
                    if (!i.consumable.consume(r, "selection")) {
                        return
                    }
                    o.setSelection(o.createRangeOn(a), {fake: true, label: XP(a)})
                }));
                this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => {
                    this._clearPreviouslySelectedWidgets(n.writer);
                    const i = n.writer;
                    const o = i.document.selection;
                    let r = null;
                    for (const t of o.getRanges()) {
                        for (const e of t) {
                            const t = e.item;
                            if (GP(t) && !FI(t, r)) {
                                i.addClass(UP, t);
                                this._previouslySelected.add(t);
                                r = t
                            }
                        }
                    }
                }), {priority: "low"});
                e.addObserver(Nw);
                this.listenTo(n, "mousedown", ((...t) => this._onMousedown(...t)));
                this.listenTo(n, "arrowKey", ((...t) => {
                    this._handleSelectionChangeOnArrowKeyPress(...t)
                }), {context: [GP, "$text"]});
                this.listenTo(n, "arrowKey", ((...t) => {
                    this._preventDefaultOnArrowKeyPress(...t)
                }), {context: "$root"});
                this.listenTo(n, "arrowKey", yI(this.editor.editing), {context: "$text"});
                this.listenTo(n, "delete", ((t, e) => {
                    if (this._handleDelete(e.direction == "forward")) {
                        e.preventDefault();
                        t.stop()
                    }
                }), {context: "$root"})
            }

            _onMousedown(t, e) {
                const n = this.editor;
                const i = n.editing.view;
                const o = i.document;
                let s = e.target;
                if (VI(s)) {
                    if ((r.isSafari || r.isGecko) && e.domEvent.detail >= 3) {
                        const t = n.editing.mapper;
                        const i = s.is("attributeElement") ? s.findAncestor((t => !t.is("attributeElement"))) : s;
                        const o = t.toModelElement(i);
                        e.preventDefault();
                        this.editor.model.change((t => {
                            t.setSelection(o, "in")
                        }))
                    }
                    return
                }
                if (!GP(s)) {
                    s = s.findAncestor(GP);
                    if (!s) {
                        return
                    }
                }
                if (r.isAndroid) {
                    e.preventDefault()
                }
                if (!o.isFocused) {
                    i.focus()
                }
                const a = n.editing.mapper.toModelElement(s);
                this._setSelectionOverElement(a)
            }

            _handleSelectionChangeOnArrowKeyPress(t, e) {
                const n = e.keyCode;
                const i = this.editor.model;
                const o = i.schema;
                const r = i.document.selection;
                const s = r.getSelectedElement();
                const a = jl(n, this.editor.locale.contentLanguageDirection);
                const l = a == "down" || a == "right";
                const c = a == "up" || a == "down";
                if (s && o.isObject(s)) {
                    const n = l ? r.getLastPosition() : r.getFirstPosition();
                    const s = o.getNearestSelectionRange(n, l ? "forward" : "backward");
                    if (s) {
                        i.change((t => {
                            t.setSelection(s)
                        }));
                        e.preventDefault();
                        t.stop()
                    }
                    return
                }
                if (!r.isCollapsed && !e.shiftKey) {
                    const n = r.getFirstPosition();
                    const s = r.getLastPosition();
                    const a = n.nodeAfter;
                    const c = s.nodeBefore;
                    if (a && o.isObject(a) || c && o.isObject(c)) {
                        i.change((t => {
                            t.setSelection(l ? s : n)
                        }));
                        e.preventDefault();
                        t.stop()
                    }
                    return
                }
                if (!r.isCollapsed) {
                    return
                }
                const d = this._getObjectElementNextToSelection(l);
                if (d && o.isObject(d)) {
                    if (o.isInline(d) && c) {
                        return
                    }
                    this._setSelectionOverElement(d);
                    e.preventDefault();
                    t.stop()
                }
            }

            _preventDefaultOnArrowKeyPress(t, e) {
                const n = this.editor.model;
                const i = n.schema;
                const o = n.document.selection.getSelectedElement();
                if (o && i.isObject(o)) {
                    e.preventDefault();
                    t.stop()
                }
            }

            _handleDelete(t) {
                if (this.editor.isReadOnly) {
                    return
                }
                const e = this.editor.model.document;
                const n = e.selection;
                if (!n.isCollapsed) {
                    return
                }
                const i = this._getObjectElementNextToSelection(t);
                if (i) {
                    this.editor.model.change((t => {
                        let e = n.anchor.parent;
                        while (e.isEmpty) {
                            const n = e;
                            e = n.parent;
                            t.remove(n)
                        }
                        this._setSelectionOverElement(i)
                    }));
                    return true
                }
            }

            _setSelectionOverElement(t) {
                this.editor.model.change((e => {
                    e.setSelection(e.createRangeOn(t))
                }))
            }

            _getObjectElementNextToSelection(t) {
                const e = this.editor.model;
                const n = e.schema;
                const i = e.document.selection;
                const o = e.createSelection(i);
                e.modifySelection(o, {direction: t ? "forward" : "backward"});
                if (o.isEqual(i)) {
                    return null
                }
                const r = t ? o.focus.nodeBefore : o.focus.nodeAfter;
                if (!!r && n.isObject(r)) {
                    return r
                }
                return null
            }

            _clearPreviouslySelectedWidgets(t) {
                for (const e of this._previouslySelected) {
                    t.removeClass(UP, e)
                }
                this._previouslySelected.clear()
            }
        }

        function VI(t) {
            let e = t;
            while (e) {
                if (e.is("editableElement") && !e.is("rootElement")) {
                    return true
                }
                if (GP(e)) {
                    return false
                }
                e = e.parent
            }
            return false
        }

        function FI(t, e) {
            if (!e) {
                return false
            }
            return Array.from(t.getAncestors()).includes(e)
        }

        class LI extends Ac {
            static get requires() {
                return [Ky]
            }

            static get pluginName() {
                return "WidgetToolbarRepository"
            }

            init() {
                const t = this.editor;
                if (t.plugins.has("BalloonToolbar")) {
                    const e = t.plugins.get("BalloonToolbar");
                    this.listenTo(e, "show", (e => {
                        if (MI(t.editing.view.document.selection)) {
                            e.stop()
                        }
                    }), {priority: "high"})
                }
                this._toolbarDefinitions = new Map;
                this._balloon = this.editor.plugins.get("ContextualBalloon");
                this.on("change:isEnabled", (() => {
                    this._updateToolbarsVisibility()
                }));
                this.listenTo(t.ui, "update", (() => {
                    this._updateToolbarsVisibility()
                }));
                this.listenTo(t.ui.focusTracker, "change:isFocused", (() => {
                    this._updateToolbarsVisibility()
                }), {priority: "low"})
            }

            destroy() {
                super.destroy();
                for (const t of this._toolbarDefinitions.values()) {
                    t.view.destroy()
                }
            }

            register(t, {ariaLabel: e, items: n, getRelatedElement: i, balloonClassName: o = "ck-toolbar-container"}) {
                if (!n.length) {
                    I("widget-toolbar-no-items", {toolbarId: t});
                    return
                }
                const r = this.editor;
                const s = r.t;
                const a = new yv(r.locale);
                a.ariaLabel = e || s("Widget toolbar");
                if (this._toolbarDefinitions.has(t)) {
                    throw new P("widget-toolbar-duplicated", this, {toolbarId: t})
                }
                a.fillFromConfig(n, r.ui.componentFactory);
                const l = {view: a, getRelatedElement: i, balloonClassName: o};
                r.ui.addToolbar(a, {
                    isContextual: true, beforeFocus: () => {
                        const t = i(r.editing.view.document.selection);
                        if (t) {
                            this._showToolbar(l, t)
                        }
                    }, afterBlur: () => {
                        this._hideToolbar(l)
                    }
                });
                this._toolbarDefinitions.set(t, l)
            }

            _updateToolbarsVisibility() {
                let t = 0;
                let e = null;
                let n = null;
                for (const i of this._toolbarDefinitions.values()) {
                    const o = i.getRelatedElement(this.editor.editing.view.document.selection);
                    if (!this.isEnabled || !o) {
                        if (this._isToolbarInBalloon(i)) {
                            this._hideToolbar(i)
                        }
                    } else if (!this.editor.ui.focusTracker.isFocused) {
                        if (this._isToolbarVisible(i)) {
                            this._hideToolbar(i)
                        }
                    } else {
                        const r = o.getAncestors().length;
                        if (r > t) {
                            t = r;
                            e = o;
                            n = i
                        }
                    }
                }
                if (n) {
                    this._showToolbar(n, e)
                }
            }

            _hideToolbar(t) {
                this._balloon.remove(t.view);
                this.stopListening(this._balloon, "change:visibleView")
            }

            _showToolbar(t, e) {
                if (this._isToolbarVisible(t)) {
                    OI(this.editor, e)
                } else if (!this._isToolbarInBalloon(t)) {
                    this._balloon.add({
                        view: t.view,
                        position: NI(this.editor, e),
                        balloonClassName: t.balloonClassName
                    });
                    this.listenTo(this._balloon, "change:visibleView", (() => {
                        for (const t of this._toolbarDefinitions.values()) {
                            if (this._isToolbarVisible(t)) {
                                const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                                OI(this.editor, e)
                            }
                        }
                    }))
                }
            }

            _isToolbarVisible(t) {
                return this._balloon.visibleView === t.view
            }

            _isToolbarInBalloon(t) {
                return this._balloon.hasView(t.view)
            }
        }

        function OI(t, e) {
            const n = t.plugins.get("ContextualBalloon");
            const i = NI(t, e);
            n.updatePosition(i)
        }

        function NI(t, e) {
            const n = t.editing.view;
            const i = vA.defaultPositions;
            return {
                target: n.domConverter.mapViewToDom(e),
                positions: [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast, i.viewportStickyNorth]
            }
        }

        function MI(t) {
            const e = t.getSelectedElement();
            return !!(e && GP(e))
        }

        class HI extends (dt()) {
            constructor(t) {
                super();
                this.set("activeHandlePosition", null);
                this.set("proposedWidthPercents", null);
                this.set("proposedWidth", null);
                this.set("proposedHeight", null);
                this.set("proposedHandleHostWidth", null);
                this.set("proposedHandleHostHeight", null);
                this._options = t;
                this._referenceCoordinates = null
            }

            get originalWidth() {
                return this._originalWidth
            }

            get originalHeight() {
                return this._originalHeight
            }

            get originalWidthPercents() {
                return this._originalWidthPercents
            }

            get aspectRatio() {
                return this._aspectRatio
            }

            begin(t, e, n) {
                const i = new sl(e);
                this.activeHandlePosition = $I(t);
                this._referenceCoordinates = qI(e, UI(this.activeHandlePosition));
                this._originalWidth = i.width;
                this._originalHeight = i.height;
                this._aspectRatio = i.width / i.height;
                const o = n.style.width;
                if (o && o.match(/^\d+(\.\d*)?%$/)) {
                    this._originalWidthPercents = parseFloat(o)
                } else {
                    this._originalWidthPercents = WI(n, i)
                }
            }

            update(t) {
                this.proposedWidth = t.width;
                this.proposedHeight = t.height;
                this.proposedWidthPercents = t.widthPercents;
                this.proposedHandleHostWidth = t.handleHostWidth;
                this.proposedHandleHostHeight = t.handleHostHeight
            }
        }

        function WI(t, e) {
            const n = t.parentElement;
            const i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
            return e.width / i * 100
        }

        function qI(t, e) {
            const n = new sl(t);
            const i = e.split("-");
            const o = {x: i[1] == "right" ? n.right : n.left, y: i[0] == "bottom" ? n.bottom : n.top};
            o.x += t.ownerDocument.defaultView.scrollX;
            o.y += t.ownerDocument.defaultView.scrollY;
            return o
        }

        function jI(t) {
            return `ck-widget__resizer__handle-${t}`
        }

        function $I(t) {
            const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
            for (const n of e) {
                if (t.classList.contains(jI(n))) {
                    return n
                }
            }
        }

        function UI(t) {
            const e = t.split("-");
            const n = {top: "bottom", bottom: "top", left: "right", right: "left"};
            return `${n[e[0]]}-${n[e[1]]}`
        }

        class GI extends pA {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-size-view", t.to("_viewPosition", (t => t ? `ck-orientation-${t}` : ""))],
                        style: {display: t.if("_isVisible", "none", (t => !t))}
                    },
                    children: [{text: t.to("_label")}]
                })
            }

            _bindToState(t, e) {
                this.bind("_isVisible").to(e, "proposedWidth", e, "proposedHeight", ((t, e) => t !== null && e !== null));
                this.bind("_label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", ((e, n, i) => {
                    if (t.unit === "px") {
                        return `${e}×${n}`
                    } else {
                        return `${i}%`
                    }
                }));
                this.bind("_viewPosition").to(e, "activeHandlePosition", e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", ((t, e, n) => e < 50 || n < 50 ? "above-center" : t))
            }

            _dismiss() {
                this.unbind();
                this._isVisible = false
            }
        }

        class KI extends (dt()) {
            constructor(t) {
                super();
                this._options = t;
                this._viewResizerWrapper = null;
                this.set("isEnabled", true);
                this.set("isSelected", false);
                this.bind("isVisible").to(this, "isEnabled", this, "isSelected", ((t, e) => t && e));
                this.decorate("begin");
                this.decorate("cancel");
                this.decorate("commit");
                this.decorate("updateSize");
                this.on("commit", (t => {
                    if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                        this._cleanup();
                        t.stop()
                    }
                }), {priority: "high"})
            }

            get state() {
                return this._state
            }

            show() {
                const t = this._options.editor.editing.view;
                t.change((t => {
                    t.removeClass("ck-hidden", this._viewResizerWrapper)
                }))
            }

            hide() {
                const t = this._options.editor.editing.view;
                t.change((t => {
                    t.addClass("ck-hidden", this._viewResizerWrapper)
                }))
            }

            attach() {
                const t = this;
                const e = this._options.viewElement;
                const n = this._options.editor.editing.view;
                n.change((n => {
                    const i = n.createUIElement("div", {class: "ck ck-reset_all ck-widget__resizer"}, (function (e) {
                        const n = this.toDomElement(e);
                        t._appendHandles(n);
                        t._appendSizeUI(n);
                        return n
                    }));
                    n.insert(n.createPositionAt(e, "end"), i);
                    n.addClass("ck-widget_with-resizer", e);
                    this._viewResizerWrapper = i;
                    if (!this.isVisible) {
                        this.hide()
                    }
                }));
                this.on("change:isVisible", (() => {
                    if (this.isVisible) {
                        this.show();
                        this.redraw()
                    } else {
                        this.hide()
                    }
                }))
            }

            begin(t) {
                this._state = new HI(this._options);
                this._sizeView._bindToState(this._options, this.state);
                this._initialViewWidth = this._options.viewElement.getStyle("width");
                this.state.begin(t, this._getHandleHost(), this._getResizeHost())
            }

            updateSize(t) {
                const e = this._proposeNewSize(t);
                const n = this._options.editor.editing.view;
                n.change((t => {
                    const n = this._options.unit || "%";
                    const i = (n === "%" ? e.widthPercents : e.width) + n;
                    t.setStyle("width", i, this._options.viewElement)
                }));
                const i = this._getHandleHost();
                const o = new sl(i);
                const r = Math.round(o.width);
                const s = Math.round(o.height);
                const a = new sl(i);
                e.width = Math.round(a.width);
                e.height = Math.round(a.height);
                this.redraw(o);
                this.state.update({...e, handleHostWidth: r, handleHostHeight: s})
            }

            commit() {
                const t = this._options.unit || "%";
                const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
                this._options.editor.editing.view.change((() => {
                    this._cleanup();
                    this._options.onCommit(e)
                }))
            }

            cancel() {
                this._cleanup()
            }

            destroy() {
                this.cancel()
            }

            redraw(t) {
                const e = this._domResizerWrapper;
                if (!YI(e)) {
                    return
                }
                const n = e.parentElement;
                const i = this._getHandleHost();
                const o = this._viewResizerWrapper;
                const r = [o.getStyle("width"), o.getStyle("height"), o.getStyle("left"), o.getStyle("top")];
                let s;
                if (n.isSameNode(i)) {
                    const e = t || new sl(i);
                    s = [e.width + "px", e.height + "px", undefined, undefined]
                } else {
                    s = [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"]
                }
                if (vt(r, s) !== "same") {
                    this._options.editor.editing.view.change((t => {
                        t.setStyle({width: s[0], height: s[1], left: s[2], top: s[3]}, o)
                    }))
                }
            }

            containsHandle(t) {
                return this._domResizerWrapper.contains(t)
            }

            static isResizeHandle(t) {
                return t.classList.contains("ck-widget__resizer__handle")
            }

            _cleanup() {
                this._sizeView._dismiss();
                const t = this._options.editor.editing.view;
                t.change((t => {
                    t.setStyle("width", this._initialViewWidth, this._options.viewElement)
                }))
            }

            _proposeNewSize(t) {
                const e = this.state;
                const n = JI(t);
                const i = this._options.isCentered ? this._options.isCentered(this) : true;
                const o = {
                    x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                    y: n.y - e.originalHeight - e._referenceCoordinates.y
                };
                if (i && e.activeHandlePosition.endsWith("-right")) {
                    o.x = n.x - (e._referenceCoordinates.x + e.originalWidth)
                }
                if (i) {
                    o.x *= 2
                }
                let r = Math.abs(e.originalWidth + o.x);
                let s = Math.abs(e.originalHeight + o.y);
                const a = r / e.aspectRatio > s ? "width" : "height";
                if (a == "width") {
                    s = r / e.aspectRatio
                } else {
                    r = s * e.aspectRatio
                }
                return {
                    width: Math.round(r),
                    height: Math.round(s),
                    widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * r * 100) / 100, 100)
                }
            }

            _getResizeHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getResizeHost(t)
            }

            _getHandleHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getHandleHost(t)
            }

            get _domResizerWrapper() {
                return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper)
            }

            _appendHandles(t) {
                const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                for (const n of e) {
                    t.appendChild(new N_({
                        tag: "div",
                        attributes: {class: `ck-widget__resizer__handle ${ZI(n)}`}
                    }).render())
                }
            }

            _appendSizeUI(t) {
                this._sizeView = new GI;
                this._sizeView.render();
                t.appendChild(this._sizeView.element)
            }
        }

        function ZI(t) {
            return `ck-widget__resizer__handle-${t}`
        }

        function JI(t) {
            return {x: t.pageX, y: t.pageY}
        }

        function YI(t) {
            return t && t.ownerDocument && t.ownerDocument.contains(t)
        }

        var QI = "Expected a function";

        function XI(t, e, n) {
            var i = true, o = true;
            if (typeof t != "function") {
                throw new TypeError(QI)
            }
            if (it(n)) {
                i = "leading" in n ? !!n.leading : i;
                o = "trailing" in n ? !!n.trailing : o
            }
            return Qf(t, e, {leading: i, maxWait: e, trailing: o})
        }

        const tR = XI;
        var eR = n(2263);
        var nR = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        nR.insert = "head";
        nR.singleton = true;
        var iR = Bc()(eR.Z, nR);
        const oR = eR.Z.locals || {};

        class rR extends Ac {
            static get pluginName() {
                return "WidgetResize"
            }

            init() {
                const t = this.editor.editing;
                const e = Xa.window.document;
                this.set("selectedResizer", null);
                this.set("_activeResizer", null);
                this._resizers = new Map;
                t.view.addObserver(Nw);
                this._observer = new (Ka());
                this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), {priority: "high"});
                this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this));
                this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this));
                this._redrawSelectedResizerThrottled = tR((() => this.redrawSelectedResizer()), 200);
                this.editor.ui.on("update", this._redrawSelectedResizerThrottled);
                this.editor.model.document.on("change", (() => {
                    for (const [t, e] of this._resizers) {
                        if (!t.isAttached()) {
                            this._resizers.delete(t);
                            e.destroy()
                        }
                    }
                }), {priority: "lowest"});
                this._observer.listenTo(Xa.window, "resize", this._redrawSelectedResizerThrottled);
                const n = this.editor.editing.view.document.selection;
                n.on("change", (() => {
                    const t = n.getSelectedElement();
                    const e = this.getResizerByViewElement(t) || null;
                    if (e) {
                        this.select(e)
                    } else {
                        this.deselect()
                    }
                }))
            }

            redrawSelectedResizer() {
                if (this.selectedResizer && this.selectedResizer.isVisible) {
                    this.selectedResizer.redraw()
                }
            }

            destroy() {
                super.destroy();
                this._observer.stopListening();
                for (const t of this._resizers.values()) {
                    t.destroy()
                }
                this._redrawSelectedResizerThrottled.cancel()
            }

            select(t) {
                this.deselect();
                this.selectedResizer = t;
                this.selectedResizer.isSelected = true
            }

            deselect() {
                if (this.selectedResizer) {
                    this.selectedResizer.isSelected = false
                }
                this.selectedResizer = null
            }

            attachTo(t) {
                const e = new KI(t);
                const n = this.editor.plugins;
                e.attach();
                if (n.has("WidgetToolbarRepository")) {
                    const t = n.get("WidgetToolbarRepository");
                    e.on("begin", (() => {
                        t.forceDisabled("resize")
                    }), {priority: "lowest"});
                    e.on("cancel", (() => {
                        t.clearForceDisabled("resize")
                    }), {priority: "highest"});
                    e.on("commit", (() => {
                        t.clearForceDisabled("resize")
                    }), {priority: "highest"})
                }
                this._resizers.set(t.viewElement, e);
                const i = this.editor.editing.view.document.selection;
                const o = i.getSelectedElement();
                if (this.getResizerByViewElement(o) == e) {
                    this.select(e)
                }
                return e
            }

            getResizerByViewElement(t) {
                return this._resizers.get(t)
            }

            _getResizerByHandle(t) {
                for (const e of this._resizers.values()) {
                    if (e.containsHandle(t)) {
                        return e
                    }
                }
            }

            _mouseDownListener(t, e) {
                const n = e.domTarget;
                if (!KI.isResizeHandle(n)) {
                    return
                }
                this._activeResizer = this._getResizerByHandle(n) || null;
                if (this._activeResizer) {
                    this._activeResizer.begin(n);
                    t.stop();
                    e.preventDefault()
                }
            }

            _mouseMoveListener(t, e) {
                if (this._activeResizer) {
                    this._activeResizer.updateSize(e)
                }
            }

            _mouseUpListener() {
                if (this._activeResizer) {
                    this._activeResizer.commit();
                    this._activeResizer = null
                }
            }
        }

        var sR = n(390);
        var aR = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        aR.insert = "head";
        aR.singleton = true;
        var lR = Bc()(sR.Z, aR);
        const cR = sR.Z.locals || {};

        class dR extends Ac {
            static get pluginName() {
                return "DragDrop"
            }

            static get requires() {
                return [NP, zI]
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                this._draggedRange = null;
                this._draggingUid = "";
                this._draggableElement = null;
                this._updateDropMarkerThrottled = tR((t => this._updateDropMarker(t)), 40);
                this._removeDropMarkerDelayed = kR((() => this._removeDropMarker()), 40);
                this._clearDraggableAttributesDelayed = kR((() => this._clearDraggableAttributes()), 40);
                e.addObserver(RP);
                e.addObserver(Nw);
                this._setupDragging();
                this._setupContentInsertionIntegration();
                this._setupClipboardInputIntegration();
                this._setupDropMarker();
                this._setupDraggableAttributeHandling();
                this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                    if (n) {
                        this.forceDisabled("readOnlyMode")
                    } else {
                        this.clearForceDisabled("readOnlyMode")
                    }
                }));
                this.on("change:isEnabled", ((t, e, n) => {
                    if (!n) {
                        this._finalizeDragging(false)
                    }
                }));
                if (r.isAndroid) {
                    this.forceDisabled("noAndroidSupport")
                }
            }

            destroy() {
                if (this._draggedRange) {
                    this._draggedRange.detach();
                    this._draggedRange = null
                }
                this._updateDropMarkerThrottled.cancel();
                this._removeDropMarkerDelayed.cancel();
                this._clearDraggableAttributesDelayed.cancel();
                return super.destroy()
            }

            _setupDragging() {
                const t = this.editor;
                const e = t.model;
                const n = e.document;
                const i = t.editing.view;
                const o = i.document;
                this.listenTo(o, "dragstart", ((i, r) => {
                    const s = n.selection;
                    if (r.target && r.target.is("editableElement")) {
                        r.preventDefault();
                        return
                    }
                    const a = r.target ? wR(r.target) : null;
                    if (a) {
                        const n = t.editing.mapper.toModelElement(a);
                        this._draggedRange = Mm.fromRange(e.createRangeOn(n));
                        if (t.plugins.has("WidgetToolbarRepository")) {
                            t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop")
                        }
                    } else if (!o.selection.isCollapsed) {
                        const t = o.selection.getSelectedElement();
                        if (!t || !GP(t)) {
                            this._draggedRange = Mm.fromRange(s.getFirstRange())
                        }
                    }
                    if (!this._draggedRange) {
                        r.preventDefault();
                        return
                    }
                    this._draggingUid = E();
                    r.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
                    r.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                    const l = e.createSelection(this._draggedRange.toRange());
                    const c = t.data.toView(e.getSelectedContent(l));
                    o.fire("clipboardOutput", {dataTransfer: r.dataTransfer, content: c, method: "dragstart"});
                    if (!this.isEnabled) {
                        this._draggedRange.detach();
                        this._draggedRange = null;
                        this._draggingUid = ""
                    }
                }), {priority: "low"});
                this.listenTo(o, "dragend", ((t, e) => {
                    this._finalizeDragging(!e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move")
                }), {priority: "low"});
                this.listenTo(o, "dragenter", (() => {
                    if (!this.isEnabled) {
                        return
                    }
                    i.focus()
                }));
                this.listenTo(o, "dragleave", (() => {
                    this._removeDropMarkerDelayed()
                }));
                this.listenTo(o, "dragging", ((e, n) => {
                    if (!this.isEnabled) {
                        n.dataTransfer.dropEffect = "none";
                        return
                    }
                    this._removeDropMarkerDelayed.cancel();
                    const i = uR(t, n.targetRanges, n.target);
                    if (!this._draggedRange) {
                        n.dataTransfer.dropEffect = "copy"
                    }
                    if (!r.isGecko) {
                        if (n.dataTransfer.effectAllowed == "copy") {
                            n.dataTransfer.dropEffect = "copy"
                        } else if (["all", "copyMove"].includes(n.dataTransfer.effectAllowed)) {
                            n.dataTransfer.dropEffect = "move"
                        }
                    }
                    if (i) {
                        this._updateDropMarkerThrottled(i)
                    }
                }), {priority: "low"})
            }

            _setupClipboardInputIntegration() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this.listenTo(n, "clipboardInput", ((e, n) => {
                    if (n.method != "drop") {
                        return
                    }
                    const i = uR(t, n.targetRanges, n.target);
                    this._removeDropMarker();
                    if (!i) {
                        this._finalizeDragging(false);
                        e.stop();
                        return
                    }
                    if (this._draggedRange && this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
                        this._draggedRange.detach();
                        this._draggedRange = null;
                        this._draggingUid = ""
                    }
                    const o = bR(n.dataTransfer) == "move";
                    if (o && this._draggedRange && this._draggedRange.containsRange(i, true)) {
                        this._finalizeDragging(false);
                        e.stop();
                        return
                    }
                    n.targetRanges = [t.editing.mapper.toViewRange(i)]
                }), {priority: "high"})
            }

            _setupContentInsertionIntegration() {
                const t = this.editor.plugins.get(NP);
                t.on("contentInsertion", ((t, e) => {
                    if (!this.isEnabled || e.method !== "drop") {
                        return
                    }
                    const n = e.targetRanges.map((t => this.editor.editing.mapper.toModelRange(t)));
                    this.editor.model.change((t => t.setSelection(n)))
                }), {priority: "high"});
                t.on("contentInsertion", ((t, e) => {
                    if (!this.isEnabled || e.method !== "drop") {
                        return
                    }
                    const n = bR(e.dataTransfer) == "move";
                    const i = !e.resultRange || !e.resultRange.isCollapsed;
                    this._finalizeDragging(i && n)
                }), {priority: "lowest"})
            }

            _setupDraggableAttributeHandling() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this.listenTo(n, "mousedown", ((i, o) => {
                    if (r.isAndroid || !o) {
                        return
                    }
                    this._clearDraggableAttributesDelayed.cancel();
                    let s = wR(o.target);
                    if (r.isBlink && !t.isReadOnly && !s && !n.selection.isCollapsed) {
                        const t = n.selection.getSelectedElement();
                        if (!t || !GP(t)) {
                            s = n.selection.editableElement
                        }
                    }
                    if (s) {
                        e.change((t => {
                            t.setAttribute("draggable", "true", s)
                        }));
                        this._draggableElement = t.editing.mapper.toModelElement(s)
                    }
                }));
                this.listenTo(n, "mouseup", (() => {
                    if (!r.isAndroid) {
                        this._clearDraggableAttributesDelayed()
                    }
                }))
            }

            _clearDraggableAttributes() {
                const t = this.editor.editing;
                t.view.change((e => {
                    if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
                        e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement))
                    }
                    this._draggableElement = null
                }))
            }

            _setupDropMarker() {
                const t = this.editor;
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: "drop-target",
                    view: {classes: ["ck-clipboard-drop-target-range"]}
                });
                t.conversion.for("editingDowncast").markerToElement({
                    model: "drop-target", view: (e, {writer: n}) => {
                        const i = t.model.schema.checkChild(e.markerRange.start, "$text");
                        if (!i) {
                            return
                        }
                        return n.createUIElement("span", {class: "ck ck-clipboard-drop-target-position"}, (function (t) {
                            const e = this.toDomElement(t);
                            e.append("⁠", t.createElement("span"), "⁠");
                            return e
                        }))
                    }
                })
            }

            _updateDropMarker(t) {
                const e = this.editor;
                const n = e.model.markers;
                e.model.change((e => {
                    if (n.has("drop-target")) {
                        if (!n.get("drop-target").getRange().isEqual(t)) {
                            e.updateMarker("drop-target", {range: t})
                        }
                    } else {
                        e.addMarker("drop-target", {range: t, usingOperation: false, affectsData: false})
                    }
                }))
            }

            _removeDropMarker() {
                const t = this.editor.model;
                this._removeDropMarkerDelayed.cancel();
                this._updateDropMarkerThrottled.cancel();
                if (t.markers.has("drop-target")) {
                    t.change((t => {
                        t.removeMarker("drop-target")
                    }))
                }
            }

            _finalizeDragging(t) {
                const e = this.editor;
                const n = e.model;
                this._removeDropMarker();
                this._clearDraggableAttributes();
                if (e.plugins.has("WidgetToolbarRepository")) {
                    e.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop")
                }
                this._draggingUid = "";
                if (!this._draggedRange) {
                    return
                }
                if (t && this.isEnabled) {
                    n.deleteContent(n.createSelection(this._draggedRange), {doNotAutoparagraph: true})
                }
                this._draggedRange.detach();
                this._draggedRange = null
            }
        }

        function uR(t, e, n) {
            const i = t.model;
            const o = t.editing.mapper;
            let s = null;
            const a = e ? e[0].start : null;
            if (n.is("uiElement")) {
                n = n.parent
            }
            s = hR(t, n);
            if (s) {
                return s
            }
            const l = pR(t, n);
            const c = a ? o.toModelPosition(a) : null;
            if (!c) {
                return fR(t, l)
            }
            s = gR(t, c, l);
            if (s) {
                return s
            }
            s = i.schema.getNearestSelectionRange(c, r.isGecko ? "forward" : "backward");
            if (s) {
                return s
            }
            return mR(t, c.parent)
        }

        function hR(t, e) {
            const n = t.model;
            const i = t.editing.mapper;
            if (GP(e)) {
                return n.createRangeOn(i.toModelElement(e))
            }
            if (!e.is("editableElement")) {
                const t = e.findAncestor((t => GP(t) || t.is("editableElement")));
                if (GP(t)) {
                    return n.createRangeOn(i.toModelElement(t))
                }
            }
            return null
        }

        function fR(t, e) {
            const n = t.model;
            const i = n.schema;
            const o = n.createPositionAt(e, 0);
            return i.getNearestSelectionRange(o, "forward")
        }

        function gR(t, e, n) {
            const i = t.model;
            if (!i.schema.checkChild(n, "$block")) {
                return null
            }
            const o = i.createPositionAt(n, 0);
            const r = e.path.slice(0, o.path.length);
            const s = i.createPositionFromPath(e.root, r);
            const a = s.nodeAfter;
            if (a && i.schema.isObject(a)) {
                return i.createRangeOn(a)
            }
            return null
        }

        function mR(t, e) {
            const n = t.model;
            let i = e;
            while (i) {
                if (n.schema.isObject(i)) {
                    return n.createRangeOn(i)
                }
                i = i.parent
            }
            return null
        }

        function pR(t, e) {
            const n = t.editing.mapper;
            const i = t.editing.view;
            const o = n.toModelElement(e);
            if (o) {
                return o
            }
            const r = i.createPositionBefore(e);
            const s = n.findMappedViewAncestor(r);
            return n.toModelElement(s)
        }

        function bR(t) {
            if (r.isGecko) {
                return t.dropEffect
            }
            return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy"
        }

        function kR(t, e) {
            let n;

            function i(...o) {
                i.cancel();
                n = setTimeout((() => t(...o)), e)
            }

            i.cancel = () => {
                clearTimeout(n)
            };
            return i
        }

        function wR(t) {
            if (t.is("editableElement")) {
                return null
            }
            if (t.hasClass("ck-widget__selection-handle")) {
                return t.findAncestor(GP)
            }
            if (GP(t)) {
                return t
            }
            const e = t.findAncestor((t => GP(t) || t.is("editableElement")));
            if (GP(e)) {
                return e
            }
            return null
        }

        class _R extends Ac {
            static get pluginName() {
                return "PastePlainText"
            }

            static get requires() {
                return [NP]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = n.document;
                const o = e.document.selection;
                let r = false;
                n.addObserver(RP);
                this.listenTo(i, "keydown", ((t, e) => {
                    r = e.shiftKey
                }));
                t.plugins.get(NP).on("contentInsertion", ((t, n) => {
                    if (!r && !AR(n.content, e.schema)) {
                        return
                    }
                    e.change((t => {
                        const i = Array.from(o.getAttributes()).filter((([t]) => e.schema.getAttributeProperties(t).isFormatting));
                        if (!o.isCollapsed) {
                            e.deleteContent(o, {doNotAutoparagraph: true})
                        }
                        i.push(...o.getAttributes());
                        const r = t.createRangeIn(n.content);
                        for (const e of r.getItems()) {
                            if (e.is("$textProxy")) {
                                t.setAttributes(i, e)
                            }
                        }
                    }))
                }))
            }
        }

        function AR(t, e) {
            if (t.childCount > 1) {
                return false
            }
            const n = t.getChild(0);
            if (e.isObject(n)) {
                return false
            }
            return Array.from(n.getAttributeKeys()).length == 0
        }

        class CR extends Ac {
            static get pluginName() {
                return "Clipboard"
            }

            static get requires() {
                return [NP, dR, _R]
            }
        }

        class vR extends vc {
            constructor(t) {
                super(t);
                this.affectsData = false
            }

            execute() {
                const t = this.editor.model;
                const e = t.document.selection;
                let n = t.schema.getLimitElement(e);
                if (e.containsEntireContent(n) || !yR(t.schema, n)) {
                    do {
                        n = n.parent;
                        if (!n) {
                            return
                        }
                    } while (!yR(t.schema, n))
                }
                t.change((t => {
                    t.setSelection(n, "in")
                }))
            }
        }

        function yR(t, e) {
            return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        }

        const xR = Hl("Ctrl+A");

        class ER extends Ac {
            static get pluginName() {
                return "SelectAllEditing"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                t.commands.add("selectAll", new vR(t));
                this.listenTo(n, "keydown", ((e, n) => {
                    if (Ml(n) === xR) {
                        t.execute("selectAll");
                        n.preventDefault()
                    }
                }))
            }
        }

        const SR = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';

        class DR extends Ac {
            static get pluginName() {
                return "SelectAllUI"
            }

            init() {
                const t = this.editor;
                t.ui.componentFactory.add("selectAll", (e => {
                    const n = t.commands.get("selectAll");
                    const i = new LC(e);
                    const o = e.t;
                    i.set({label: o("Select all"), icon: SR, keystroke: "Ctrl+A", tooltip: true});
                    i.bind("isEnabled").to(n, "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute("selectAll");
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }

        class TR extends Ac {
            static get requires() {
                return [ER, DR]
            }

            static get pluginName() {
                return "SelectAll"
            }
        }

        class BR extends vc {
            constructor(t) {
                super(t);
                this._stack = [];
                this._createdBatches = new WeakSet;
                this.refresh();
                this.listenTo(t.data, "set", ((t, e) => {
                    e[1] = {...e[1]};
                    const n = e[1];
                    if (!n.batchType) {
                        n.batchType = {isUndoable: false}
                    }
                }), {priority: "high"});
                this.listenTo(t.data, "set", ((t, e) => {
                    const n = e[1];
                    if (!n.batchType.isUndoable) {
                        this.clearStack()
                    }
                }))
            }

            refresh() {
                this.isEnabled = this._stack.length > 0
            }

            addBatch(t) {
                const e = this.editor.model.document.selection;
                const n = {ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward};
                this._stack.push({batch: t, selection: n});
                this.refresh()
            }

            clearStack() {
                this._stack = [];
                this.refresh()
            }

            _restoreSelection(t, e, n) {
                const i = this.editor.model;
                const o = i.document;
                const r = [];
                const s = t.map((t => t.getTransformedByOperations(n)));
                const a = s.flat();
                for (const t of s) {
                    const e = t.filter((t => t.root != o.graveyard)).filter((t => !IR(t, a)));
                    if (!e.length) {
                        continue
                    }
                    PR(e);
                    r.push(e[0])
                }
                if (r.length) {
                    i.change((t => {
                        t.setSelection(r, {backward: e})
                    }))
                }
            }

            _undo(t, e) {
                const n = this.editor.model;
                const i = n.document;
                this._createdBatches.add(e);
                const o = t.operations.slice().filter((t => t.isDocumentOperation));
                o.reverse();
                for (const t of o) {
                    const o = t.baseVersion + 1;
                    const r = Array.from(i.history.getOperations(o));
                    const s = _k([t.getReversed()], r, {
                        useRelations: true,
                        document: this.editor.model.document,
                        padWithNoOps: false,
                        forceWeakRemove: true
                    });
                    const a = s.operationsA;
                    for (const o of a) {
                        e.addOperation(o);
                        n.applyOperation(o);
                        i.history.setOperationAsUndone(t, o)
                    }
                }
            }
        }

        function PR(t) {
            t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1));
            for (let e = 1; e < t.length; e++) {
                const n = t[e - 1];
                const i = n.getJoined(t[e], true);
                if (i) {
                    e--;
                    t.splice(e, 2, i)
                }
            }
        }

        function IR(t, e) {
            return e.some((e => e !== t && e.containsRange(t, true)))
        }

        class RR extends BR {
            execute(t = null) {
                const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1;
                const n = this._stack.splice(e, 1)[0];
                const i = this.editor.model.createBatch({isUndo: true});
                this.editor.model.enqueueChange(i, (() => {
                    this._undo(n.batch, i);
                    const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                    this._restoreSelection(n.selection.ranges, n.selection.isBackward, t);
                    this.fire("revert", n.batch, i)
                }));
                this.refresh()
            }
        }

        class zR extends BR {
            execute() {
                const t = this._stack.pop();
                const e = this.editor.model.createBatch({isUndo: true});
                this.editor.model.enqueueChange(e, (() => {
                    const n = t.batch.operations[t.batch.operations.length - 1];
                    const i = n.baseVersion + 1;
                    const o = this.editor.model.document.history.getOperations(i);
                    this._restoreSelection(t.selection.ranges, t.selection.isBackward, o);
                    this._undo(t.batch, e)
                }));
                this.refresh()
            }
        }

        class VR extends Ac {
            static get pluginName() {
                return "UndoEditing"
            }

            constructor(t) {
                super(t);
                this._batchRegistry = new WeakSet
            }

            init() {
                const t = this.editor;
                this._undoCommand = new RR(t);
                this._redoCommand = new zR(t);
                t.commands.add("undo", this._undoCommand);
                t.commands.add("redo", this._redoCommand);
                this.listenTo(t.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) {
                        return
                    }
                    const i = n.batch;
                    const o = this._redoCommand._createdBatches.has(i);
                    const r = this._undoCommand._createdBatches.has(i);
                    const s = this._batchRegistry.has(i);
                    if (s) {
                        return
                    }
                    this._batchRegistry.add(i);
                    if (!i.isUndoable) {
                        return
                    }
                    if (o) {
                        this._undoCommand.addBatch(i)
                    } else if (!r) {
                        this._undoCommand.addBatch(i);
                        this._redoCommand.clearStack()
                    }
                }), {priority: "highest"});
                this.listenTo(this._undoCommand, "revert", ((t, e, n) => {
                    this._redoCommand.addBatch(n)
                }));
                t.keystrokes.set("CTRL+Z", "undo");
                t.keystrokes.set("CTRL+Y", "redo");
                t.keystrokes.set("CTRL+SHIFT+Z", "redo")
            }
        }

        const FR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
        const LR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';

        class OR extends Ac {
            static get pluginName() {
                return "UndoUI"
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.t;
                const i = e.uiLanguageDirection == "ltr" ? FR : LR;
                const o = e.uiLanguageDirection == "ltr" ? LR : FR;
                this._addButton("undo", n("Undo"), "CTRL+Z", i);
                this._addButton("redo", n("Redo"), "CTRL+Y", o)
            }

            _addButton(t, e, n, i) {
                const o = this.editor;
                o.ui.componentFactory.add(t, (r => {
                    const s = o.commands.get(t);
                    const a = new LC(r);
                    a.set({label: e, icon: i, keystroke: n, tooltip: true});
                    a.bind("isEnabled").to(s, "isEnabled");
                    this.listenTo(a, "execute", (() => {
                        o.execute(t);
                        o.editing.view.focus()
                    }));
                    return a
                }))
            }
        }

        class NR extends Ac {
            static get requires() {
                return [VR, OR]
            }

            static get pluginName() {
                return "Undo"
            }
        }

        class MR extends Ac {
            static get requires() {
                return [CR, iD, TR, cD, iE, NR]
            }

            static get pluginName() {
                return "Essentials"
            }
        }

        var HR = n(1590);
        var WR = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        WR.insert = "head";
        WR.singleton = true;
        var qR = Bc()(HR.Z, WR);
        const jR = HR.Z.locals || {};
        var $R = n(9289);
        var UR = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        UR.insert = "head";
        UR.singleton = true;
        var GR = Bc()($R.Z, UR);
        const KR = $R.Z.locals || {};

        class ZR extends pA {
            constructor(t) {
                super(t);
                const e = t.t;
                this.set("matchCount", 0);
                this.set("highlightOffset", 0);
                this.set("isDirty", false);
                this.set("_areCommandsEnabled", {});
                this.set("_resultsCounterText", "");
                this.set("_matchCase", false);
                this.set("_wholeWordsOnly", false);
                this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", ((t, e) => t > 0 && !e));
                this._findInputView = this._createInputField(e("Find in text…"));
                this._replaceInputView = this._createInputField(e("Replace with…"));
                this._findButtonView = this._createButton({
                    label: e("Find"),
                    class: "ck-button-find ck-button-action",
                    withText: true
                });
                this._findPrevButtonView = this._createButton({
                    label: e("Previous result"),
                    class: "ck-button-prev",
                    icon: Ly,
                    keystroke: "Shift+F3",
                    tooltip: true
                });
                this._findNextButtonView = this._createButton({
                    label: e("Next result"),
                    class: "ck-button-next",
                    icon: Ly,
                    keystroke: "F3",
                    tooltip: true
                });
                this._optionsDropdown = this._createOptionsDropdown();
                this._replaceButtonView = this._createButton({
                    label: e("Replace"),
                    class: "ck-button-replace",
                    withText: true
                });
                this._replaceAllButtonView = this._createButton({
                    label: e("Replace all"),
                    class: "ck-button-replaceall",
                    withText: true
                });
                this._findFieldsetView = this._createFindFieldset();
                this._replaceFieldsetView = this._createReplaceFieldset();
                this._focusTracker = new ac;
                this._keystrokes = new lc;
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this._focusTracker,
                    keystrokeHandler: this._keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-find-and-replace-form"], tabindex: "-1"},
                    children: [new by(t, {label: e("Find and replace")}), this._findFieldsetView, this._replaceFieldsetView]
                });
                yC(this)
            }

            render() {
                super.render();
                xC({view: this});
                this._initFocusCycling();
                this._initKeystrokeHandling()
            }

            destroy() {
                super.destroy();
                this._focusTracker.destroy();
                this._keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            reset() {
                this._findInputView.errorText = null;
                this.isDirty = true
            }

            get _textToFind() {
                return this._findInputView.fieldView.element.value
            }

            get _textToReplace() {
                return this._replaceInputView.fieldView.element.value
            }

            _createFindFieldset() {
                const t = this.locale;
                const e = new pA(t);
                this._findInputView.fieldView.on("input", (() => {
                    this.isDirty = true
                }));
                this._findButtonView.on("execute", this._onFindButtonExecute.bind(this));
                this._findPrevButtonView.delegate("execute").to(this, "findPrevious");
                this._findNextButtonView.delegate("execute").to(this, "findNext");
                this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({findPrevious: t}) => t));
                this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({findNext: t}) => t));
                this._injectFindResultsCounter();
                e.setTemplate({
                    tag: "fieldset",
                    attributes: {class: ["ck", "ck-find-and-replace-form__find"]},
                    children: [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView]
                });
                return e
            }

            _onFindButtonExecute() {
                if (!this._textToFind) {
                    const t = this.t;
                    this._findInputView.errorText = t("Text to find must not be empty.");
                    return
                }
                this.isDirty = false;
                this.fire("findNext", {
                    searchText: this._textToFind,
                    matchCase: this._matchCase,
                    wholeWords: this._wholeWordsOnly
                })
            }

            _injectFindResultsCounter() {
                const t = this.locale;
                const e = t.t;
                const n = this.bindTemplate;
                const i = new pA(t);
                this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", ((t, n) => e("%0 of %1", [t, n])));
                i.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-results-counter", n.if("isDirty", "ck-hidden")]},
                    children: [{text: n.to("_resultsCounterText")}]
                });
                const o = () => {
                    const e = this._findInputView.fieldView.element;
                    if (!e || !pl(e)) {
                        return
                    }
                    const n = new sl(i.element).width;
                    const o = t.uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
                    if (!n) {
                        e.style[o] = null
                    } else {
                        e.style[o] = `calc( 2 * var(--ck-spacing-standard) + ${n}px )`
                    }
                };
                this.on("change:_resultsCounterText", o, {priority: "low"});
                this.on("change:isDirty", o, {priority: "low"});
                this._findInputView.template.children[0].children.push(i)
            }

            _createReplaceFieldset() {
                const t = this.locale;
                const e = t.t;
                const n = new pA(t);
                this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({replace: t}, e) => t && e));
                this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({replaceAll: t}, e) => t && e));
                this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({replace: t}, e) => t && e));
                this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", ((t, n) => {
                    if (t || !n) {
                        return ""
                    }
                    return e("Tip: Find some text first in order to replace it.")
                }));
                this._replaceButtonView.on("execute", (() => {
                    this.fire("replace", {searchText: this._textToFind, replaceText: this._textToReplace})
                }));
                this._replaceAllButtonView.on("execute", (() => {
                    this.fire("replaceAll", {searchText: this._textToFind, replaceText: this._textToReplace});
                    this.focus()
                }));
                n.setTemplate({
                    tag: "fieldset",
                    attributes: {class: ["ck", "ck-find-and-replace-form__replace"]},
                    children: [this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView]
                });
                return n
            }

            _createOptionsDropdown() {
                const t = this.locale;
                const e = t.t;
                const n = qv(t);
                n.class = "ck-options-dropdown";
                n.buttonView.set({withText: false, label: e("Show options"), icon: CC.cog, tooltip: true});
                const i = new Fy({withText: true, label: e("Match case"), _isMatchCaseSwitch: true});
                const o = new Fy({withText: true, label: e("Whole words only")});
                i.bind("isOn").to(this, "_matchCase");
                o.bind("isOn").to(this, "_wholeWordsOnly");
                n.on("execute", (t => {
                    if (t.source._isMatchCaseSwitch) {
                        this._matchCase = !this._matchCase
                    } else {
                        this._wholeWordsOnly = !this._wholeWordsOnly
                    }
                    this.isDirty = true
                }));
                $v(n, new rc([{type: "switchbutton", model: i}, {type: "switchbutton", model: o}]));
                return n
            }

            _initFocusCycling() {
                const t = [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this._focusTracker.add(t.element)
                }))
            }

            _initKeystrokeHandling() {
                const t = t => t.stopPropagation();
                const e = t => {
                    t.stopPropagation();
                    t.preventDefault()
                };
                this._keystrokes.listenTo(this.element);
                this._keystrokes.set("f3", (t => {
                    e(t);
                    this._findNextButtonView.fire("execute")
                }));
                this._keystrokes.set("shift+f3", (t => {
                    e(t);
                    this._findPrevButtonView.fire("execute")
                }));
                this._keystrokes.set("enter", (t => {
                    const n = t.target;
                    if (n === this._findInputView.fieldView.element) {
                        if (this._areCommandsEnabled.findNext) {
                            this._findNextButtonView.fire("execute")
                        } else {
                            this._findButtonView.fire("execute")
                        }
                        e(t)
                    } else if (n === this._replaceInputView.fieldView.element && !this.isDirty) {
                        this._replaceButtonView.fire("execute");
                        e(t)
                    }
                }));
                this._keystrokes.set("shift+enter", (t => {
                    const n = t.target;
                    if (n !== this._findInputView.fieldView.element) {
                        return
                    }
                    if (this._areCommandsEnabled.findPrevious) {
                        this._findPrevButtonView.fire("execute")
                    } else {
                        this._findButtonView.fire("execute")
                    }
                    e(t)
                }));
                this._keystrokes.set("arrowright", t);
                this._keystrokes.set("arrowleft", t);
                this._keystrokes.set("arrowup", t);
                this._keystrokes.set("arrowdown", t);
                this.listenTo(this._findInputView.element, "selectstart", ((t, e) => {
                    e.stopPropagation()
                }), {priority: "high"});
                this.listenTo(this._replaceInputView.element, "selectstart", ((t, e) => {
                    e.stopPropagation()
                }), {priority: "high"})
            }

            _createButton(t) {
                const e = new LC(this.locale);
                e.set(t);
                return e
            }

            _createInputField(t) {
                const e = new Py(this.locale, Iy);
                e.label = t;
                return e
            }
        }

        const JR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>';

        class YR extends Ac {
            static get pluginName() {
                return "FindAndReplaceUI"
            }

            constructor(t) {
                super(t);
                this.formView = null
            }

            init() {
                const t = this.editor;
                t.ui.componentFactory.add("findAndReplace", (e => {
                    const n = qv(e);
                    const i = this.formView = new ZR(t.locale);
                    n.bind("isEnabled").to(t.commands.get("find"));
                    n.panelView.children.add(i);
                    n.on("change:isOpen", ((t, e, n) => {
                        if (n) {
                            i.disableCssTransitions();
                            i.reset();
                            i._findInputView.fieldView.select();
                            i.enableCssTransitions()
                        } else {
                            this.fire("searchReseted")
                        }
                    }), {priority: "low"});
                    this._setupDropdownButton(n);
                    this._setupFormView(i);
                    return n
                }))
            }

            _setupDropdownButton(t) {
                const e = this.editor;
                const n = e.locale.t;
                t.buttonView.set({icon: JR, label: n("Find and replace"), keystroke: "CTRL+F", tooltip: true});
                e.keystrokes.set("Ctrl+F", ((e, n) => {
                    t.isOpen = true;
                    n()
                }))
            }

            _setupFormView(t) {
                const e = this.editor;
                const n = e.commands;
                const i = this.editor.plugins.get("FindAndReplaceEditing");
                const o = i.state;
                const r = {before: -1, same: 0, after: 1};
                t.bind("highlightOffset").to(o, "highlightedResult", (t => {
                    if (!t) {
                        return 0
                    }
                    return Array.from(o.results).sort(((t, e) => r[t.marker.getStart().compareWith(e.marker.getStart())])).indexOf(t) + 1
                }));
                t.listenTo(o.results, "change", (() => {
                    t.matchCount = o.results.length
                }));
                t.bind("_areCommandsEnabled").to(n.get("findNext"), "isEnabled", n.get("findPrevious"), "isEnabled", n.get("replace"), "isEnabled", n.get("replaceAll"), "isEnabled", ((t, e, n, i) => ({
                    findNext: t,
                    findPrevious: e,
                    replace: n,
                    replaceAll: i
                })));
                t.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this);
                t.on("change:isDirty", ((t, e, n) => {
                    if (n) {
                        this.fire("searchReseted")
                    }
                }))
            }
        }

        function QR(t, e, n, i) {
            const o = i || new rc;
            e.change((i => {
                [...t].forEach((({type: t, item: r}) => {
                    if (t === "elementStart") {
                        if (e.schema.checkChild(r, "$text")) {
                            const t = n({item: r, text: XR(e.createRangeIn(r))});
                            if (!t) {
                                return
                            }
                            t.forEach((t => {
                                const e = `findResult:${E()}`;
                                const n = i.addMarker(e, {
                                    usingOperation: false,
                                    affectsData: false,
                                    range: i.createRange(i.createPositionAt(r, t.start), i.createPositionAt(r, t.end))
                                });
                                const s = tz(o, n);
                                o.add({id: e, label: t.label, marker: n}, s)
                            }))
                        }
                    }
                }))
            }));
            return o
        }

        function XR(t) {
            return Array.from(t.getItems()).reduce(((t, e) => {
                if (!(e.is("text") || e.is("textProxy"))) {
                    return `${t}\n`
                }
                return t + e.data
            }), "")
        }

        function tz(t, e) {
            const n = t.find((({marker: t}) => e.getStart().isBefore(t.getStart())));
            return n ? t.getIndex(n) : t.length
        }

        function ez(t) {
            const e = t.length - 1;
            let n = t.index;
            if (t.length === 3) {
                n += t[1].length
            }
            return {label: t[e], start: n, end: n + t[e].length}
        }

        function nz(t, e) {
            let n = "gu";
            if (!e.matchCase) {
                n += "i"
            }
            let i = `(${mE(t)})`;
            if (e.wholeWords) {
                const e = "[^a-zA-ZÀ-ɏḀ-ỿ]";
                if (!new RegExp("^" + e).test(t)) {
                    i = `(^|${e}|_)${i}`
                }
                if (!new RegExp(e + "$").test(t)) {
                    i = `${i}(?=_|${e}|$)`
                }
            }
            const o = new RegExp(i, n);

            function r({text: t}) {
                const e = [...t.matchAll(o)];
                return e.map(ez)
            }

            return r
        }

        class iz extends vc {
            constructor(t, e) {
                super(t);
                this.isEnabled = true;
                this.affectsData = false;
                this._state = e
            }

            execute(t, {matchCase: e, wholeWords: n} = {}) {
                const {editor: i} = this;
                const {model: o} = i;
                let r;
                if (typeof t === "string") {
                    r = nz(t, {matchCase: e, wholeWords: n});
                    this._state.searchText = t
                } else {
                    r = t
                }
                const s = o.document.getRootNames().reduce(((t, e) => QR(o.createRangeIn(o.document.getRoot(e)), o, r, t)), null);
                this._state.clear(o);
                this._state.results.addMany(Array.from(s));
                this._state.highlightedResult = s.get(0);
                if (typeof t === "string") {
                    this._state.searchText = t
                }
                this._state.matchCase = !!e;
                this._state.matchWholeWords = !!n;
                return {results: s, findCallback: r}
            }
        }

        class oz extends vc {
            constructor(t, e) {
                super(t);
                this.isEnabled = true;
                this._state = e
            }

            execute(t, e) {
                const {model: n} = this.editor;
                n.change((i => {
                    const o = e.marker.getRange();
                    if (o.root.rootName === "$graveyard") {
                        this._state.results.remove(e);
                        return
                    }
                    let r = {};
                    for (const t of o.getItems()) {
                        if (t.is("$text") || t.is("$textProxy")) {
                            r = t.getAttributes();
                            break
                        }
                    }
                    n.insertContent(i.createText(t, r), o);
                    if (this._state.results.has(e)) {
                        this._state.results.remove(e)
                    }
                }))
            }
        }

        class rz extends oz {
            execute(t, e) {
                const {editor: n} = this;
                const {model: i} = n;
                const o = e instanceof rc ? e : i.document.getRootNames().reduce(((t, n) => QR(i.createRangeIn(i.document.getRoot(n)), i, nz(e, this._state), t)), null);
                if (o.length) {
                    i.change((() => {
                        [...o].forEach((e => {
                            super.execute(t, e)
                        }))
                    }))
                }
            }
        }

        class sz extends vc {
            constructor(t, e) {
                super(t);
                this.affectsData = false;
                this._state = e;
                this.isEnabled = false;
                this.listenTo(this._state.results, "change", (() => {
                    this.isEnabled = this._state.results.length > 1
                }))
            }

            refresh() {
                this.isEnabled = this._state.results.length > 1
            }

            execute() {
                const t = this._state.results;
                const e = t.getIndex(this._state.highlightedResult);
                const n = e + 1 >= t.length ? 0 : e + 1;
                this._state.highlightedResult = this._state.results.get(n)
            }
        }

        class az extends sz {
            execute() {
                const t = this._state.results;
                const e = t.getIndex(this._state.highlightedResult);
                const n = e - 1 < 0 ? this._state.results.length - 1 : e - 1;
                this._state.highlightedResult = this._state.results.get(n)
            }
        }

        class lz {
            constructor(t) {
                this.set("results", new rc);
                this.set("highlightedResult", null);
                this.set("searchText", "");
                this.set("replaceText", "");
                this.set("matchCase", false);
                this.set("matchWholeWords", false);
                this.results.on("change", ((e, {removed: n, index: i}) => {
                    n = Array.from(n);
                    if (n.length) {
                        let e = false;
                        t.change((i => {
                            for (const o of n) {
                                if (this.highlightedResult === o) {
                                    e = true
                                }
                                if (t.markers.has(o.marker.name)) {
                                    i.removeMarker(o.marker)
                                }
                            }
                        }));
                        if (e) {
                            const t = i >= this.results.length ? 0 : i;
                            this.highlightedResult = this.results.get(t)
                        }
                    }
                }))
            }

            clear(t) {
                this.searchText = "";
                t.change((e => {
                    if (this.highlightedResult) {
                        const n = this.highlightedResult.marker.name.split(":")[1];
                        const i = t.markers.get(`findResultHighlighted:${n}`);
                        if (i) {
                            e.removeMarker(i)
                        }
                    }
                    [...this.results].forEach((({marker: t}) => {
                        e.removeMarker(t)
                    }))
                }));
                this.results.clear()
            }
        }

        A(lz, dt);
        var cz = n(5436);
        var dz = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        dz.insert = "head";
        dz.singleton = true;
        var uz = Bc()(cz.Z, dz);
        const hz = cz.Z.locals || {};
        const fz = "ck-find-result_selected";

        function gz(t, e, n) {
            const i = new Set;
            const o = new Set;
            const r = e.document.differ.getChanges();
            r.forEach((t => {
                if (t.name === "$text" || e.schema.isInline(t.position.nodeAfter)) {
                    i.add(t.position.parent);
                    [...e.markers.getMarkersAtPosition(t.position)].forEach((t => {
                        o.add(t.name)
                    }))
                } else if (t.type === "insert") {
                    i.add(t.position.nodeAfter)
                }
            }));
            e.document.differ.getChangedMarkers().forEach((({name: t, data: {newRange: e}}) => {
                if (e && e.start.root.rootName === "$graveyard") {
                    o.add(t)
                }
            }));
            i.forEach((t => {
                const n = [...e.markers.getMarkersIntersectingRange(e.createRangeIn(t))];
                n.forEach((t => o.add(t.name)))
            }));
            e.change((e => {
                o.forEach((n => {
                    if (t.has(n)) {
                        t.remove(n)
                    }
                    e.removeMarker(n)
                }))
            }));
            i.forEach((i => {
                QR(e.createRangeOn(i), e, n, t)
            }))
        }

        class mz extends Ac {
            static get pluginName() {
                return "FindAndReplaceEditing"
            }

            init() {
                this._activeResults = null;
                this.state = new lz(this.editor.model);
                this._defineConverters();
                this._defineCommands();
                this.listenTo(this.state, "change:highlightedResult", ((t, e, n, i) => {
                    const {model: o} = this.editor;
                    o.change((t => {
                        if (i) {
                            const e = i.marker.name.split(":")[1];
                            const n = o.markers.get(`findResultHighlighted:${e}`);
                            if (n) {
                                t.removeMarker(n)
                            }
                        }
                        if (n) {
                            const e = n.marker.name.split(":")[1];
                            t.addMarker(`findResultHighlighted:${e}`, {
                                usingOperation: false,
                                affectsData: false,
                                range: n.marker.getRange()
                            })
                        }
                    }))
                }));
                const t = Qf(e.bind(this), 32);
                this.listenTo(this.state, "change:highlightedResult", t, {priority: "low"});
                this.listenTo(this.editor, "destroy", t.cancel);

                function e(t, e, n) {
                    if (n) {
                        const t = this.editor.editing.view.domConverter;
                        const e = this.editor.editing.mapper.toViewRange(n.marker.getRange());
                        xl({target: t.viewRangeToDom(e), viewportOffset: 40})
                    }
                }
            }

            find(t) {
                const {editor: e} = this;
                const {model: n} = e;
                const {findCallback: i, results: o} = e.execute("find", t);
                this._activeResults = o;
                this.listenTo(n.document, "change:data", (() => gz(this._activeResults, n, i)));
                return this._activeResults
            }

            stop() {
                if (!this._activeResults) {
                    return
                }
                this.stopListening(this.editor.model.document);
                this.state.clear(this.editor.model);
                this._activeResults = null
            }

            _defineCommands() {
                this.editor.commands.add("find", new iz(this.editor, this.state));
                this.editor.commands.add("findNext", new sz(this.editor, this.state));
                this.editor.commands.add("findPrevious", new az(this.editor, this.state));
                this.editor.commands.add("replace", new oz(this.editor, this.state));
                this.editor.commands.add("replaceAll", new rz(this.editor, this.state))
            }

            _defineConverters() {
                const {editor: t} = this;
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: "findResult", view: ({markerName: t}) => {
                        const [, e] = t.split(":");
                        return {name: "span", classes: ["ck-find-result"], attributes: {"data-find-result": e}}
                    }
                });
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: "findResultHighlighted",
                    view: ({markerName: t}) => {
                        const [, e] = t.split(":");
                        return {name: "span", classes: [fz], attributes: {"data-find-result": e}}
                    }
                })
            }
        }

        class pz extends Ac {
            static get requires() {
                return [mz, YR]
            }

            static get pluginName() {
                return "FindAndReplace"
            }

            init() {
                const t = this.editor.plugins.get("FindAndReplaceUI");
                const e = this.editor.plugins.get("FindAndReplaceEditing");
                const n = e.state;
                t.on("findNext", ((t, e) => {
                    if (e) {
                        n.searchText = e.searchText;
                        this.editor.execute("find", e.searchText, e)
                    } else {
                        this.editor.execute("findNext")
                    }
                }));
                t.on("findPrevious", ((t, e) => {
                    if (e && n.searchText !== e.searchText) {
                        this.editor.execute("find", e.searchText)
                    } else {
                        this.editor.execute("findPrevious")
                    }
                }));
                t.on("replace", ((t, e) => {
                    if (n.searchText !== e.searchText) {
                        this.editor.execute("find", e.searchText)
                    }
                    const i = n.highlightedResult;
                    if (i) {
                        this.editor.execute("replace", e.replaceText, i)
                    }
                }));
                t.on("replaceAll", ((t, e) => {
                    if (n.searchText !== e.searchText) {
                        this.editor.execute("find", e.searchText)
                    }
                    this.editor.execute("replaceAll", e.replaceText, n.results)
                }));
                t.on("searchReseted", (() => {
                    n.clear(this.editor.model);
                    e.stop()
                }))
            }
        }

        class bz extends vc {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = e.selection.getAttribute(this.attributeKey);
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.value;
                e.change((t => {
                    if (i.isCollapsed) {
                        if (o) {
                            t.setSelectionAttribute(this.attributeKey, o)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (o) {
                                t.setAttribute(this.attributeKey, o, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }
        }

        class kz extends rc {
            constructor(t) {
                super(t);
                this.set("isEmpty", true);
                this.on("change", (() => {
                    this.set("isEmpty", this.length === 0)
                }))
            }

            add(t, e) {
                if (this.find((e => e.color === t.color))) {
                    return
                }
                super.add(t, e)
            }

            hasColor(t) {
                return !!this.find((e => e.color === t))
            }
        }

        A(kz, dt);
        var wz = n(2585);
        var _z = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        _z.insert = "head";
        _z.singleton = true;
        var Az = Bc()(wz.Z, _z);
        const Cz = wz.Z.locals || {};

        class vz extends pA {
            constructor(t, {
                colors: e,
                columns: n,
                removeButtonLabel: i,
                documentColorsLabel: o,
                documentColorsCount: r
            }) {
                super(t);
                this.items = this.createCollection();
                this.colorDefinitions = e;
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.set("selectedColor");
                this.removeButtonLabel = i;
                this.columns = n;
                this.documentColors = new kz;
                this.documentColorsCount = r;
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this._documentColorsLabel = o;
                this.setTemplate({tag: "div", attributes: {class: ["ck", "ck-color-table"]}, children: this.items});
                this.items.add(this._createRemoveColorButton())
            }

            updateDocumentColors(t, e) {
                const n = t.document;
                const i = this.documentColorsCount;
                this.documentColors.clear();
                for (const o of n.getRootNames()) {
                    const r = n.getRoot(o);
                    const s = t.createRangeIn(r);
                    for (const t of s.getItems()) {
                        if (t.is("$textProxy") && t.hasAttribute(e)) {
                            this._addColorToDocumentColors(t.getAttribute(e));
                            if (this.documentColors.length >= i) {
                                return
                            }
                        }
                    }
                }
            }

            updateSelectedColors() {
                const t = this.documentColorsGrid;
                const e = this.staticColorsGrid;
                const n = this.selectedColor;
                e.selectedColor = n;
                if (t) {
                    t.selectedColor = n
                }
            }

            render() {
                super.render();
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            appendGrids() {
                if (this.staticColorsGrid) {
                    return
                }
                this.staticColorsGrid = this._createStaticColorsGrid();
                this.items.add(this.staticColorsGrid);
                this.focusTracker.add(this.staticColorsGrid.element);
                this._focusables.add(this.staticColorsGrid);
                if (this.documentColorsCount) {
                    const t = N_.bind(this.documentColors, this.documentColors);
                    const e = new cy(this.locale);
                    e.text = this._documentColorsLabel;
                    e.extendTemplate({attributes: {class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")]}});
                    this.items.add(e);
                    this.documentColorsGrid = this._createDocumentColorsGrid();
                    this.items.add(this.documentColorsGrid);
                    this.focusTracker.add(this.documentColorsGrid.element);
                    this._focusables.add(this.documentColorsGrid)
                }
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }

            _createRemoveColorButton() {
                const t = new LC;
                t.set({withText: true, icon: CC.eraser, label: this.removeButtonLabel});
                t.class = "ck-color-table__remove-color";
                t.on("execute", (() => {
                    this.fire("execute", {value: null})
                }));
                t.render();
                this.focusTracker.add(t.element);
                this._focusables.add(t);
                return t
            }

            _createStaticColorsGrid() {
                const t = new QC(this.locale, {colorDefinitions: this.colorDefinitions, columns: this.columns});
                t.delegate("execute").to(this);
                return t
            }

            _createDocumentColorsGrid() {
                const t = N_.bind(this.documentColors, this.documentColors);
                const e = new QC(this.locale, {columns: this.columns});
                e.delegate("execute").to(this);
                e.extendTemplate({attributes: {class: t.if("isEmpty", "ck-hidden")}});
                e.items.bindTo(this.documentColors).using((t => {
                    const e = new GC;
                    e.set({color: t.color, hasBorder: t.options && t.options.hasBorder});
                    if (t.label) {
                        e.set({label: t.label, tooltip: true})
                    }
                    e.on("execute", (() => {
                        this.fire("execute", {value: t.color})
                    }));
                    return e
                }));
                this.documentColors.on("change:isEmpty", ((t, n, i) => {
                    if (i) {
                        e.selectedColor = null
                    }
                }));
                return e
            }

            _addColorToDocumentColors(t) {
                const e = this.colorDefinitions.find((e => e.color === t));
                if (!e) {
                    this.documentColors.add({color: t, label: t, options: {hasBorder: false}})
                } else {
                    this.documentColors.add(Object.assign({}, e))
                }
            }
        }

        const yz = "fontSize";
        const xz = "fontFamily";
        const Ez = "fontColor";
        const Sz = "fontBackgroundColor";

        function Dz(t, e) {
            const n = {model: {key: t, values: []}, view: {}, upcastAlso: {}};
            for (const t of e) {
                n.model.values.push(t.model);
                n.view[t.model] = t.view;
                if (t.upcastAlso) {
                    n.upcastAlso[t.model] = t.upcastAlso
                }
            }
            return n
        }

        function Tz(t) {
            return e => Iz(e.getStyle(t))
        }

        function Bz(t) {
            return (e, {writer: n}) => n.createAttributeElement("span", {style: `${t}:${e}`}, {priority: 7})
        }

        function Pz({
                        dropdownView: t,
                        colors: e,
                        columns: n,
                        removeButtonLabel: i,
                        documentColorsLabel: o,
                        documentColorsCount: r
                    }) {
            const s = t.locale;
            const a = new vz(s, {
                colors: e,
                columns: n,
                removeButtonLabel: i,
                documentColorsLabel: o,
                documentColorsCount: r
            });
            t.colorTableView = a;
            t.panelView.children.add(a);
            a.delegate("execute").to(t, "execute");
            return a
        }

        function Iz(t) {
            return t.replace(/\s/g, "")
        }

        class Rz extends bz {
            constructor(t) {
                super(t, Ez)
            }
        }

        class zz extends Ac {
            static get pluginName() {
                return "FontColorEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(Ez, {
                    colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {color: "hsl(270, 75%, 60%)", label: "Purple"}], columns: 5
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "span", styles: {color: /[\s\S]+/}},
                    model: {key: Ez, value: Tz("color")}
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "font", attributes: {color: /^#?\w+$/}},
                    model: {key: Ez, value: t => t.getAttribute("color")}
                });
                t.conversion.for("downcast").attributeToElement({model: Ez, view: Bz("color")});
                t.commands.add(Ez, new Rz(t));
                t.model.schema.extend("$text", {allowAttributes: Ez});
                t.model.schema.setAttributeProperties(Ez, {isFormatting: true, copyOnEnter: true})
            }
        }

        class Vz extends Ac {
            constructor(t, {commandName: e, icon: n, componentName: i, dropdownLabel: o}) {
                super(t);
                this.commandName = e;
                this.componentName = i;
                this.icon = n;
                this.dropdownLabel = o;
                this.columns = t.config.get(`${this.componentName}.columns`);
                this.colorTableView = undefined
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = e.t;
                const i = t.commands.get(this.commandName);
                const o = jC(t.config.get(this.componentName).colors);
                const r = qC(e, o);
                const s = t.config.get(`${this.componentName}.documentColors`);
                t.ui.componentFactory.add(this.componentName, (e => {
                    const o = qv(e);
                    this.colorTableView = Pz({
                        dropdownView: o,
                        colors: r.map((t => ({label: t.label, color: t.model, options: {hasBorder: t.hasBorder}}))),
                        columns: this.columns,
                        removeButtonLabel: n("Remove color"),
                        documentColorsLabel: s !== 0 ? n("Document colors") : undefined,
                        documentColorsCount: s === undefined ? this.columns : s
                    });
                    this.colorTableView.bind("selectedColor").to(i, "value");
                    o.buttonView.set({label: this.dropdownLabel, icon: this.icon, tooltip: true});
                    o.extendTemplate({attributes: {class: "ck-color-ui-dropdown"}});
                    o.bind("isEnabled").to(i);
                    o.on("execute", ((e, n) => {
                        t.execute(this.commandName, n);
                        t.editing.view.focus()
                    }));
                    o.on("change:isOpen", ((e, n, i) => {
                        o.colorTableView.appendGrids();
                        if (i) {
                            if (s !== 0) {
                                this.colorTableView.updateDocumentColors(t.model, this.componentName)
                            }
                            this.colorTableView.updateSelectedColors()
                        }
                    }));
                    Uv(o, (() => o.colorTableView.staticColorsGrid.items.find((t => t.isOn))));
                    return o
                }))
            }
        }

        const Fz = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';

        class Lz extends Vz {
            constructor(t) {
                const e = t.locale.t;
                super(t, {commandName: Ez, componentName: Ez, icon: Fz, dropdownLabel: e("Font Color")})
            }

            static get pluginName() {
                return "FontColorUI"
            }
        }

        class Oz extends Ac {
            static get requires() {
                return [zz, Lz]
            }

            static get pluginName() {
                return "FontColor"
            }
        }

        class Nz extends bz {
            constructor(t) {
                super(t, xz)
            }
        }

        function Mz(t) {
            return t.map(Hz).filter((t => !!t))
        }

        function Hz(t) {
            if (typeof t === "object") {
                return t
            }
            if (t === "default") {
                return {title: "Default", model: undefined}
            }
            if (typeof t !== "string") {
                return
            }
            return Wz(t)
        }

        function Wz(t) {
            const e = t.replace(/"|'/g, "").split(",");
            const n = e[0];
            const i = e.map(qz).join(", ");
            return {title: n, model: i, view: {name: "span", styles: {"font-family": i}, priority: 7}}
        }

        function qz(t) {
            t = t.trim();
            if (t.indexOf(" ") > 0) {
                t = `'${t}'`
            }
            return t
        }

        class jz extends Ac {
            static get pluginName() {
                return "FontFamilyEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(xz, {
                    options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"],
                    supportAllValues: false
                })
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: xz});
                t.model.schema.setAttributeProperties(xz, {isFormatting: true, copyOnEnter: true});
                const e = Mz(t.config.get("fontFamily.options")).filter((t => t.model));
                const n = Dz(xz, e);
                if (t.config.get("fontFamily.supportAllValues")) {
                    this._prepareAnyValueConverters();
                    this._prepareCompatibilityConverter()
                } else {
                    t.conversion.attributeToElement(n)
                }
                t.commands.add(xz, new Nz(t))
            }

            _prepareAnyValueConverters() {
                const t = this.editor;
                t.conversion.for("downcast").attributeToElement({
                    model: xz,
                    view: (t, {writer: e}) => e.createAttributeElement("span", {style: "font-family:" + t}, {priority: 7})
                });
                t.conversion.for("upcast").elementToAttribute({
                    model: {key: xz, value: t => t.getStyle("font-family")},
                    view: {name: "span", styles: {"font-family": /.*/}}
                })
            }

            _prepareCompatibilityConverter() {
                const t = this.editor;
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "font", attributes: {face: /.*/}},
                    model: {key: xz, value: t => t.getAttribute("face")}
                })
            }
        }

        const $z = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';

        class Uz extends Ac {
            static get pluginName() {
                return "FontFamilyUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = this._getLocalizedOptions();
                const i = t.commands.get(xz);
                t.ui.componentFactory.add(xz, (o => {
                    const r = qv(o);
                    $v(r, Gz(n, i));
                    r.buttonView.set({label: e("Font Family"), icon: $z, tooltip: true});
                    r.extendTemplate({attributes: {class: "ck-font-family-dropdown"}});
                    r.bind("isEnabled").to(i);
                    this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {value: e.source.commandParam});
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }

            _getLocalizedOptions() {
                const t = this.editor;
                const e = t.t;
                const n = Mz(t.config.get(xz).options);
                return n.map((t => {
                    if (t.title === "Default") {
                        t.title = e("Default")
                    }
                    return t
                }))
            }
        }

        function Gz(t, e) {
            const n = new rc;
            for (const i of t) {
                const t = {
                    type: "button",
                    model: new Fy({commandName: xz, commandParam: i.model, label: i.title, withText: true})
                };
                t.model.bind("isOn").to(e, "value", (t => {
                    if (t === i.model) {
                        return true
                    }
                    if (!t || !i.model) {
                        return false
                    }
                    return t.split(",")[0].replace(/'/g, "").toLowerCase() === i.model.toLowerCase()
                }));
                if (i.view && i.view.styles) {
                    t.model.set("labelStyle", `font-family: ${i.view.styles["font-family"]}`)
                }
                n.add(t)
            }
            return n
        }

        class Kz extends Ac {
            static get requires() {
                return [jz, Uz]
            }

            static get pluginName() {
                return "FontFamily"
            }
        }

        class Zz extends bz {
            constructor(t) {
                super(t, yz)
            }
        }

        function Jz(t) {
            return t.map((t => Qz(t))).filter((t => !!t))
        }

        const Yz = {
            get tiny() {
                return {title: "Tiny", model: "tiny", view: {name: "span", classes: "text-tiny", priority: 7}}
            }, get small() {
                return {title: "Small", model: "small", view: {name: "span", classes: "text-small", priority: 7}}
            }, get big() {
                return {title: "Big", model: "big", view: {name: "span", classes: "text-big", priority: 7}}
            }, get huge() {
                return {title: "Huge", model: "huge", view: {name: "span", classes: "text-huge", priority: 7}}
            }
        };

        function Qz(t) {
            if (nV(t)) {
                return tV(t)
            }
            const e = eV(t);
            if (e) {
                return tV(e)
            }
            if (t === "default") {
                return {model: undefined, title: "Default"}
            }
            if (iV(t)) {
                return
            }
            return Xz(t)
        }

        function Xz(t) {
            if (typeof t === "number" || typeof t === "string") {
                t = {title: String(t), model: `${parseFloat(t)}px`}
            }
            t.view = {name: "span", styles: {"font-size": t.model}};
            return tV(t)
        }

        function tV(t) {
            if (!t.view.priority) {
                t.view.priority = 7
            }
            return t
        }

        function eV(t) {
            return Yz[t] || Yz[t.model]
        }

        function nV(t) {
            return typeof t === "object" && t.title && t.model && t.view
        }

        function iV(t) {
            let e;
            if (typeof t === "object") {
                if (!t.model) {
                    throw new P("font-size-invalid-definition", null, t)
                } else {
                    e = parseFloat(t.model)
                }
            } else {
                e = parseFloat(t)
            }
            return isNaN(e)
        }

        const oV = ["x-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"];

        class rV extends Ac {
            static get pluginName() {
                return "FontSizeEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(yz, {options: ["tiny", "small", "default", "big", "huge"], supportAllValues: false})
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: yz});
                t.model.schema.setAttributeProperties(yz, {isFormatting: true, copyOnEnter: true});
                const e = t.config.get("fontSize.supportAllValues");
                const n = Jz(this.editor.config.get("fontSize.options")).filter((t => t.model));
                const i = Dz(yz, n);
                if (e) {
                    this._prepareAnyValueConverters(i);
                    this._prepareCompatibilityConverter()
                } else {
                    t.conversion.attributeToElement(i)
                }
                t.commands.add(yz, new Zz(t))
            }

            _prepareAnyValueConverters(t) {
                const e = this.editor;
                const n = t.model.values.filter((t => !Yw(String(t)) && !Xw(String(t))));
                if (n.length) {
                    throw new P("font-size-invalid-use-of-named-presets", null, {presets: n})
                }
                e.conversion.for("downcast").attributeToElement({
                    model: yz, view: (t, {writer: e}) => {
                        if (!t) {
                            return
                        }
                        return e.createAttributeElement("span", {style: "font-size:" + t}, {priority: 7})
                    }
                });
                e.conversion.for("upcast").elementToAttribute({
                    model: {key: yz, value: t => t.getStyle("font-size")},
                    view: {name: "span", styles: {"font-size": /.*/}}
                })
            }

            _prepareCompatibilityConverter() {
                const t = this.editor;
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "font",
                        attributes: {size: /^[+-]?\d{1,3}$/}
                    }, model: {
                        key: yz, value: t => {
                            const e = t.getAttribute("size");
                            const n = e[0] === "-" || e[0] === "+";
                            let i = parseInt(e, 10);
                            if (n) {
                                i = 3 + i
                            }
                            const o = oV.length - 1;
                            const r = Math.min(Math.max(i, 0), o);
                            return oV[r]
                        }
                    }
                })
            }
        }

        const sV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
        var aV = n(6203);
        var lV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        lV.insert = "head";
        lV.singleton = true;
        var cV = Bc()(aV.Z, lV);
        const dV = aV.Z.locals || {};

        class uV extends Ac {
            static get pluginName() {
                return "FontSizeUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = this._getLocalizedOptions();
                const i = t.commands.get(yz);
                t.ui.componentFactory.add(yz, (o => {
                    const r = qv(o);
                    $v(r, hV(n, i));
                    r.buttonView.set({label: e("Font Size"), icon: sV, tooltip: true});
                    r.extendTemplate({attributes: {class: ["ck-font-size-dropdown"]}});
                    r.bind("isEnabled").to(i);
                    this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {value: e.source.commandParam});
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }

            _getLocalizedOptions() {
                const t = this.editor;
                const e = t.t;
                const n = {Default: e("Default"), Tiny: e("Tiny"), Small: e("Small"), Big: e("Big"), Huge: e("Huge")};
                const i = Jz(t.config.get(yz).options);
                return i.map((t => {
                    const e = n[t.title];
                    if (e && e != t.title) {
                        t = Object.assign({}, t, {title: e})
                    }
                    return t
                }))
            }
        }

        function hV(t, e) {
            const n = new rc;
            for (const i of t) {
                const t = {
                    type: "button",
                    model: new Fy({
                        commandName: yz,
                        commandParam: i.model,
                        label: i.title,
                        class: "ck-fontsize-option",
                        withText: true
                    })
                };
                if (i.view && i.view.styles) {
                    t.model.set("labelStyle", `font-size:${i.view.styles["font-size"]}`)
                }
                if (i.view && i.view.classes) {
                    t.model.set("class", `${t.model.class} ${i.view.classes}`)
                }
                t.model.bind("isOn").to(e, "value", (t => t === i.model));
                n.add(t)
            }
            return n
        }

        class fV extends Ac {
            static get requires() {
                return [rV, uV]
            }

            static get pluginName() {
                return "FontSize"
            }

            normalizeSizeOptions(t) {
                return Jz(t)
            }
        }

        class gV extends vc {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = sc(e.selection.getSelectedBlocks());
                this.value = !!n && n.is("element", "paragraph");
                this.isEnabled = !!n && mV(n, t.schema)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.change((i => {
                    const o = (t.selection || n.selection).getSelectedBlocks();
                    for (const t of o) {
                        if (!t.is("element", "paragraph") && mV(t, e.schema)) {
                            i.rename(t, "paragraph")
                        }
                    }
                }))
            }
        }

        function mV(t, e) {
            return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
        }

        class pV extends vc {
            execute(t) {
                const e = this.editor.model;
                const n = t.attributes;
                let i = t.position;
                e.change((t => {
                    const o = t.createElement("paragraph");
                    if (n) {
                        e.schema.setAllowedAttributes(o, n, t)
                    }
                    if (!e.schema.checkChild(i.parent, o)) {
                        const n = e.schema.findAllowedParent(i, o);
                        if (!n) {
                            return
                        }
                        i = t.split(i, n).position
                    }
                    e.insertContent(o, i);
                    t.setSelection(o, "in")
                }))
            }
        }

        class bV extends Ac {
            static get pluginName() {
                return "Paragraph"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                t.commands.add("paragraph", new gV(t));
                t.commands.add("insertParagraph", new pV(t));
                e.schema.register("paragraph", {inheritAllFrom: "$block"});
                t.conversion.elementToElement({model: "paragraph", view: "p"});
                t.conversion.for("upcast").elementToElement({
                    model: (t, {writer: e}) => {
                        if (!bV.paragraphLikeElements.has(t.name)) {
                            return null
                        }
                        if (t.isEmpty) {
                            return null
                        }
                        return e.createElement("paragraph")
                    }, view: /.+/, converterPriority: "low"
                })
            }
        }

        bV.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
        const kV = CC.paragraph;

        class wV extends (null && Plugin) {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("paragraph", (n => {
                    const i = new ButtonView(n);
                    const o = t.commands.get("paragraph");
                    i.label = e("Paragraph");
                    i.icon = kV;
                    i.tooltip = true;
                    i.isToggleable = true;
                    i.bind("isEnabled").to(o);
                    i.bind("isOn").to(o, "value");
                    i.on("execute", (() => {
                        t.execute("paragraph")
                    }));
                    return i
                }))
            }
        }

        class _V extends vc {
            constructor(t, e) {
                super(t);
                this.modelElements = e
            }

            refresh() {
                const t = sc(this.editor.model.document.selection.getSelectedBlocks());
                this.value = !!t && this.modelElements.includes(t.name) && t.name;
                this.isEnabled = !!t && this.modelElements.some((e => AV(t, e, this.editor.model.schema)))
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = t.value;
                e.change((t => {
                    const o = Array.from(n.selection.getSelectedBlocks()).filter((t => AV(t, i, e.schema)));
                    for (const e of o) {
                        if (!e.is("element", i)) {
                            t.rename(e, i)
                        }
                    }
                }))
            }
        }

        function AV(t, e, n) {
            return n.checkChild(t.parent, e) && !n.isObject(t)
        }

        const CV = "paragraph";

        class vV extends Ac {
            static get pluginName() {
                return "HeadingEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("heading", {
                    options: [{
                        model: "paragraph",
                        title: "Paragraph",
                        class: "ck-heading_paragraph"
                    }, {
                        model: "heading1",
                        view: "h2",
                        title: "Heading 1",
                        class: "ck-heading_heading1"
                    }, {
                        model: "heading2",
                        view: "h3",
                        title: "Heading 2",
                        class: "ck-heading_heading2"
                    }, {model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3"}]
                })
            }

            static get requires() {
                return [bV]
            }

            init() {
                const t = this.editor;
                const e = t.config.get("heading.options");
                const n = [];
                for (const i of e) {
                    if (i.model !== CV) {
                        t.model.schema.register(i.model, {inheritAllFrom: "$block"});
                        t.conversion.elementToElement(i);
                        n.push(i.model)
                    }
                }
                this._addDefaultH1Conversion(t);
                t.commands.add("heading", new _V(t, n))
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands.get("enter");
                const n = t.config.get("heading.options");
                if (e) {
                    this.listenTo(e, "afterExecute", ((e, i) => {
                        const o = t.model.document.selection.getFirstPosition().parent;
                        const r = n.some((t => o.is("element", t.model)));
                        if (r && !o.is("element", CV) && o.childCount === 0) {
                            i.writer.rename(o, CV)
                        }
                    }))
                }
            }

            _addDefaultH1Conversion(t) {
                t.conversion.for("upcast").elementToElement({
                    model: "heading1",
                    view: "h1",
                    converterPriority: D.get("low") + 1
                })
            }
        }

        function yV(t) {
            const e = t.t;
            const n = {
                Paragraph: e("Paragraph"),
                "Heading 1": e("Heading 1"),
                "Heading 2": e("Heading 2"),
                "Heading 3": e("Heading 3"),
                "Heading 4": e("Heading 4"),
                "Heading 5": e("Heading 5"),
                "Heading 6": e("Heading 6")
            };
            return t.config.get("heading.options").map((t => {
                const e = n[t.title];
                if (e && e != t.title) {
                    t.title = e
                }
                return t
            }))
        }

        var xV = n(3230);
        var EV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        EV.insert = "head";
        EV.singleton = true;
        var SV = Bc()(xV.Z, EV);
        const DV = xV.Z.locals || {};

        class TV extends Ac {
            static get pluginName() {
                return "HeadingUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = yV(t);
                const i = e("Choose heading");
                const o = e("Heading");
                t.ui.componentFactory.add("heading", (e => {
                    const r = {};
                    const s = new rc;
                    const a = t.commands.get("heading");
                    const l = t.commands.get("paragraph");
                    const c = [a];
                    for (const t of n) {
                        const e = {type: "button", model: new Fy({label: t.title, class: t.class, withText: true})};
                        if (t.model === "paragraph") {
                            e.model.bind("isOn").to(l, "value");
                            e.model.set("commandName", "paragraph");
                            c.push(l)
                        } else {
                            e.model.bind("isOn").to(a, "value", (e => e === t.model));
                            e.model.set({commandName: "heading", commandValue: t.model})
                        }
                        s.add(e);
                        r[t.model] = t.title
                    }
                    const d = qv(e);
                    $v(d, s);
                    d.buttonView.set({isOn: false, withText: true, tooltip: o});
                    d.extendTemplate({attributes: {class: ["ck-heading-dropdown"]}});
                    d.bind("isEnabled").toMany(c, "isEnabled", ((...t) => t.some((t => t))));
                    d.buttonView.bind("label").to(a, "value", l, "value", ((t, e) => {
                        const n = t || e && "paragraph";
                        return r[n] ? r[n] : i
                    }));
                    this.listenTo(d, "execute", (e => {
                        t.execute(e.source.commandName, e.source.commandValue ? {value: e.source.commandValue} : undefined);
                        t.editing.view.focus()
                    }));
                    return d
                }))
            }
        }

        class BV extends Ac {
            static get requires() {
                return [vV, TV]
            }

            static get pluginName() {
                return "Heading"
            }
        }

        class PV extends vc {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = e.selection.getAttribute("highlight");
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "highlight")
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.value;
                e.change((t => {
                    if (i.isCollapsed) {
                        const e = i.getFirstPosition();
                        if (i.hasAttribute("highlight")) {
                            const n = t => t.item.hasAttribute("highlight") && t.item.getAttribute("highlight") === this.value;
                            const i = e.getLastMatchingPosition(n, {direction: "backward"});
                            const r = e.getLastMatchingPosition(n);
                            const s = t.createRange(i, r);
                            if (!o || this.value === o) {
                                if (!e.isEqual(r)) {
                                    t.removeAttribute("highlight", s)
                                }
                                t.removeSelectionAttribute("highlight")
                            } else {
                                if (!e.isEqual(r)) {
                                    t.setAttribute("highlight", o, s)
                                }
                                t.setSelectionAttribute("highlight", o)
                            }
                        } else if (o) {
                            t.setSelectionAttribute("highlight", o)
                        }
                    } else {
                        const n = e.schema.getValidRanges(i.getRanges(), "highlight");
                        for (const e of n) {
                            if (o) {
                                t.setAttribute("highlight", o, e)
                            } else {
                                t.removeAttribute("highlight", e)
                            }
                        }
                    }
                }))
            }
        }

        class IV extends Ac {
            static get pluginName() {
                return "HighlightEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("highlight", {
                    options: [{
                        model: "yellowMarker",
                        class: "marker-yellow",
                        title: "Yellow marker",
                        color: "var(--ck-highlight-marker-yellow)",
                        type: "marker"
                    }, {
                        model: "greenMarker",
                        class: "marker-green",
                        title: "Green marker",
                        color: "var(--ck-highlight-marker-green)",
                        type: "marker"
                    }, {
                        model: "pinkMarker",
                        class: "marker-pink",
                        title: "Pink marker",
                        color: "var(--ck-highlight-marker-pink)",
                        type: "marker"
                    }, {
                        model: "blueMarker",
                        class: "marker-blue",
                        title: "Blue marker",
                        color: "var(--ck-highlight-marker-blue)",
                        type: "marker"
                    }, {
                        model: "redPen",
                        class: "pen-red",
                        title: "Red pen",
                        color: "var(--ck-highlight-pen-red)",
                        type: "pen"
                    }, {
                        model: "greenPen",
                        class: "pen-green",
                        title: "Green pen",
                        color: "var(--ck-highlight-pen-green)",
                        type: "pen"
                    }]
                })
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: "highlight"});
                const e = t.config.get("highlight.options");
                t.conversion.attributeToElement(RV(e));
                t.commands.add("highlight", new PV(t))
            }
        }

        function RV(t) {
            const e = {model: {key: "highlight", values: []}, view: {}};
            for (const n of t) {
                e.model.values.push(n.model);
                e.view[n.model] = {name: "mark", classes: n.class}
            }
            return e
        }

        const zV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
        const VV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
        var FV = n(713);
        var LV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        LV.insert = "head";
        LV.singleton = true;
        var OV = Bc()(FV.Z, LV);
        const NV = FV.Z.locals || {};

        class MV extends Ac {
            get localizedOptionTitles() {
                const t = this.editor.t;
                return {
                    "Yellow marker": t("Yellow marker"),
                    "Green marker": t("Green marker"),
                    "Pink marker": t("Pink marker"),
                    "Blue marker": t("Blue marker"),
                    "Red pen": t("Red pen"),
                    "Green pen": t("Green pen")
                }
            }

            static get pluginName() {
                return "HighlightUI"
            }

            init() {
                const t = this.editor.config.get("highlight.options");
                for (const e of t) {
                    this._addHighlighterButton(e)
                }
                this._addRemoveHighlightButton();
                this._addDropdown(t)
            }

            _addRemoveHighlightButton() {
                const t = this.editor.t;
                const e = this.editor.commands.get("highlight");
                this._addButton("removeHighlight", t("Remove highlight"), CC.eraser, null, (t => {
                    t.bind("isEnabled").to(e, "isEnabled")
                }))
            }

            _addHighlighterButton(t) {
                const e = this.editor.commands.get("highlight");
                this._addButton("highlight:" + t.model, t.title, WV(t.type), t.model, n);

                function n(n) {
                    n.bind("isEnabled").to(e, "isEnabled");
                    n.bind("isOn").to(e, "value", (e => e === t.model));
                    n.iconView.fillColor = t.color;
                    n.isToggleable = true
                }
            }

            _addButton(t, e, n, i, o) {
                const r = this.editor;
                r.ui.componentFactory.add(t, (t => {
                    const s = new LC(t);
                    const a = this.localizedOptionTitles[e] ? this.localizedOptionTitles[e] : e;
                    s.set({label: a, icon: n, tooltip: true});
                    s.on("execute", (() => {
                        r.execute("highlight", {value: i});
                        r.editing.view.focus()
                    }));
                    o(s);
                    return s
                }))
            }

            _addDropdown(t) {
                const e = this.editor;
                const n = e.t;
                const i = e.ui.componentFactory;
                const o = t[0];
                const r = t.reduce(((t, e) => {
                    t[e.model] = e;
                    return t
                }), {});
                i.add("highlight", (s => {
                    const a = e.commands.get("highlight");
                    const l = qv(s, rv);
                    const c = l.buttonView;
                    c.set({
                        label: n("Highlight"),
                        tooltip: true,
                        lastExecuted: o.model,
                        commandValue: o.model,
                        isToggleable: true
                    });
                    c.bind("icon").to(a, "value", (t => WV(u(t, "type"))));
                    c.bind("color").to(a, "value", (t => u(t, "color")));
                    c.bind("commandValue").to(a, "value", (t => u(t, "model")));
                    c.bind("isOn").to(a, "value", (t => !!t));
                    c.delegate("execute").to(l);
                    const d = t.map((t => {
                        const e = i.create("highlight:" + t.model);
                        this.listenTo(e, "execute", (() => {
                            l.buttonView.set({lastExecuted: t.model})
                        }));
                        return e
                    }));
                    l.bind("isEnabled").toMany(d, "isEnabled", ((...t) => t.some((t => t))));
                    d.push(new gv);
                    d.push(i.create("removeHighlight"));
                    jv(l, d, {enableActiveItemFocusOnDropdownOpen: true});
                    HV(l);
                    l.toolbarView.ariaLabel = n("Text highlight toolbar");
                    c.on("execute", (() => {
                        e.execute("highlight", {value: c.commandValue})
                    }));
                    this.listenTo(l, "execute", (() => {
                        e.editing.view.focus()
                    }));

                    function u(t, e) {
                        const n = !t || t === c.lastExecuted ? c.lastExecuted : t;
                        return r[n][e]
                    }

                    return l
                }))
            }
        }

        function HV(t) {
            const e = t.buttonView.actionView;
            e.iconView.bind("fillColor").to(t.buttonView, "color")
        }

        function WV(t) {
            return t === "marker" ? zV : VV
        }

        class qV extends Ac {
            static get requires() {
                return [IV, MV]
            }

            static get pluginName() {
                return "Highlight"
            }
        }

        class jV extends vc {
            refresh() {
                const t = this.editor.model;
                const e = t.schema;
                const n = t.document.selection;
                this.isEnabled = $V(n, e, t)
            }

            execute() {
                const t = this.editor.model;
                t.change((e => {
                    const n = e.createElement("horizontalLine");
                    t.insertObject(n, null, null, {setSelection: "after"})
                }))
            }
        }

        function $V(t, e, n) {
            const i = UV(t, n);
            return e.checkChild(i, "horizontalLine")
        }

        function UV(t, e) {
            const n = eI(t, e);
            const i = n.start.parent;
            if (i.isEmpty && !i.is("element", "$root")) {
                return i.parent
            }
            return i
        }

        var GV = n(2536);
        var KV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        KV.insert = "head";
        KV.singleton = true;
        var ZV = Bc()(GV.Z, KV);
        const JV = GV.Z.locals || {};

        class YV extends Ac {
            static get pluginName() {
                return "HorizontalLineEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const i = t.conversion;
                e.register("horizontalLine", {inheritAllFrom: "$blockObject"});
                i.for("dataDowncast").elementToElement({
                    model: "horizontalLine",
                    view: (t, {writer: e}) => e.createEmptyElement("hr")
                });
                i.for("editingDowncast").elementToStructure({
                    model: "horizontalLine", view: (t, {writer: e}) => {
                        const i = n("Horizontal line");
                        const o = e.createContainerElement("div", null, e.createEmptyElement("hr"));
                        e.addClass("ck-horizontal-line", o);
                        e.setCustomProperty("hr", true, o);
                        return QV(o, e, i)
                    }
                });
                i.for("upcast").elementToElement({view: "hr", model: "horizontalLine"});
                t.commands.add("horizontalLine", new jV(t))
            }
        }

        function QV(t, e, n) {
            e.setCustomProperty("horizontalLine", true, t);
            return KP(t, e, {label: n})
        }

        const XV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';

        class tF extends Ac {
            static get pluginName() {
                return "HorizontalLineUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("horizontalLine", (n => {
                    const i = t.commands.get("horizontalLine");
                    const o = new LC(n);
                    o.set({label: e("Horizontal line"), icon: XV, tooltip: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("horizontalLine");
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class eF extends Ac {
            static get requires() {
                return [YV, tF, zI]
            }

            static get pluginName() {
                return "HorizontalLine"
            }
        }

        class nF extends vc {
            refresh() {
                const t = this.editor;
                const e = t.plugins.get("ImageUtils");
                const n = e.getClosestSelectedImageElement(this.editor.model.document.selection);
                this.isEnabled = !!n;
                if (this.isEnabled && n.hasAttribute("alt")) {
                    this.value = n.getAttribute("alt")
                } else {
                    this.value = false
                }
            }

            execute(t) {
                const e = this.editor;
                const n = e.plugins.get("ImageUtils");
                const i = e.model;
                const o = n.getClosestSelectedImageElement(i.document.selection);
                i.change((e => {
                    e.setAttribute("alt", t.newValue, o)
                }))
            }
        }

        function iF(t) {
            return t.createContainerElement("span", {class: "image-inline"}, t.createEmptyElement("img"))
        }

        function oF(t) {
            return t.createContainerElement("figure", {class: "image"}, [t.createEmptyElement("img"), t.createSlot()])
        }

        function rF(t, e) {
            const n = t.plugins.get("ImageUtils");
            const i = t.plugins.has("ImageInlineEditing") && t.plugins.has("ImageBlockEditing");
            return t => {
                if (!n.isInlineImageView(t)) {
                    return null
                }
                if (!i) {
                    return o(t)
                }
                const r = t.getStyle("display") == "block" || t.findAncestor(n.isBlockImageView) ? "imageBlock" : "imageInline";
                if (r !== e) {
                    return null
                }
                return o(t)
            };

            function o(t) {
                const e = {name: true};
                if (t.hasAttribute("src")) {
                    e.attributes = ["src"]
                }
                return e
            }
        }

        function sF(t, e) {
            const n = sc(e.getSelectedBlocks());
            if (!n || t.isObject(n)) {
                return "imageBlock"
            }
            if (n.isEmpty && n.name != "listItem") {
                return "imageBlock"
            }
            return "imageInline"
        }

        class aF extends Ac {
            static get pluginName() {
                return "ImageUtils"
            }

            isImage(t) {
                return this.isInlineImage(t) || this.isBlockImage(t)
            }

            isInlineImageView(t) {
                return !!t && t.is("element", "img")
            }

            isBlockImageView(t) {
                return !!t && t.is("element", "figure") && t.hasClass("image")
            }

            insertImage(t = {}, e = null, n = null) {
                const i = this.editor;
                const o = i.model;
                const r = o.document.selection;
                n = uF(i, e || r, n);
                t = {...Object.fromEntries(r.getAttributes()), ...t};
                for (const e in t) {
                    if (!o.schema.checkAttribute(n, e)) {
                        delete t[e]
                    }
                }
                return o.change((i => {
                    const r = i.createElement(n, t);
                    o.insertObject(r, e, null, {setSelection: "on", findOptimalPosition: !e && n != "imageInline"});
                    if (r.parent) {
                        return r
                    }
                    return null
                }))
            }

            getClosestSelectedImageWidget(t) {
                const e = t.getFirstPosition();
                if (!e) {
                    return null
                }
                const n = t.getSelectedElement();
                if (n && this.isImageWidget(n)) {
                    return n
                }
                let i = e.parent;
                while (i) {
                    if (i.is("element") && this.isImageWidget(i)) {
                        return i
                    }
                    i = i.parent
                }
                return null
            }

            getClosestSelectedImageElement(t) {
                const e = t.getSelectedElement();
                return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock")
            }

            isImageAllowed() {
                const t = this.editor.model;
                const e = t.document.selection;
                return lF(this.editor, e) && cF(e)
            }

            toImageWidget(t, e, n) {
                e.setCustomProperty("image", true, t);
                const i = () => {
                    const e = this.findViewImgElement(t);
                    const i = e.getAttribute("alt");
                    return i ? `${i} ${n}` : n
                };
                return KP(t, e, {label: i})
            }

            isImageWidget(t) {
                return !!t.getCustomProperty("image") && GP(t)
            }

            isBlockImage(t) {
                return !!t && t.is("element", "imageBlock")
            }

            isInlineImage(t) {
                return !!t && t.is("element", "imageInline")
            }

            findViewImgElement(t) {
                if (this.isInlineImageView(t)) {
                    return t
                }
                const e = this.editor.editing.view;
                for (const {item: n} of e.createRangeIn(t)) {
                    if (this.isInlineImageView(n)) {
                        return n
                    }
                }
            }
        }

        function lF(t, e) {
            const n = uF(t, e);
            if (n == "imageBlock") {
                const n = dF(e, t.model);
                if (t.model.schema.checkChild(n, "imageBlock")) {
                    return true
                }
            } else if (t.model.schema.checkChild(e.focus, "imageInline")) {
                return true
            }
            return false
        }

        function cF(t) {
            return [...t.focus.getAncestors()].every((t => !t.is("element", "imageBlock")))
        }

        function dF(t, e) {
            const n = eI(t, e);
            const i = n.start.parent;
            if (i.isEmpty && !i.is("element", "$root")) {
                return i.parent
            }
            return i
        }

        function uF(t, e, n) {
            const i = t.model.schema;
            const o = t.config.get("image.insert.type");
            if (!t.plugins.has("ImageBlockEditing")) {
                return "imageInline"
            }
            if (!t.plugins.has("ImageInlineEditing")) {
                return "imageBlock"
            }
            if (n) {
                return n
            }
            if (o === "inline") {
                return "imageInline"
            }
            if (o === "block") {
                return "imageBlock"
            }
            if (e.is("selection")) {
                return sF(i, e)
            }
            return i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock"
        }

        class hF extends Ac {
            static get requires() {
                return [aF]
            }

            static get pluginName() {
                return "ImageTextAlternativeEditing"
            }

            init() {
                this.editor.commands.add("imageTextAlternative", new nF(this.editor))
            }
        }

        var fF = n(6831);
        var gF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        gF.insert = "head";
        gF.singleton = true;
        var mF = Bc()(fF.Z, gF);
        const pF = fF.Z.locals || {};

        class bF extends pA {
            constructor(t) {
                super(t);
                const e = this.locale.t;
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.labeledInput = this._createLabeledInputView();
                this.saveButtonView = this._createButton(e("Save"), CC.check, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(e("Cancel"), CC.cancel, "ck-button-cancel", "cancel");
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1"},
                    children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                });
                yC(this)
            }

            render() {
                super.render();
                this.keystrokes.listenTo(this.element);
                xC({view: this});
                [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }))
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            _createButton(t, e, n, i) {
                const o = new LC(this.locale);
                o.set({label: t, icon: e, tooltip: true});
                o.extendTemplate({attributes: {class: n}});
                if (i) {
                    o.delegate("execute").to(this, i)
                }
                return o
            }

            _createLabeledInputView() {
                const t = this.locale.t;
                const e = new Py(this.locale, Iy);
                e.label = t("Text alternative");
                return e
            }
        }

        function kF(t) {
            const e = t.plugins.get("ContextualBalloon");
            if (t.plugins.get("ImageUtils").getClosestSelectedImageWidget(t.editing.view.document.selection)) {
                const n = wF(t);
                e.updatePosition(n)
            }
        }

        function wF(t) {
            const e = t.editing.view;
            const n = vA.defaultPositions;
            const i = t.plugins.get("ImageUtils");
            return {
                target: e.domConverter.mapViewToDom(i.getClosestSelectedImageWidget(e.document.selection)),
                positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth]
            }
        }

        class _F extends Ac {
            static get requires() {
                return [Ky]
            }

            static get pluginName() {
                return "ImageTextAlternativeUI"
            }

            init() {
                this._createButton();
                this._createForm()
            }

            destroy() {
                super.destroy();
                this._form.destroy()
            }

            _createButton() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("imageTextAlternative", (n => {
                    const i = t.commands.get("imageTextAlternative");
                    const o = new LC(n);
                    o.set({label: e("Change image text alternative"), icon: CC.lowVision, tooltip: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    o.bind("isOn").to(i, "value", (t => !!t));
                    this.listenTo(o, "execute", (() => {
                        this._showForm()
                    }));
                    return o
                }))
            }

            _createForm() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                const i = t.plugins.get("ImageUtils");
                this._balloon = this.editor.plugins.get("ContextualBalloon");
                this._form = new bF(t.locale);
                this._form.render();
                this.listenTo(this._form, "submit", (() => {
                    t.execute("imageTextAlternative", {newValue: this._form.labeledInput.fieldView.element.value});
                    this._hideForm(true)
                }));
                this.listenTo(this._form, "cancel", (() => {
                    this._hideForm(true)
                }));
                this._form.keystrokes.set("Esc", ((t, e) => {
                    this._hideForm(true);
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!i.getClosestSelectedImageWidget(n.selection)) {
                        this._hideForm(true)
                    } else if (this._isVisible) {
                        kF(t)
                    }
                }));
                vC({
                    emitter: this._form,
                    activator: () => this._isVisible,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideForm()
                })
            }

            _showForm() {
                if (this._isVisible) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("imageTextAlternative");
                const n = this._form.labeledInput;
                this._form.disableCssTransitions();
                if (!this._isInBalloon) {
                    this._balloon.add({view: this._form, position: wF(t)})
                }
                n.fieldView.value = n.fieldView.element.value = e.value || "";
                this._form.labeledInput.fieldView.select();
                this._form.enableCssTransitions()
            }

            _hideForm(t) {
                if (!this._isInBalloon) {
                    return
                }
                if (this._form.focusTracker.isFocused) {
                    this._form.saveButtonView.focus()
                }
                this._balloon.remove(this._form);
                if (t) {
                    this.editor.editing.view.focus()
                }
            }

            get _isVisible() {
                return this._balloon.visibleView === this._form
            }

            get _isInBalloon() {
                return this._balloon.hasView(this._form)
            }
        }

        class AF extends Ac {
            static get requires() {
                return [hF, _F]
            }

            static get pluginName() {
                return "ImageTextAlternative"
            }
        }

        function CF(t) {
            return t => {
                t.on("element:figure", e)
            };

            function e(e, n, i) {
                if (!i.consumable.test(n.viewItem, {name: true, classes: "image"})) {
                    return
                }
                const o = t.findViewImgElement(n.viewItem);
                if (!o || !i.consumable.test(o, {name: true})) {
                    return
                }
                i.consumable.consume(n.viewItem, {name: true, classes: "image"});
                const r = i.convertItem(o, n.modelCursor);
                const s = sc(r.modelRange.getItems());
                if (!s) {
                    i.consumable.revert(n.viewItem, {name: true, classes: "image"});
                    return
                }
                i.convertChildren(n.viewItem, s);
                i.updateConversionResult(s, n)
            }
        }

        function vF(t) {
            const e = ["srcset", "media", "type", "sizes"];
            return t => {
                t.on("element:picture", n)
            };

            function n(n, i, o) {
                const r = i.viewItem;
                if (!o.consumable.test(r, {name: true})) {
                    return
                }
                const s = new Map;
                for (const t of r.getChildren()) {
                    if (t.is("element", "source")) {
                        const n = {};
                        for (const i of e) {
                            if (t.hasAttribute(i)) {
                                if (o.consumable.test(t, {attributes: i})) {
                                    n[i] = t.getAttribute(i)
                                }
                            }
                        }
                        if (Object.keys(n).length) {
                            s.set(t, n)
                        }
                    }
                }
                const a = t.findViewImgElement(r);
                if (!a) {
                    return
                }
                let l = i.modelCursor.parent;
                if (!l.is("element", "imageBlock")) {
                    const t = o.convertItem(a, i.modelCursor);
                    i.modelRange = t.modelRange;
                    i.modelCursor = t.modelCursor;
                    l = first(t.modelRange.getItems())
                }
                o.consumable.consume(r, {name: true});
                for (const [t, e] of s) {
                    o.consumable.consume(t, {attributes: Object.keys(e)})
                }
                if (s.size) {
                    o.writer.setAttribute("sources", Array.from(s.values()), l)
                }
                o.convertChildren(r, l)
            }
        }

        function yF(t, e) {
            return t => {
                t.on(`attribute:srcset:${e}`, n)
            };

            function n(e, n, i) {
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const o = i.writer;
                const r = i.mapper.toViewElement(n.item);
                const s = t.findViewImgElement(r);
                if (n.attributeNewValue === null) {
                    const t = n.attributeOldValue;
                    if (t.data) {
                        o.removeAttribute("srcset", s);
                        o.removeAttribute("sizes", s);
                        if (t.width) {
                            o.removeAttribute("width", s)
                        }
                    }
                } else {
                    const t = n.attributeNewValue;
                    if (t.data) {
                        o.setAttribute("srcset", t.data, s);
                        o.setAttribute("sizes", "100vw", s);
                        if (t.width) {
                            o.setAttribute("width", t.width, s)
                        }
                    }
                }
            }
        }

        function xF(t) {
            return t => {
                t.on("attribute:sources:imageBlock", e);
                t.on("attribute:sources:imageInline", e)
            };

            function e(e, n, i) {
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const o = i.writer;
                const r = i.mapper.toViewElement(n.item);
                const s = t.findViewImgElement(r);
                if (n.attributeNewValue && n.attributeNewValue.length) {
                    const t = o.createContainerElement("picture", null, n.attributeNewValue.map((t => o.createEmptyElement("source", t))));
                    const e = [];
                    let i = s.parent;
                    while (i && i.is("attributeElement")) {
                        const t = i.parent;
                        o.unwrap(o.createRangeOn(s), i);
                        e.unshift(i);
                        i = t
                    }
                    o.insert(o.createPositionBefore(s), t);
                    o.move(o.createRangeOn(s), o.createPositionAt(t, "end"));
                    for (const n of e) {
                        o.wrap(o.createRangeOn(t), n)
                    }
                } else if (s.parent.is("element", "picture")) {
                    const t = s.parent;
                    o.move(o.createRangeOn(s), o.createPositionBefore(t));
                    o.remove(t)
                }
            }
        }

        function EF(t, e, n) {
            return t => {
                t.on(`attribute:${n}:${e}`, i)
            };

            function i(e, n, i) {
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const o = i.writer;
                const r = i.mapper.toViewElement(n.item);
                const s = t.findViewImgElement(r);
                o.setAttribute(n.attributeKey, n.attributeNewValue || "", s)
            }
        }

        class SF extends Sf {
            observe(t) {
                this.listenTo(t, "load", ((t, e) => {
                    const n = e.target;
                    if (this.checkShouldIgnoreEventFromTarget(n)) {
                        return
                    }
                    if (n.tagName == "IMG") {
                        this._fireEvents(e)
                    }
                }), {useCapture: true})
            }

            _fireEvents(t) {
                if (this.isEnabled) {
                    this.document.fire("layoutChanged");
                    this.document.fire("imageLoaded", t)
                }
            }
        }

        class DF extends vc {
            constructor(t) {
                super(t);
                const e = t.config.get("image.insert.type");
                if (!t.plugins.has("ImageBlockEditing")) {
                    if (e === "block") {
                        I("image-block-plugin-required")
                    }
                }
                if (!t.plugins.has("ImageInlineEditing")) {
                    if (e === "inline") {
                        I("image-inline-plugin-required")
                    }
                }
            }

            refresh() {
                this.isEnabled = this.editor.plugins.get("ImageUtils").isImageAllowed()
            }

            execute(t) {
                const e = Zl(t.source);
                const n = this.editor.model.document.selection;
                const i = this.editor.plugins.get("ImageUtils");
                const o = Object.fromEntries(n.getAttributes());
                e.forEach(((t, e) => {
                    const r = n.getSelectedElement();
                    if (typeof t === "string") {
                        t = {src: t}
                    }
                    if (e && r && i.isImage(r)) {
                        const e = this.editor.model.createPositionAfter(r);
                        i.insertImage({...t, ...o}, e)
                    } else {
                        i.insertImage({...t, ...o})
                    }
                }))
            }
        }

        class TF extends Ac {
            static get requires() {
                return [aF]
            }

            static get pluginName() {
                return "ImageEditing"
            }

            init() {
                const t = this.editor;
                const e = t.conversion;
                t.editing.view.addObserver(SF);
                e.for("upcast").attributeToAttribute({
                    view: {name: "img", key: "alt"},
                    model: "alt"
                }).attributeToAttribute({
                    view: {name: "img", key: "srcset"}, model: {
                        key: "srcset", value: t => {
                            const e = {data: t.getAttribute("srcset")};
                            if (t.hasAttribute("width")) {
                                e.width = t.getAttribute("width")
                            }
                            return e
                        }
                    }
                });
                const n = new DF(t);
                t.commands.add("insertImage", n);
                t.commands.add("imageInsert", n)
            }
        }

        class BF extends vc {
            constructor(t, e) {
                super(t);
                this._modelElementName = e
            }

            refresh() {
                const t = this.editor;
                const e = t.plugins.get("ImageUtils");
                const n = e.getClosestSelectedImageElement(this.editor.model.document.selection);
                if (this._modelElementName === "imageBlock") {
                    this.isEnabled = e.isInlineImage(n)
                } else {
                    this.isEnabled = e.isBlockImage(n)
                }
            }

            execute() {
                const t = this.editor;
                const e = this.editor.model;
                const n = t.plugins.get("ImageUtils");
                const i = n.getClosestSelectedImageElement(e.document.selection);
                const o = Object.fromEntries(i.getAttributes());
                if (!o.src && !o.uploadId) {
                    return null
                }
                return e.change((t => {
                    const r = Array.from(e.markers).filter((t => t.getRange().containsItem(i)));
                    const s = n.insertImage(o, e.createSelection(i, "on"), this._modelElementName);
                    if (!s) {
                        return null
                    }
                    const a = t.createRangeOn(s);
                    for (const e of r) {
                        const n = e.getRange();
                        const i = n.root.rootName != "$graveyard" ? n.getJoined(a, true) : a;
                        t.updateMarker(e, {range: i})
                    }
                    return {oldElement: i, newElement: s}
                }))
            }
        }

        class PF extends Ac {
            static get requires() {
                return [TF, aF, NP]
            }

            static get pluginName() {
                return "ImageBlockEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                e.register("imageBlock", {inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"]});
                this._setupConversion();
                if (t.plugins.has("ImageInlineEditing")) {
                    t.commands.add("imageTypeBlock", new BF(this.editor, "imageBlock"));
                    this._setupClipboardIntegration()
                }
            }

            _setupConversion() {
                const t = this.editor;
                const e = t.t;
                const n = t.conversion;
                const i = t.plugins.get("ImageUtils");
                n.for("dataDowncast").elementToStructure({model: "imageBlock", view: (t, {writer: e}) => oF(e)});
                n.for("editingDowncast").elementToStructure({
                    model: "imageBlock",
                    view: (t, {writer: n}) => i.toImageWidget(oF(n), n, e("image widget"))
                });
                n.for("downcast").add(EF(i, "imageBlock", "src")).add(EF(i, "imageBlock", "alt")).add(yF(i, "imageBlock"));
                n.for("upcast").elementToElement({
                    view: rF(t, "imageBlock"),
                    model: (t, {writer: e}) => e.createElement("imageBlock", t.hasAttribute("src") ? {src: t.getAttribute("src")} : null)
                }).add(CF(i))
            }

            _setupClipboardIntegration() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = t.plugins.get("ImageUtils");
                this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((o, r) => {
                    const s = Array.from(r.content.getChildren());
                    let a;
                    if (!s.every(i.isInlineImageView)) {
                        return
                    }
                    if (r.targetRanges) {
                        a = t.editing.mapper.toModelRange(r.targetRanges[0])
                    } else {
                        a = e.document.selection.getFirstRange()
                    }
                    const l = e.createSelection(a);
                    if (sF(e.schema, l) === "imageBlock") {
                        const t = new Mw(n.document);
                        const e = s.map((e => t.createElement("figure", {class: "image"}, e)));
                        r.content = t.createDocumentFragment(e)
                    }
                }))
            }
        }

        var IF = n(9048);
        var RF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        RF.insert = "head";
        RF.singleton = true;
        var zF = Bc()(IF.Z, RF);
        const VF = IF.Z.locals || {};

        class FF extends Ac {
            static get requires() {
                return [PF, zI, AF]
            }

            static get pluginName() {
                return "ImageBlock"
            }
        }

        class LF extends Ac {
            static get requires() {
                return [TF, aF, NP]
            }

            static get pluginName() {
                return "ImageInlineEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                e.register("imageInline", {inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"]});
                e.addChildCheck(((t, e) => {
                    if (t.endsWith("caption") && e.name === "imageInline") {
                        return false
                    }
                }));
                this._setupConversion();
                if (t.plugins.has("ImageBlockEditing")) {
                    t.commands.add("imageTypeInline", new BF(this.editor, "imageInline"));
                    this._setupClipboardIntegration()
                }
            }

            _setupConversion() {
                const t = this.editor;
                const e = t.t;
                const n = t.conversion;
                const i = t.plugins.get("ImageUtils");
                n.for("dataDowncast").elementToElement({
                    model: "imageInline",
                    view: (t, {writer: e}) => e.createEmptyElement("img")
                });
                n.for("editingDowncast").elementToStructure({
                    model: "imageInline",
                    view: (t, {writer: n}) => i.toImageWidget(iF(n), n, e("image widget"))
                });
                n.for("downcast").add(EF(i, "imageInline", "src")).add(EF(i, "imageInline", "alt")).add(yF(i, "imageInline"));
                n.for("upcast").elementToElement({
                    view: rF(t, "imageInline"),
                    model: (t, {writer: e}) => e.createElement("imageInline", t.hasAttribute("src") ? {src: t.getAttribute("src")} : null)
                })
            }

            _setupClipboardIntegration() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = t.plugins.get("ImageUtils");
                this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((o, r) => {
                    const s = Array.from(r.content.getChildren());
                    let a;
                    if (!s.every(i.isBlockImageView)) {
                        return
                    }
                    if (r.targetRanges) {
                        a = t.editing.mapper.toModelRange(r.targetRanges[0])
                    } else {
                        a = e.document.selection.getFirstRange()
                    }
                    const l = e.createSelection(a);
                    if (sF(e.schema, l) === "imageInline") {
                        const t = new Mw(n.document);
                        const e = s.map((e => {
                            if (e.childCount === 1) {
                                Array.from(e.getAttributes()).forEach((n => t.setAttribute(...n, i.findViewImgElement(e))));
                                return e.getChild(0)
                            } else {
                                return e
                            }
                        }));
                        r.content = t.createDocumentFragment(e)
                    }
                }))
            }
        }

        class OF extends Ac {
            static get requires() {
                return [LF, zI, AF]
            }

            static get pluginName() {
                return "ImageInline"
            }
        }

        class NF extends Ac {
            static get requires() {
                return [FF, OF]
            }

            static get pluginName() {
                return "Image"
            }
        }

        class MF extends vc {
            refresh() {
                const t = this.editor;
                const e = t.plugins.get("ImageUtils");
                const n = e.getClosestSelectedImageElement(t.model.document.selection);
                this.isEnabled = !!n;
                if (!n || !n.hasAttribute("width")) {
                    this.value = null
                } else {
                    this.value = {width: n.getAttribute("width"), height: null}
                }
            }

            execute(t) {
                const e = this.editor;
                const n = e.model;
                const i = e.plugins.get("ImageUtils");
                const o = i.getClosestSelectedImageElement(n.document.selection);
                this.value = {width: t.width, height: null};
                if (o) {
                    n.change((e => {
                        e.setAttribute("width", t.width, o)
                    }))
                }
            }
        }

        class HF extends Ac {
            static get requires() {
                return [aF]
            }

            static get pluginName() {
                return "ImageResizeEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("image", {
                    resizeUnit: "%",
                    resizeOptions: [{
                        name: "resizeImage:original",
                        value: null,
                        icon: "original"
                    }, {name: "resizeImage:25", value: "25", icon: "small"}, {
                        name: "resizeImage:50",
                        value: "50",
                        icon: "medium"
                    }, {name: "resizeImage:75", value: "75", icon: "large"}]
                })
            }

            init() {
                const t = this.editor;
                const e = new MF(t);
                this._registerSchema();
                this._registerConverters("imageBlock");
                this._registerConverters("imageInline");
                t.commands.add("resizeImage", e);
                t.commands.add("imageResize", e)
            }

            _registerSchema() {
                if (this.editor.plugins.has("ImageBlockEditing")) {
                    this.editor.model.schema.extend("imageBlock", {allowAttributes: "width"})
                }
                if (this.editor.plugins.has("ImageInlineEditing")) {
                    this.editor.model.schema.extend("imageInline", {allowAttributes: "width"})
                }
            }

            _registerConverters(t) {
                const e = this.editor;
                e.conversion.for("downcast").add((e => e.on(`attribute:width:${t}`, ((t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) {
                        return
                    }
                    const i = n.writer;
                    const o = n.mapper.toViewElement(e.item);
                    if (e.attributeNewValue !== null) {
                        i.setStyle("width", e.attributeNewValue, o);
                        i.addClass("image_resized", o)
                    } else {
                        i.removeStyle("width", o);
                        i.removeClass("image_resized", o)
                    }
                }))));
                e.conversion.for("upcast").attributeToAttribute({
                    view: {
                        name: t === "imageBlock" ? "figure" : "img",
                        styles: {width: /.+/}
                    }, model: {key: "width", value: t => t.getStyle("width")}
                })
            }
        }

        const WF = {
            small: CC.objectSizeSmall,
            medium: CC.objectSizeMedium,
            large: CC.objectSizeLarge,
            original: CC.objectSizeFull
        };

        class qF extends Ac {
            static get requires() {
                return [HF]
            }

            static get pluginName() {
                return "ImageResizeButtons"
            }

            constructor(t) {
                super(t);
                this._resizeUnit = t.config.get("image.resizeUnit")
            }

            init() {
                const t = this.editor;
                const e = t.config.get("image.resizeOptions");
                const n = t.commands.get("resizeImage");
                this.bind("isEnabled").to(n);
                for (const t of e) {
                    this._registerImageResizeButton(t)
                }
                this._registerImageResizeDropdown(e)
            }

            _registerImageResizeButton(t) {
                const e = this.editor;
                const {name: n, value: i, icon: o} = t;
                const r = i ? i + this._resizeUnit : null;
                e.ui.componentFactory.add(n, (n => {
                    const i = new LC(n);
                    const s = e.commands.get("resizeImage");
                    const a = this._getOptionLabelValue(t, true);
                    if (!WF[o]) {
                        throw new P("imageresizebuttons-missing-icon", e, t)
                    }
                    i.set({label: a, icon: WF[o], tooltip: a, isToggleable: true});
                    i.bind("isEnabled").to(this);
                    i.bind("isOn").to(s, "value", jF(r));
                    this.listenTo(i, "execute", (() => {
                        e.execute("resizeImage", {width: r})
                    }));
                    return i
                }))
            }

            _registerImageResizeDropdown(t) {
                const e = this.editor;
                const n = e.t;
                const i = t.find((t => !t.value));
                const o = o => {
                    const r = e.commands.get("resizeImage");
                    const s = qv(o, tv);
                    const a = s.buttonView;
                    a.set({
                        tooltip: n("Resize image"),
                        commandValue: i.value,
                        icon: WF.medium,
                        isToggleable: true,
                        label: this._getOptionLabelValue(i),
                        withText: true,
                        class: "ck-resize-image-button"
                    });
                    a.bind("label").to(r, "value", (t => {
                        if (t && t.width) {
                            return t.width
                        } else {
                            return this._getOptionLabelValue(i)
                        }
                    }));
                    s.bind("isOn").to(r);
                    s.bind("isEnabled").to(this);
                    $v(s, this._getResizeDropdownListItemDefinitions(t, r));
                    s.listView.ariaLabel = n("Image resize list");
                    this.listenTo(s, "execute", (t => {
                        e.execute(t.source.commandName, {width: t.source.commandValue});
                        e.editing.view.focus()
                    }));
                    return s
                };
                e.ui.componentFactory.add("resizeImage", o);
                e.ui.componentFactory.add("imageResize", o)
            }

            _getOptionLabelValue(t, e) {
                const n = this.editor.t;
                if (t.label) {
                    return t.label
                } else if (e) {
                    if (t.value) {
                        return n("Resize image to %0", t.value + this._resizeUnit)
                    } else {
                        return n("Resize image to the original size")
                    }
                } else {
                    if (t.value) {
                        return t.value + this._resizeUnit
                    } else {
                        return n("Original")
                    }
                }
            }

            _getResizeDropdownListItemDefinitions(t, e) {
                const n = new rc;
                t.map((t => {
                    const i = t.value ? t.value + this._resizeUnit : null;
                    const o = {
                        type: "button",
                        model: new Fy({
                            commandName: "resizeImage",
                            commandValue: i,
                            label: this._getOptionLabelValue(t),
                            withText: true,
                            icon: null
                        })
                    };
                    o.model.bind("isOn").to(e, "value", jF(i));
                    n.add(o)
                }));
                return n
            }
        }

        function jF(t) {
            return e => {
                if (t === null && e === t) {
                    return true
                }
                return e && e.width === t
            }
        }

        const $F = "figure.image.ck-widget > img," + "figure.image.ck-widget > picture > img," + "figure.image.ck-widget > a > img," + "figure.image.ck-widget > a > picture > img," + "span.image-inline.ck-widget > img," + "span.image-inline.ck-widget > picture > img";
        const UF = /(image|image-inline)/;
        const GF = "image_resized";

        class KF extends Ac {
            static get requires() {
                return [rR]
            }

            static get pluginName() {
                return "ImageResizeHandles"
            }

            init() {
                const t = this.editor.commands.get("resizeImage");
                this.bind("isEnabled").to(t);
                this._setupResizerCreator()
            }

            _setupResizerCreator() {
                const t = this.editor;
                const e = t.editing.view;
                e.addObserver(SF);
                this.listenTo(e.document, "imageLoaded", ((n, i) => {
                    if (!i.target.matches($F)) {
                        return
                    }
                    const o = t.editing.view.domConverter;
                    const r = o.domToView(i.target);
                    const s = r.findAncestor({classes: UF});
                    let a = this.editor.plugins.get(rR).getResizerByViewElement(s);
                    if (a) {
                        a.redraw();
                        return
                    }
                    const l = t.editing.mapper;
                    const c = l.toModelElement(s);
                    a = t.plugins.get(rR).attachTo({
                        unit: t.config.get("image.resizeUnit"),
                        modelElement: c,
                        viewElement: s,
                        editor: t,
                        getHandleHost(t) {
                            return t.querySelector("img")
                        },
                        getResizeHost() {
                            return o.mapViewToDom(l.toViewElement(c.parent))
                        },
                        isCentered() {
                            const t = c.getAttribute("imageStyle");
                            return !t || t == "block" || t == "alignCenter"
                        },
                        onCommit(n) {
                            e.change((t => {
                                t.removeClass(GF, s)
                            }));
                            t.execute("resizeImage", {width: n})
                        }
                    });
                    a.on("updateSize", (() => {
                        if (!s.hasClass(GF)) {
                            e.change((t => {
                                t.addClass(GF, s)
                            }))
                        }
                    }));
                    a.bind("isEnabled").to(this)
                }))
            }
        }

        var ZF = n(1043);
        var JF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        JF.insert = "head";
        JF.singleton = true;
        var YF = Bc()(ZF.Z, JF);
        const QF = ZF.Z.locals || {};

        class XF extends Ac {
            static get requires() {
                return [HF, KF, qF]
            }

            static get pluginName() {
                return "ImageResize"
            }
        }

        class tL extends vc {
            constructor(t, e) {
                super(t);
                this._defaultStyles = {imageBlock: false, imageInline: false};
                this._styles = new Map(e.map((t => {
                    if (t.isDefault) {
                        for (const e of t.modelElements) {
                            this._defaultStyles[e] = t.name
                        }
                    }
                    return [t.name, t]
                })))
            }

            refresh() {
                const t = this.editor;
                const e = t.plugins.get("ImageUtils");
                const n = e.getClosestSelectedImageElement(this.editor.model.document.selection);
                this.isEnabled = !!n;
                if (!this.isEnabled) {
                    this.value = false
                } else if (n.hasAttribute("imageStyle")) {
                    this.value = n.getAttribute("imageStyle")
                } else {
                    this.value = this._defaultStyles[n.name]
                }
            }

            execute(t = {}) {
                const e = this.editor;
                const n = e.model;
                const i = e.plugins.get("ImageUtils");
                n.change((e => {
                    const o = t.value;
                    let r = i.getClosestSelectedImageElement(n.document.selection);
                    if (o && this.shouldConvertImageType(o, r)) {
                        this.editor.execute(i.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock");
                        r = i.getClosestSelectedImageElement(n.document.selection)
                    }
                    if (!o || this._styles.get(o).isDefault) {
                        e.removeAttribute("imageStyle", r)
                    } else {
                        e.setAttribute("imageStyle", o, r)
                    }
                }))
            }

            shouldConvertImageType(t, e) {
                const n = this._styles.get(t).modelElements;
                return !n.includes(e.name)
            }
        }

        const {
            objectFullWidth: eL,
            objectInline: nL,
            objectLeft: iL,
            objectRight: oL,
            objectCenter: rL,
            objectBlockLeft: sL,
            objectBlockRight: aL
        } = CC;
        const lL = {
            get inline() {
                return {name: "inline", title: "In line", icon: nL, modelElements: ["imageInline"], isDefault: true}
            }, get alignLeft() {
                return {
                    name: "alignLeft",
                    title: "Left aligned image",
                    icon: iL,
                    modelElements: ["imageBlock", "imageInline"],
                    className: "image-style-align-left"
                }
            }, get alignBlockLeft() {
                return {
                    name: "alignBlockLeft",
                    title: "Left aligned image",
                    icon: sL,
                    modelElements: ["imageBlock"],
                    className: "image-style-block-align-left"
                }
            }, get alignCenter() {
                return {
                    name: "alignCenter",
                    title: "Centered image",
                    icon: rL,
                    modelElements: ["imageBlock"],
                    className: "image-style-align-center"
                }
            }, get alignRight() {
                return {
                    name: "alignRight",
                    title: "Right aligned image",
                    icon: oL,
                    modelElements: ["imageBlock", "imageInline"],
                    className: "image-style-align-right"
                }
            }, get alignBlockRight() {
                return {
                    name: "alignBlockRight",
                    title: "Right aligned image",
                    icon: aL,
                    modelElements: ["imageBlock"],
                    className: "image-style-block-align-right"
                }
            }, get block() {
                return {
                    name: "block",
                    title: "Centered image",
                    icon: rL,
                    modelElements: ["imageBlock"],
                    isDefault: true
                }
            }, get side() {
                return {
                    name: "side",
                    title: "Side image",
                    icon: oL,
                    modelElements: ["imageBlock"],
                    className: "image-style-side"
                }
            }
        };
        const cL = {full: eL, left: sL, right: aL, center: rL, inlineLeft: iL, inlineRight: oL, inline: nL};
        const dL = [{
            name: "imageStyle:wrapText",
            title: "Wrap text",
            defaultItem: "imageStyle:alignLeft",
            items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
        }, {
            name: "imageStyle:breakText",
            title: "Break text",
            defaultItem: "imageStyle:block",
            items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
        }];

        function uL(t) {
            const e = t.configuredStyles.options || [];
            const n = e.map((t => gL(t))).filter((e => mL(e, t)));
            return n
        }

        function hL(t, e) {
            if (t && e) {
                return {options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]}
            } else if (t) {
                return {options: ["block", "side"]}
            } else if (e) {
                return {options: ["inline", "alignLeft", "alignRight"]}
            }
            return {}
        }

        function fL(t) {
            if (t.has("ImageBlockEditing") && t.has("ImageInlineEditing")) {
                return [...dL]
            } else {
                return []
            }
        }

        function gL(t) {
            if (typeof t === "string") {
                if (!lL[t]) {
                    t = {name: t}
                } else {
                    t = {...lL[t]}
                }
            } else {
                t = pL(lL[t.name], t)
            }
            if (typeof t.icon === "string") {
                t.icon = cL[t.icon] || t.icon
            }
            return t
        }

        function mL(t, {isBlockPluginLoaded: e, isInlinePluginLoaded: n}) {
            const {modelElements: i, name: o} = t;
            if (!i || !i.length || !o) {
                bL({style: t});
                return false
            } else {
                const o = [e ? "imageBlock" : null, n ? "imageInline" : null];
                if (!i.some((t => o.includes(t)))) {
                    I("image-style-missing-dependency", {
                        style: t,
                        missingPlugins: i.map((t => t === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing"))
                    });
                    return false
                }
            }
            return true
        }

        function pL(t, e) {
            const n = {...e};
            for (const i in t) {
                if (!Object.prototype.hasOwnProperty.call(e, i)) {
                    n[i] = t[i]
                }
            }
            return n
        }

        function bL(t) {
            I("image-style-configuration-definition-invalid", t)
        }

        const kL = {
            normalizeStyles: uL,
            getDefaultStylesConfiguration: hL,
            getDefaultDropdownDefinitions: fL,
            warnInvalidStyle: bL,
            DEFAULT_OPTIONS: lL,
            DEFAULT_ICONS: cL,
            DEFAULT_DROPDOWN_DEFINITIONS: dL
        };

        function wL(t) {
            return (e, n, i) => {
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const o = AL(n.attributeNewValue, t);
                const r = AL(n.attributeOldValue, t);
                const s = i.mapper.toViewElement(n.item);
                const a = i.writer;
                if (r) {
                    a.removeClass(r.className, s)
                }
                if (o) {
                    a.addClass(o.className, s)
                }
            }
        }

        function _L(t) {
            const e = {
                imageInline: t.filter((t => !t.isDefault && t.modelElements.includes("imageInline"))),
                imageBlock: t.filter((t => !t.isDefault && t.modelElements.includes("imageBlock")))
            };
            return (t, n, i) => {
                if (!n.modelRange) {
                    return
                }
                const o = n.viewItem;
                const r = sc(n.modelRange.getItems());
                if (!r) {
                    return
                }
                if (!i.schema.checkAttribute(r, "imageStyle")) {
                    return
                }
                for (const t of e[r.name]) {
                    if (i.consumable.consume(o, {classes: t.className})) {
                        i.writer.setAttribute("imageStyle", t.name, r)
                    }
                }
            }
        }

        function AL(t, e) {
            for (const n of e) {
                if (n.name === t) {
                    return n
                }
            }
        }

        class CL extends Ac {
            static get pluginName() {
                return "ImageStyleEditing"
            }

            static get requires() {
                return [aF]
            }

            init() {
                const {normalizeStyles: t, getDefaultStylesConfiguration: e} = kL;
                const n = this.editor;
                const i = n.plugins.has("ImageBlockEditing");
                const o = n.plugins.has("ImageInlineEditing");
                n.config.define("image.styles", e(i, o));
                this.normalizedStyles = t({
                    configuredStyles: n.config.get("image.styles"),
                    isBlockPluginLoaded: i,
                    isInlinePluginLoaded: o
                });
                this._setupConversion(i, o);
                this._setupPostFixer();
                n.commands.add("imageStyle", new tL(n, this.normalizedStyles))
            }

            _setupConversion(t, e) {
                const n = this.editor;
                const i = n.model.schema;
                const o = wL(this.normalizedStyles);
                const r = _L(this.normalizedStyles);
                n.editing.downcastDispatcher.on("attribute:imageStyle", o);
                n.data.downcastDispatcher.on("attribute:imageStyle", o);
                if (t) {
                    i.extend("imageBlock", {allowAttributes: "imageStyle"});
                    n.data.upcastDispatcher.on("element:figure", r, {priority: "low"})
                }
                if (e) {
                    i.extend("imageInline", {allowAttributes: "imageStyle"});
                    n.data.upcastDispatcher.on("element:img", r, {priority: "low"})
                }
            }

            _setupPostFixer() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.plugins.get(aF);
                const i = new Map(this.normalizedStyles.map((t => [t.name, t])));
                e.registerPostFixer((t => {
                    let o = false;
                    for (const r of e.differ.getChanges()) {
                        if (r.type == "insert" || r.type == "attribute" && r.attributeKey == "imageStyle") {
                            let e = r.type == "insert" ? r.position.nodeAfter : r.range.start.nodeAfter;
                            if (e && e.is("element", "paragraph") && e.childCount > 0) {
                                e = e.getChild(0)
                            }
                            if (!n.isImage(e)) {
                                continue
                            }
                            const s = e.getAttribute("imageStyle");
                            if (!s) {
                                continue
                            }
                            const a = i.get(s);
                            if (!a || !a.modelElements.includes(e.name)) {
                                t.removeAttribute("imageStyle", e);
                                o = true
                            }
                        }
                    }
                    return o
                }))
            }
        }

        var vL = n(4622);
        var yL = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        yL.insert = "head";
        yL.singleton = true;
        var xL = Bc()(vL.Z, yL);
        const EL = vL.Z.locals || {};

        class SL extends Ac {
            static get requires() {
                return [CL]
            }

            static get pluginName() {
                return "ImageStyleUI"
            }

            get localizedDefaultStylesTitles() {
                const t = this.editor.t;
                return {
                    "Wrap text": t("Wrap text"),
                    "Break text": t("Break text"),
                    "In line": t("In line"),
                    "Full size image": t("Full size image"),
                    "Side image": t("Side image"),
                    "Left aligned image": t("Left aligned image"),
                    "Centered image": t("Centered image"),
                    "Right aligned image": t("Right aligned image")
                }
            }

            init() {
                const t = this.editor.plugins;
                const e = this.editor.config.get("image.toolbar") || [];
                const n = DL(t.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
                for (const t of n) {
                    this._createButton(t)
                }
                const i = DL([...e.filter(it), ...kL.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles);
                for (const t of i) {
                    this._createDropdown(t, n)
                }
            }

            _createDropdown(t, e) {
                const n = this.editor.ui.componentFactory;
                n.add(t.name, (i => {
                    let o;
                    const {defaultItem: r, items: s, title: a} = t;
                    const l = s.filter((t => e.find((({name: e}) => TL(e) === t)))).map((t => {
                        const e = n.create(t);
                        if (t === r) {
                            o = e
                        }
                        return e
                    }));
                    if (s.length !== l.length) {
                        kL.warnInvalidStyle({dropdown: t})
                    }
                    const c = qv(i, rv);
                    const d = c.buttonView;
                    const u = d.arrowView;
                    jv(c, l, {enableActiveItemFocusOnDropdownOpen: true});
                    d.set({label: BL(a, o.label), class: null, tooltip: true});
                    u.unbind("label");
                    u.set({label: a});
                    d.bind("icon").toMany(l, "isOn", ((...t) => {
                        const e = t.findIndex(mu);
                        return e < 0 ? o.icon : l[e].icon
                    }));
                    d.bind("label").toMany(l, "isOn", ((...t) => {
                        const e = t.findIndex(mu);
                        return BL(a, e < 0 ? o.label : l[e].label)
                    }));
                    d.bind("isOn").toMany(l, "isOn", ((...t) => t.some(mu)));
                    d.bind("class").toMany(l, "isOn", ((...t) => t.some(mu) ? "ck-splitbutton_flatten" : null));
                    d.on("execute", (() => {
                        if (!l.some((({isOn: t}) => t))) {
                            o.fire("execute")
                        } else {
                            c.isOpen = !c.isOpen
                        }
                    }));
                    c.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some(mu)));
                    this.listenTo(c, "execute", (() => {
                        this.editor.editing.view.focus()
                    }));
                    return c
                }))
            }

            _createButton(t) {
                const e = t.name;
                this.editor.ui.componentFactory.add(TL(e), (n => {
                    const i = this.editor.commands.get("imageStyle");
                    const o = new LC(n);
                    o.set({label: t.title, icon: t.icon, tooltip: true, isToggleable: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    o.bind("isOn").to(i, "value", (t => t === e));
                    o.on("execute", this._executeCommand.bind(this, e));
                    return o
                }))
            }

            _executeCommand(t) {
                this.editor.execute("imageStyle", {value: t});
                this.editor.editing.view.focus()
            }
        }

        function DL(t, e) {
            for (const n of t) {
                if (e[n.title]) {
                    n.title = e[n.title]
                }
            }
            return t
        }

        function TL(t) {
            return `imageStyle:${t}`
        }

        function BL(t, e) {
            return (t ? t + ": " : "") + e
        }

        class PL extends Ac {
            static get requires() {
                return [CL, SL]
            }

            static get pluginName() {
                return "ImageStyle"
            }
        }

        class IL extends pA {
            constructor(t) {
                super(t);
                this.buttonView = new LC(t);
                this._fileInputView = new RL(t);
                this._fileInputView.bind("acceptedType").to(this);
                this._fileInputView.bind("allowMultipleFiles").to(this);
                this._fileInputView.delegate("done").to(this);
                this.setTemplate({
                    tag: "span",
                    attributes: {class: "ck-file-dialog-button"},
                    children: [this.buttonView, this._fileInputView]
                });
                this.buttonView.on("execute", (() => {
                    this._fileInputView.open()
                }))
            }

            focus() {
                this.buttonView.focus()
            }
        }

        class RL extends pA {
            constructor(t) {
                super(t);
                this.set("acceptedType", undefined);
                this.set("allowMultipleFiles", false);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck-hidden"],
                        type: "file",
                        tabindex: "-1",
                        accept: e.to("acceptedType"),
                        multiple: e.to("allowMultipleFiles")
                    },
                    on: {
                        change: e.to((() => {
                            if (this.element && this.element.files && this.element.files.length) {
                                this.fire("done", this.element.files)
                            }
                            this.element.value = ""
                        }))
                    }
                })
            }

            open() {
                this.element.click()
            }
        }

        class zL extends (null && Plugin) {
            static get requires() {
                return [FileRepository]
            }

            static get pluginName() {
                return "SimpleUploadAdapter"
            }

            init() {
                const t = this.editor.config.get("simpleUpload");
                if (!t) {
                    return
                }
                if (!t.uploadUrl) {
                    logWarning("simple-upload-adapter-missing-uploadurl");
                    return
                }
                this.editor.plugins.get(FileRepository).createUploadAdapter = e => new VL(e, t)
            }
        }

        class VL {
            constructor(t, e) {
                this.loader = t;
                this.options = e
            }

            upload() {
                return this.loader.file.then((t => new Promise(((e, n) => {
                    this._initRequest();
                    this._initListeners(e, n, t);
                    this._sendRequest(t)
                }))))
            }

            abort() {
                if (this.xhr) {
                    this.xhr.abort()
                }
            }

            _initRequest() {
                const t = this.xhr = new XMLHttpRequest;
                t.open("POST", this.options.uploadUrl, true);
                t.responseType = "json"
            }

            _initListeners(t, e, n) {
                const i = this.xhr;
                const o = this.loader;
                const r = `Couldn't upload file: ${n.name}.`;
                i.addEventListener("error", (() => e(r)));
                i.addEventListener("abort", (() => e()));
                i.addEventListener("load", (() => {
                    const n = i.response;
                    if (!n || n.error) {
                        return e(n && n.error && n.error.message ? n.error.message : r)
                    }
                    const o = n.url ? {default: n.url} : n.urls;
                    t({...n, urls: o})
                }));
                if (i.upload) {
                    i.upload.addEventListener("progress", (t => {
                        if (t.lengthComputable) {
                            o.uploadTotal = t.total;
                            o.uploaded = t.loaded
                        }
                    }))
                }
            }

            _sendRequest(t) {
                const e = this.options.headers || {};
                const n = this.options.withCredentials || false;
                for (const t of Object.keys(e)) {
                    this.xhr.setRequestHeader(t, e[t])
                }
                this.xhr.withCredentials = n;
                const i = new FormData;
                i.append("upload", t);
                this.xhr.send(i)
            }
        }

        function FL(t) {
            const e = t.map((t => t.replace("+", "\\+")));
            return new RegExp(`^image\\/(${e.join("|")})$`)
        }

        function LL(t) {
            return new Promise(((e, n) => {
                const i = t.getAttribute("src");
                fetch(i).then((t => t.blob())).then((t => {
                    const n = NL(t, i);
                    const o = n.replace("image/", "");
                    const r = `image.${o}`;
                    const s = new File([t], r, {type: n});
                    e(s)
                })).catch((t => t && t.name === "TypeError" ? ML(i).then(e).catch(n) : n(t)))
            }))
        }

        function OL(t, e) {
            if (!t.isInlineImageView(e) || !e.getAttribute("src")) {
                return false
            }
            return e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || e.getAttribute("src").match(/^blob:/g)
        }

        function NL(t, e) {
            if (t.type) {
                return t.type
            } else if (e.match(/data:(image\/\w+);base64/)) {
                return e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
            } else {
                return "image/jpeg"
            }
        }

        function ML(t) {
            return HL(t).then((e => {
                const n = NL(e, t);
                const i = n.replace("image/", "");
                const o = `image.${i}`;
                return new File([e], o, {type: n})
            }))
        }

        function HL(t) {
            return new Promise(((e, n) => {
                const i = Xa.document.createElement("img");
                i.addEventListener("load", (() => {
                    const t = Xa.document.createElement("canvas");
                    t.width = i.width;
                    t.height = i.height;
                    const o = t.getContext("2d");
                    o.drawImage(i, 0, 0);
                    t.toBlob((t => t ? e(t) : n()))
                }));
                i.addEventListener("error", (() => n()));
                i.src = t
            }))
        }

        class WL extends Ac {
            static get pluginName() {
                return "ImageUploadUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = n => {
                    const i = new IL(n);
                    const o = t.commands.get("uploadImage");
                    const r = t.config.get("image.upload.types");
                    const s = FL(r);
                    i.set({acceptedType: r.map((t => `image/${t}`)).join(","), allowMultipleFiles: true});
                    i.buttonView.set({label: e("Insert image"), icon: CC.image, tooltip: true});
                    i.buttonView.bind("isEnabled").to(o);
                    i.on("done", ((e, n) => {
                        const i = Array.from(n).filter((t => s.test(t.type)));
                        if (i.length) {
                            t.execute("uploadImage", {file: i});
                            t.editing.view.focus()
                        }
                    }));
                    return i
                };
                t.ui.componentFactory.add("uploadImage", n);
                t.ui.componentFactory.add("imageUpload", n)
            }
        }

        var qL = n(5870);
        var jL = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        jL.insert = "head";
        jL.singleton = true;
        var $L = Bc()(qL.Z, jL);
        const UL = qL.Z.locals || {};
        var GL = n(9899);
        var KL = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        KL.insert = "head";
        KL.singleton = true;
        var ZL = Bc()(GL.Z, KL);
        const JL = GL.Z.locals || {};
        var YL = n(9825);
        var QL = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        QL.insert = "head";
        QL.singleton = true;
        var XL = Bc()(YL.Z, QL);
        const tO = YL.Z.locals || {};

        class eO extends Ac {
            static get pluginName() {
                return "ImageUploadProgress"
            }

            constructor(t) {
                super(t);
                this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
            }

            init() {
                const t = this.editor;
                if (t.plugins.has("ImageBlockEditing")) {
                    t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", ((...t) => this.uploadStatusChange(...t)))
                }
                if (t.plugins.has("ImageInlineEditing")) {
                    t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", ((...t) => this.uploadStatusChange(...t)))
                }
            }

            uploadStatusChange(t, e, n) {
                const i = this.editor;
                const o = e.item;
                const r = o.getAttribute("uploadId");
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const s = i.plugins.get("ImageUtils");
                const a = i.plugins.get(KS);
                const l = r ? e.attributeNewValue : null;
                const c = this.placeholder;
                const d = i.editing.mapper.toViewElement(o);
                const u = n.writer;
                if (l == "reading") {
                    nO(d, u);
                    oO(s, c, d, u);
                    return
                }
                if (l == "uploading") {
                    const t = a.loaders.get(r);
                    nO(d, u);
                    if (!t) {
                        oO(s, c, d, u)
                    } else {
                        rO(d, u);
                        sO(d, u, t, i.editing.view);
                        fO(s, d, u, t)
                    }
                    return
                }
                if (l == "complete" && a.loaders.get(r)) {
                    lO(d, u, i.editing.view)
                }
                aO(d, u);
                rO(d, u);
                iO(d, u)
            }
        }

        function nO(t, e) {
            if (!t.hasClass("ck-appear")) {
                e.addClass("ck-appear", t)
            }
        }

        function iO(t, e) {
            e.removeClass("ck-appear", t)
        }

        function oO(t, e, n, i) {
            if (!n.hasClass("ck-image-upload-placeholder")) {
                i.addClass("ck-image-upload-placeholder", n)
            }
            const o = t.findViewImgElement(n);
            if (o.getAttribute("src") !== e) {
                i.setAttribute("src", e, o)
            }
            if (!uO(n, "placeholder")) {
                i.insert(i.createPositionAfter(o), dO(i))
            }
        }

        function rO(t, e) {
            if (t.hasClass("ck-image-upload-placeholder")) {
                e.removeClass("ck-image-upload-placeholder", t)
            }
            hO(t, e, "placeholder")
        }

        function sO(t, e, n, i) {
            const o = cO(e);
            e.insert(e.createPositionAt(t, "end"), o);
            n.on("change:uploadedPercent", ((t, e, n) => {
                i.change((t => {
                    t.setStyle("width", n + "%", o)
                }))
            }))
        }

        function aO(t, e) {
            hO(t, e, "progressBar")
        }

        function lO(t, e, n) {
            const i = e.createUIElement("div", {class: "ck-image-upload-complete-icon"});
            e.insert(e.createPositionAt(t, "end"), i);
            setTimeout((() => {
                n.change((t => t.remove(t.createRangeOn(i))))
            }), 3e3)
        }

        function cO(t) {
            const e = t.createUIElement("div", {class: "ck-progress-bar"});
            t.setCustomProperty("progressBar", true, e);
            return e
        }

        function dO(t) {
            const e = t.createUIElement("div", {class: "ck-upload-placeholder-loader"});
            t.setCustomProperty("placeholder", true, e);
            return e
        }

        function uO(t, e) {
            for (const n of t.getChildren()) {
                if (n.getCustomProperty(e)) {
                    return n
                }
            }
        }

        function hO(t, e, n) {
            const i = uO(t, n);
            if (i) {
                e.remove(e.createRangeOn(i))
            }
        }

        function fO(t, e, n, i) {
            if (i.data) {
                const o = t.findViewImgElement(e);
                n.setAttribute("src", i.data, o)
            }
        }

        class gO extends vc {
            refresh() {
                const t = this.editor;
                const e = t.plugins.get("ImageUtils");
                const n = t.model.document.selection.getSelectedElement();
                this.isEnabled = e.isImageAllowed() || e.isImage(n)
            }

            execute(t) {
                const e = Zl(t.file);
                const n = this.editor.model.document.selection;
                const i = this.editor.plugins.get("ImageUtils");
                const o = Object.fromEntries(n.getAttributes());
                e.forEach(((t, e) => {
                    const r = n.getSelectedElement();
                    if (e && r && i.isImage(r)) {
                        const e = this.editor.model.createPositionAfter(r);
                        this._uploadImage(t, o, e)
                    } else {
                        this._uploadImage(t, o)
                    }
                }))
            }

            _uploadImage(t, e, n) {
                const i = this.editor;
                const o = i.plugins.get(KS);
                const r = o.createLoader(t);
                const s = i.plugins.get("ImageUtils");
                if (!r) {
                    return
                }
                s.insertImage({...e, uploadId: r.id}, n)
            }
        }

        class mO extends Ac {
            static get requires() {
                return [KS, Vy, NP, aF]
            }

            static get pluginName() {
                return "ImageUploadEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("image", {upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]}});
                this._uploadImageElements = new Map
            }

            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.conversion;
                const i = t.plugins.get(KS);
                const o = t.plugins.get("ImageUtils");
                const r = FL(t.config.get("image.upload.types"));
                const s = new gO(t);
                t.commands.add("uploadImage", s);
                t.commands.add("imageUpload", s);
                n.for("upcast").attributeToAttribute({view: {name: "img", key: "uploadId"}, model: "uploadId"});
                this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                    if (pO(n.dataTransfer)) {
                        return
                    }
                    const i = Array.from(n.dataTransfer.files).filter((t => {
                        if (!t) {
                            return false
                        }
                        return r.test(t.type)
                    }));
                    if (!i.length) {
                        return
                    }
                    e.stop();
                    t.model.change((e => {
                        if (n.targetRanges) {
                            e.setSelection(n.targetRanges.map((e => t.editing.mapper.toModelRange(e))))
                        }
                        t.model.enqueueChange((() => {
                            t.execute("uploadImage", {file: i})
                        }))
                    }))
                }));
                this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((e, n) => {
                    const r = Array.from(t.editing.view.createRangeIn(n.content)).filter((t => OL(o, t.item) && !t.item.getAttribute("uploadProcessed"))).map((t => ({
                        promise: LL(t.item),
                        imageElement: t.item
                    })));
                    if (!r.length) {
                        return
                    }
                    const s = new Mw(t.editing.view.document);
                    for (const t of r) {
                        s.setAttribute("uploadProcessed", true, t.imageElement);
                        const e = i.createLoader(t.promise);
                        if (e) {
                            s.setAttribute("src", "", t.imageElement);
                            s.setAttribute("uploadId", e.id, t.imageElement)
                        }
                    }
                }));
                t.editing.view.document.on("dragover", ((t, e) => {
                    e.preventDefault()
                }));
                e.on("change", (() => {
                    const n = e.differ.getChanges({includeChangesInGraveyard: true}).reverse();
                    const o = new Set;
                    for (const e of n) {
                        if (e.type == "insert" && e.name != "$text") {
                            const n = e.position.nodeAfter;
                            const r = e.position.root.rootName == "$graveyard";
                            for (const e of bO(t, n)) {
                                const t = e.getAttribute("uploadId");
                                if (!t) {
                                    continue
                                }
                                const n = i.loaders.get(t);
                                if (!n) {
                                    continue
                                }
                                if (r) {
                                    if (!o.has(t)) {
                                        n.abort()
                                    }
                                } else {
                                    o.add(t);
                                    this._uploadImageElements.set(t, e);
                                    if (n.status == "idle") {
                                        this._readAndUpload(n)
                                    }
                                }
                            }
                        }
                    }
                }));
                this.on("uploadComplete", ((t, {imageElement: e, data: n}) => {
                    const i = n.urls ? n.urls : n;
                    this.editor.model.change((t => {
                        t.setAttribute("src", i.default, e);
                        this._parseAndSetSrcsetAttributeOnImage(i, e, t)
                    }))
                }), {priority: "low"})
            }

            afterInit() {
                const t = this.editor.model.schema;
                if (this.editor.plugins.has("ImageBlockEditing")) {
                    t.extend("imageBlock", {allowAttributes: ["uploadId", "uploadStatus"]})
                }
                if (this.editor.plugins.has("ImageInlineEditing")) {
                    t.extend("imageInline", {allowAttributes: ["uploadId", "uploadStatus"]})
                }
            }

            _readAndUpload(t) {
                const e = this.editor;
                const n = e.model;
                const i = e.locale.t;
                const o = e.plugins.get(KS);
                const s = e.plugins.get(Vy);
                const a = e.plugins.get("ImageUtils");
                const l = this._uploadImageElements;
                n.enqueueChange({isUndoable: false}, (e => {
                    e.setAttribute("uploadStatus", "reading", l.get(t.id))
                }));
                return t.read().then((() => {
                    const i = t.upload();
                    const o = l.get(t.id);
                    if (r.isSafari) {
                        const t = e.editing.mapper.toViewElement(o);
                        const n = a.findViewImgElement(t);
                        e.editing.view.once("render", (() => {
                            if (!n.parent) {
                                return
                            }
                            const t = e.editing.view.domConverter.mapViewToDom(n.parent);
                            if (!t) {
                                return
                            }
                            const i = t.style.display;
                            t.style.display = "none";
                            t._ckHack = t.offsetHeight;
                            t.style.display = i
                        }))
                    }
                    n.enqueueChange({isUndoable: false}, (t => {
                        t.setAttribute("uploadStatus", "uploading", o)
                    }));
                    return i
                })).then((e => {
                    n.enqueueChange({isUndoable: false}, (n => {
                        const i = l.get(t.id);
                        n.setAttribute("uploadStatus", "complete", i);
                        this.fire("uploadComplete", {data: e, imageElement: i})
                    }));
                    c()
                })).catch((e => {
                    if (t.status !== "error" && t.status !== "aborted") {
                        throw e
                    }
                    if (t.status == "error" && e) {
                        s.showWarning(e, {title: i("Upload failed"), namespace: "upload"})
                    }
                    n.enqueueChange({isUndoable: false}, (e => {
                        e.remove(l.get(t.id))
                    }));
                    c()
                }));

                function c() {
                    n.enqueueChange({isUndoable: false}, (e => {
                        const n = l.get(t.id);
                        e.removeAttribute("uploadId", n);
                        e.removeAttribute("uploadStatus", n);
                        l.delete(t.id)
                    }));
                    o.destroyLoader(t)
                }
            }

            _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                let i = 0;
                const o = Object.keys(t).filter((t => {
                    const e = parseInt(t, 10);
                    if (!isNaN(e)) {
                        i = Math.max(i, e);
                        return true
                    }
                })).map((e => `${t[e]} ${e}w`)).join(", ");
                if (o != "") {
                    n.setAttribute("srcset", {data: o, width: i}, e)
                }
            }
        }

        function pO(t) {
            return Array.from(t.types).includes("text/html") && t.getData("text/html") !== ""
        }

        function bO(t, e) {
            const n = t.plugins.get("ImageUtils");
            return Array.from(t.model.createRangeOn(e)).filter((t => n.isImage(t.item))).map((t => t.item))
        }

        class kO extends Ac {
            static get pluginName() {
                return "ImageUpload"
            }

            static get requires() {
                return [mO, WL, eO]
            }
        }

        class wO extends Ac {
            static get pluginName() {
                return "IndentEditing"
            }

            init() {
                const t = this.editor;
                t.commands.add("indent", new xc(t));
                t.commands.add("outdent", new xc(t))
            }
        }

        const _O = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
        const AO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';

        class CO extends Ac {
            static get pluginName() {
                return "IndentUI"
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.t;
                const i = e.uiLanguageDirection == "ltr" ? _O : AO;
                const o = e.uiLanguageDirection == "ltr" ? AO : _O;
                this._defineButton("indent", n("Increase indent"), i);
                this._defineButton("outdent", n("Decrease indent"), o)
            }

            _defineButton(t, e, n) {
                const i = this.editor;
                i.ui.componentFactory.add(t, (o => {
                    const r = i.commands.get(t);
                    const s = new LC(o);
                    s.set({label: e, icon: n, tooltip: true});
                    s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
                    this.listenTo(s, "execute", (() => {
                        i.execute(t);
                        i.editing.view.focus()
                    }));
                    return s
                }))
            }
        }

        class vO extends Ac {
            static get pluginName() {
                return "Indent"
            }

            static get requires() {
                return [wO, CO]
            }
        }

        class yO extends vc {
            constructor(t, e) {
                super(t);
                this._indentBehavior = e
            }

            refresh() {
                const t = this.editor;
                const e = t.model;
                const n = sc(e.document.selection.getSelectedBlocks());
                if (!n || !e.schema.checkAttribute(n, "blockIndent")) {
                    this.isEnabled = false;
                    return
                }
                this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute("blockIndent"))
            }

            execute() {
                const t = this.editor.model;
                const e = xO(t);
                t.change((t => {
                    for (const n of e) {
                        const e = n.getAttribute("blockIndent");
                        const i = this._indentBehavior.getNextIndent(e);
                        if (i) {
                            t.setAttribute("blockIndent", i, n)
                        } else {
                            t.removeAttribute("blockIndent", n)
                        }
                    }
                }))
            }
        }

        function xO(t) {
            const e = t.document.selection;
            const n = t.schema;
            const i = Array.from(e.getSelectedBlocks());
            return i.filter((t => n.checkAttribute(t, "blockIndent")))
        }

        class EO {
            constructor(t) {
                this.isForward = t.direction === "forward";
                this.offset = t.offset;
                this.unit = t.unit
            }

            checkEnabled(t) {
                const e = parseFloat(t || 0);
                return this.isForward || e > 0
            }

            getNextIndent(t) {
                const e = parseFloat(t || 0);
                const n = !t || t.endsWith(this.unit);
                if (!n) {
                    return this.isForward ? this.offset + this.unit : undefined
                }
                const i = this.isForward ? this.offset : -this.offset;
                const o = e + i;
                return o > 0 ? o + this.unit : undefined
            }
        }

        class SO {
            constructor(t) {
                this.isForward = t.direction === "forward";
                this.classes = t.classes
            }

            checkEnabled(t) {
                const e = this.classes.indexOf(t);
                if (this.isForward) {
                    return e < this.classes.length - 1
                } else {
                    return e >= 0
                }
            }

            getNextIndent(t) {
                const e = this.classes.indexOf(t);
                const n = this.isForward ? 1 : -1;
                return this.classes[e + n]
            }
        }

        const DO = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];

        class TO extends Ac {
            constructor(t) {
                super(t);
                t.config.define("indentBlock", {offset: 40, unit: "px"})
            }

            static get pluginName() {
                return "IndentBlock"
            }

            init() {
                const t = this.editor;
                const e = t.config.get("indentBlock");
                const n = !e.classes || !e.classes.length;
                const i = Object.assign({direction: "forward"}, e);
                const o = Object.assign({direction: "backward"}, e);
                if (n) {
                    t.data.addStyleProcessorRules(T_);
                    this._setupConversionUsingOffset(t.conversion);
                    t.commands.add("indentBlock", new yO(t, new EO(i)));
                    t.commands.add("outdentBlock", new yO(t, new EO(o)))
                } else {
                    this._setupConversionUsingClasses(e.classes);
                    t.commands.add("indentBlock", new yO(t, new SO(i)));
                    t.commands.add("outdentBlock", new yO(t, new SO(o)))
                }
            }

            afterInit() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.commands.get("indent");
                const i = t.commands.get("outdent");
                const o = t.config.get("heading.options");
                const r = o && o.map((t => t.model));
                const s = r || DO;
                s.forEach((t => {
                    if (e.isRegistered(t)) {
                        e.extend(t, {allowAttributes: "blockIndent"})
                    }
                }));
                e.setAttributeProperties("blockIndent", {isFormatting: true});
                n.registerChildCommand(t.commands.get("indentBlock"));
                i.registerChildCommand(t.commands.get("outdentBlock"))
            }

            _setupConversionUsingOffset() {
                const t = this.editor.conversion;
                const e = this.editor.locale;
                const n = e.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
                t.for("upcast").attributeToAttribute({
                    view: {styles: {[n]: /[\s\S]+/}},
                    model: {key: "blockIndent", value: t => t.getStyle(n)}
                });
                t.for("downcast").attributeToAttribute({
                    model: "blockIndent",
                    view: t => ({key: "style", value: {[n]: t}})
                })
            }

            _setupConversionUsingClasses(t) {
                const e = {model: {key: "blockIndent", values: []}, view: {}};
                for (const n of t) {
                    e.model.values.push(n);
                    e.view[n] = {key: "class", value: [n]}
                }
                this.editor.conversion.attributeToAttribute(e)
            }
        }

        const BO = "italic";

        class PO extends Ac {
            static get pluginName() {
                return "ItalicEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: BO});
                t.model.schema.setAttributeProperties(BO, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: BO,
                    view: "i",
                    upcastAlso: ["em", {styles: {"font-style": "italic"}}]
                });
                t.commands.add(BO, new AD(t, BO));
                t.keystrokes.set("CTRL+I", BO)
            }
        }

        const IO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
        const RO = "italic";

        class zO extends Ac {
            static get pluginName() {
                return "ItalicUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(RO, (n => {
                    const i = t.commands.get(RO);
                    const o = new LC(n);
                    o.set({label: e("Italic"), icon: IO, keystroke: "CTRL+I", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(RO);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class VO extends Ac {
            static get requires() {
                return [PO, zO]
            }

            static get pluginName() {
                return "Italic"
            }
        }

        class FO {
            constructor() {
                this._definitions = new Set
            }

            get length() {
                return this._definitions.size
            }

            add(t) {
                if (Array.isArray(t)) {
                    t.forEach((t => this._definitions.add(t)))
                } else {
                    this._definitions.add(t)
                }
            }

            getDispatcher() {
                return t => {
                    t.on("attribute:linkHref", ((t, e, n) => {
                        if (!n.consumable.test(e.item, "attribute:linkHref")) {
                            return
                        }
                        if (!(e.item.is("selection") || n.schema.isInline(e.item))) {
                            return
                        }
                        const i = n.writer;
                        const o = i.document.selection;
                        for (const t of this._definitions) {
                            const r = i.createAttributeElement("a", t.attributes, {priority: 5});
                            if (t.classes) {
                                i.addClass(t.classes, r)
                            }
                            for (const e in t.styles) {
                                i.setStyle(e, t.styles[e], r)
                            }
                            i.setCustomProperty("link", true, r);
                            if (t.callback(e.attributeNewValue)) {
                                if (e.item.is("selection")) {
                                    i.wrap(o.getFirstRange(), r)
                                } else {
                                    i.wrap(n.mapper.toViewRange(e.range), r)
                                }
                            } else {
                                i.unwrap(n.mapper.toViewRange(e.range), r)
                            }
                        }
                    }), {priority: "high"})
                }
            }

            getDispatcherForLinkedImage() {
                return t => {
                    t.on("attribute:linkHref:imageBlock", ((t, e, {writer: n, mapper: i}) => {
                        const o = i.toViewElement(e.item);
                        const r = Array.from(o.getChildren()).find((t => t.name === "a"));
                        for (const t of this._definitions) {
                            const i = dc(t.attributes);
                            if (t.callback(e.attributeNewValue)) {
                                for (const [t, e] of i) {
                                    if (t === "class") {
                                        n.addClass(e, r)
                                    } else {
                                        n.setAttribute(t, e, r)
                                    }
                                }
                                if (t.classes) {
                                    n.addClass(t.classes, r)
                                }
                                for (const e in t.styles) {
                                    n.setStyle(e, t.styles[e], r)
                                }
                            } else {
                                for (const [t, e] of i) {
                                    if (t === "class") {
                                        n.removeClass(e, r)
                                    } else {
                                        n.removeAttribute(t, r)
                                    }
                                }
                                if (t.classes) {
                                    n.removeClass(t.classes, r)
                                }
                                for (const e in t.styles) {
                                    n.removeStyle(e, r)
                                }
                            }
                        }
                    }))
                }
            }
        }

        class LO extends vc {
            constructor(t) {
                super(t);
                this.manualDecorators = new rc;
                this.automaticDecorators = new FO
            }

            restoreManualDecoratorStates() {
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = e.getSelectedElement() || sc(e.getSelectedBlocks());
                if (zS(n, t.schema)) {
                    this.value = n.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.value = e.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref")
                }
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }

            execute(t, e = {}) {
                const n = this.editor.model;
                const i = n.document.selection;
                const o = [];
                const r = [];
                for (const t in e) {
                    if (e[t]) {
                        o.push(t)
                    } else {
                        r.push(t)
                    }
                }
                n.change((e => {
                    if (i.isCollapsed) {
                        const s = i.getFirstPosition();
                        if (i.hasAttribute("linkHref")) {
                            const a = EE(s, "linkHref", i.getAttribute("linkHref"), n);
                            e.setAttribute("linkHref", t, a);
                            o.forEach((t => {
                                e.setAttribute(t, true, a)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, a)
                            }));
                            e.setSelection(e.createPositionAfter(a.end.nodeBefore))
                        } else if (t !== "") {
                            const r = dc(i.getAttributes());
                            r.set("linkHref", t);
                            o.forEach((t => {
                                r.set(t, true)
                            }));
                            const {end: a} = n.insertContent(e.createText(t, r), s);
                            e.setSelection(a)
                        }
                        ["linkHref", ...o, ...r].forEach((t => {
                            e.removeSelectionAttribute(t)
                        }))
                    } else {
                        const s = n.schema.getValidRanges(i.getRanges(), "linkHref");
                        const a = [];
                        for (const t of i.getSelectedBlocks()) {
                            if (n.schema.checkAttribute(t, "linkHref")) {
                                a.push(e.createRangeOn(t))
                            }
                        }
                        const l = a.slice();
                        for (const t of s) {
                            if (this._isRangeToUpdate(t, a)) {
                                l.push(t)
                            }
                        }
                        for (const n of l) {
                            e.setAttribute("linkHref", t, n);
                            o.forEach((t => {
                                e.setAttribute(t, true, n)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, n)
                            }))
                        }
                    }
                }))
            }

            _getDecoratorStateFromModel(t) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = n.getSelectedElement();
                if (zS(i, e.schema)) {
                    return i.getAttribute(t)
                }
                return n.getAttribute(t)
            }

            _isRangeToUpdate(t, e) {
                for (const n of e) {
                    if (n.containsRange(t)) {
                        return false
                    }
                }
                return true
            }
        }

        class OO extends vc {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = e.getSelectedElement();
                if (zS(n, t.schema)) {
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref")
                }
            }

            execute() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                const i = t.commands.get("link");
                e.change((t => {
                    const o = n.isCollapsed ? [EE(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref");
                    for (const e of o) {
                        t.removeAttribute("linkHref", e);
                        if (i) {
                            for (const n of i.manualDecorators) {
                                t.removeAttribute(n.id, e)
                            }
                        }
                    }
                }))
            }
        }

        class NO {
            constructor({id: t, label: e, attributes: n, classes: i, styles: o, defaultValue: r}) {
                this.id = t;
                this.set("value");
                this.defaultValue = r;
                this.label = e;
                this.attributes = n;
                this.classes = i;
                this.styles = o
            }

            _createPattern() {
                return {attributes: this.attributes, classes: this.classes, styles: this.styles}
            }
        }

        A(NO, dt);
        var MO = n(399);
        var HO = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        HO.insert = "head";
        HO.singleton = true;
        var WO = Bc()(MO.Z, HO);
        const qO = MO.Z.locals || {};
        const jO = "ck-link_selected";
        const $O = "automatic";
        const UO = "manual";
        const GO = /^(https?:)?\/\//;

        class KO extends Ac {
            static get pluginName() {
                return "LinkEditing"
            }

            static get requires() {
                return [sE, jx, NP]
            }

            constructor(t) {
                super(t);
                t.config.define("link", {addTargetToExternalLinks: false})
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: "linkHref"});
                t.conversion.for("dataDowncast").attributeToElement({model: "linkHref", view: TS});
                t.conversion.for("editingDowncast").attributeToElement({
                    model: "linkHref",
                    view: (t, e) => TS(BS(t), e)
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "a", attributes: {href: true}},
                    model: {key: "linkHref", value: t => t.getAttribute("href")}
                });
                t.commands.add("link", new LO(t));
                t.commands.add("unlink", new OO(t));
                const e = IS(t.t, RS(t.config.get("link.decorators")));
                this._enableAutomaticDecorators(e.filter((t => t.mode === $O)));
                this._enableManualDecorators(e.filter((t => t.mode === UO)));
                const n = t.plugins.get(sE);
                n.registerAttribute("linkHref");
                DE(t, "linkHref", "a", jO);
                this._enableLinkOpen();
                this._enableInsertContentSelectionAttributesFixer();
                this._enableClickingAfterLink();
                this._enableTypingOverLink();
                this._handleDeleteContentAfterLink()
            }

            _enableAutomaticDecorators(t) {
                const e = this.editor;
                const n = e.commands.get("link");
                const i = n.automaticDecorators;
                if (e.config.get("link.addTargetToExternalLinks")) {
                    i.add({
                        id: "linkIsExternal",
                        mode: $O,
                        callback: t => GO.test(t),
                        attributes: {target: "_blank", rel: "noopener noreferrer"}
                    })
                }
                i.add(t);
                if (i.length) {
                    e.conversion.for("downcast").add(i.getDispatcher())
                }
            }

            _enableManualDecorators(t) {
                if (!t.length) {
                    return
                }
                const e = this.editor;
                const n = e.commands.get("link");
                const i = n.manualDecorators;
                t.forEach((t => {
                    e.model.schema.extend("$text", {allowAttributes: t.id});
                    t = new NO(t);
                    i.add(t);
                    e.conversion.for("downcast").attributeToElement({
                        model: t.id,
                        view: (e, {writer: n, schema: i}, {item: o}) => {
                            if (!(o.is("selection") || i.isInline(o))) {
                                return
                            }
                            if (e) {
                                const e = n.createAttributeElement("a", t.attributes, {priority: 5});
                                if (t.classes) {
                                    n.addClass(t.classes, e)
                                }
                                for (const i in t.styles) {
                                    n.setStyle(i, t.styles[i], e)
                                }
                                n.setCustomProperty("link", true, e);
                                return e
                            }
                        }
                    });
                    e.conversion.for("upcast").elementToAttribute({
                        view: {name: "a", ...t._createPattern()},
                        model: {key: t.id}
                    })
                }))
            }

            _enableLinkOpen() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this.listenTo(n, "click", ((t, e) => {
                    const n = r.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey;
                    if (!n) {
                        return
                    }
                    let i = e.domTarget;
                    if (i.tagName.toLowerCase() != "a") {
                        i = i.closest("a")
                    }
                    if (!i) {
                        return
                    }
                    const o = i.getAttribute("href");
                    if (!o) {
                        return
                    }
                    t.stop();
                    e.preventDefault();
                    OS(o)
                }), {context: "$capture"});
                this.listenTo(n, "keydown", ((e, n) => {
                    const i = t.commands.get("link").value;
                    const o = i && n.keyCode === Ol.enter && n.altKey;
                    if (!o) {
                        return
                    }
                    e.stop();
                    OS(i)
                }))
            }

            _enableInsertContentSelectionAttributesFixer() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                this.listenTo(e, "insertContent", (() => {
                    const t = n.anchor.nodeBefore;
                    const i = n.anchor.nodeAfter;
                    if (!n.hasAttribute("linkHref")) {
                        return
                    }
                    if (!t) {
                        return
                    }
                    if (!t.hasAttribute("linkHref")) {
                        return
                    }
                    if (i && i.hasAttribute("linkHref")) {
                        return
                    }
                    e.change((t => {
                        ZO(t, QO(e.schema))
                    }))
                }), {priority: "low"})
            }

            _enableClickingAfterLink() {
                const t = this.editor;
                const e = t.model;
                t.editing.view.addObserver(Nw);
                let n = false;
                this.listenTo(t.editing.view.document, "mousedown", (() => {
                    n = true
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (() => {
                    if (!n) {
                        return
                    }
                    n = false;
                    const t = e.document.selection;
                    if (!t.isCollapsed) {
                        return
                    }
                    if (!t.hasAttribute("linkHref")) {
                        return
                    }
                    const i = t.getFirstPosition();
                    const o = EE(i, "linkHref", t.getAttribute("linkHref"), e);
                    if (i.isTouching(o.start) || i.isTouching(o.end)) {
                        e.change((t => {
                            ZO(t, QO(e.schema))
                        }))
                    }
                }))
            }

            _enableTypingOverLink() {
                const t = this.editor;
                const e = t.editing.view;
                let n;
                let i;
                this.listenTo(e.document, "delete", (() => {
                    i = true
                }), {priority: "high"});
                this.listenTo(t.model, "deleteContent", (() => {
                    const e = t.model.document.selection;
                    if (e.isCollapsed) {
                        return
                    }
                    if (i) {
                        i = false;
                        return
                    }
                    if (!YO(t)) {
                        return
                    }
                    if (JO(t.model)) {
                        n = e.getAttributes()
                    }
                }), {priority: "high"});
                this.listenTo(t.model, "insertContent", ((e, [o]) => {
                    i = false;
                    if (!YO(t)) {
                        return
                    }
                    if (!n) {
                        return
                    }
                    t.model.change((t => {
                        for (const [e, i] of n) {
                            t.setAttribute(e, i, o)
                        }
                    }));
                    n = null
                }), {priority: "high"})
            }

            _handleDeleteContentAfterLink() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = t.editing.view;
                let o = false;
                let r = false;
                this.listenTo(i.document, "delete", ((t, e) => {
                    r = e.direction === "backward"
                }), {priority: "high"});
                this.listenTo(e, "deleteContent", (() => {
                    o = false;
                    const t = n.getFirstPosition();
                    const i = n.getAttribute("linkHref");
                    if (!i) {
                        return
                    }
                    const r = EE(t, "linkHref", i, e);
                    o = r.containsPosition(t) || r.end.isEqual(t)
                }), {priority: "high"});
                this.listenTo(e, "deleteContent", (() => {
                    if (!r) {
                        return
                    }
                    r = false;
                    if (o) {
                        return
                    }
                    t.model.enqueueChange((t => {
                        ZO(t, QO(e.schema))
                    }))
                }), {priority: "low"})
            }
        }

        function ZO(t, e) {
            t.removeSelectionAttribute("linkHref");
            for (const n of e) {
                t.removeSelectionAttribute(n)
            }
        }

        function JO(t) {
            const e = t.document.selection;
            const n = e.getFirstPosition();
            const i = e.getLastPosition();
            const o = n.nodeAfter;
            if (!o) {
                return false
            }
            if (!o.is("$text")) {
                return false
            }
            if (!o.hasAttribute("linkHref")) {
                return false
            }
            const r = i.textNode || i.nodeBefore;
            if (o === r) {
                return true
            }
            const s = EE(n, "linkHref", o.getAttribute("linkHref"), t);
            return s.containsRange(t.createRange(n, i), true)
        }

        function YO(t) {
            const e = t.model.change((t => t.batch));
            return e.isTyping
        }

        function QO(t) {
            const e = t.getDefinition("$text").allowAttributes;
            return e.filter((t => t.startsWith("link")))
        }

        var XO = n(4827);
        var tN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        tN.insert = "head";
        tN.singleton = true;
        var eN = Bc()(XO.Z, tN);
        const nN = XO.Z.locals || {};

        class iN extends pA {
            constructor(t, e) {
                super(t);
                const n = t.t;
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.urlInputView = this._createUrlInput();
                this.saveButtonView = this._createButton(n("Save"), CC.check, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(n("Cancel"), CC.cancel, "ck-button-cancel", "cancel");
                this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e);
                this.children = this._createFormChildren(e.manualDecorators);
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                const i = ["ck", "ck-link-form", "ck-responsive-form"];
                if (e.manualDecorators.length) {
                    i.push("ck-link-form_layout-vertical", "ck-vertical-form")
                }
                this.setTemplate({tag: "form", attributes: {class: i, tabindex: "-1"}, children: this.children});
                yC(this)
            }

            getDecoratorSwitchesState() {
                return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => {
                    t[e.name] = e.isOn;
                    return t
                }), {})
            }

            render() {
                super.render();
                xC({view: this});
                const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createUrlInput() {
                const t = this.locale.t;
                const e = new Py(this.locale, Iy);
                e.label = t("Link URL");
                return e
            }

            _createButton(t, e, n, i) {
                const o = new LC(this.locale);
                o.set({label: t, icon: e, tooltip: true});
                o.extendTemplate({attributes: {class: n}});
                if (i) {
                    o.delegate("execute").to(this, i)
                }
                return o
            }

            _createManualDecoratorSwitches(t) {
                const e = this.createCollection();
                for (const n of t.manualDecorators) {
                    const i = new WC(this.locale);
                    i.set({name: n.id, label: n.label, withText: true});
                    i.bind("isOn").toMany([n, t], "value", ((t, e) => e === undefined && t === undefined ? n.defaultValue : t));
                    i.on("execute", (() => {
                        n.set("value", !i.isOn)
                    }));
                    e.add(i)
                }
                return e
            }

            _createFormChildren(t) {
                const e = this.createCollection();
                e.add(this.urlInputView);
                if (t.length) {
                    const t = new pA;
                    t.setTemplate({
                        tag: "ul",
                        children: this._manualDecoratorSwitches.map((t => ({
                            tag: "li",
                            children: [t],
                            attributes: {class: ["ck", "ck-list__item"]}
                        }))),
                        attributes: {class: ["ck", "ck-reset", "ck-list"]}
                    });
                    e.add(t)
                }
                e.add(this.saveButtonView);
                e.add(this.cancelButtonView);
                return e
            }
        }

        var oN = n(9465);
        var rN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        rN.insert = "head";
        rN.singleton = true;
        var sN = Bc()(oN.Z, rN);
        const aN = oN.Z.locals || {};
        const lN = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';

        class cN extends pA {
            constructor(t) {
                super(t);
                const e = t.t;
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.previewButtonView = this._createPreviewButton();
                this.unlinkButtonView = this._createButton(e("Unlink"), lN, "unlink");
                this.editButtonView = this._createButton(e("Edit link"), CC.pencil, "edit");
                this.set("href");
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1"},
                    children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                })
            }

            render() {
                super.render();
                const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createButton(t, e, n) {
                const i = new LC(this.locale);
                i.set({label: t, icon: e, tooltip: true});
                i.delegate("execute").to(this, n);
                return i
            }

            _createPreviewButton() {
                const t = new LC(this.locale);
                const e = this.bindTemplate;
                const n = this.t;
                t.set({withText: true, tooltip: n("Open link in new tab")});
                t.extendTemplate({
                    attributes: {
                        class: ["ck", "ck-link-actions__preview"],
                        href: e.to("href", (t => t && BS(t))),
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }
                });
                t.bind("label").to(this, "href", (t => t || n("This link has no URL")));
                t.bind("isEnabled").to(this, "href", (t => !!t));
                t.template.tag = "a";
                t.template.eventListeners = {};
                return t
            }
        }

        const dN = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
        const uN = "link-ui";

        class hN extends Ac {
            static get requires() {
                return [Ky]
            }

            static get pluginName() {
                return "LinkUI"
            }

            init() {
                const t = this.editor;
                t.editing.view.addObserver(Ow);
                this.actionsView = this._createActionsView();
                this.formView = this._createFormView();
                this._balloon = t.plugins.get(Ky);
                this._createToolbarLinkButton();
                this._enableUserBalloonInteractions();
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: uN,
                    view: {classes: ["ck-fake-link-selection"]}
                });
                t.conversion.for("editingDowncast").markerToElement({
                    model: uN,
                    view: {name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]}
                })
            }

            destroy() {
                super.destroy();
                this.formView.destroy()
            }

            _createActionsView() {
                const t = this.editor;
                const e = new cN(t.locale);
                const n = t.commands.get("link");
                const i = t.commands.get("unlink");
                e.bind("href").to(n, "value");
                e.editButtonView.bind("isEnabled").to(n);
                e.unlinkButtonView.bind("isEnabled").to(i);
                this.listenTo(e, "edit", (() => {
                    this._addFormView()
                }));
                this.listenTo(e, "unlink", (() => {
                    t.execute("unlink");
                    this._hideUI()
                }));
                e.keystrokes.set("Esc", ((t, e) => {
                    this._hideUI();
                    e()
                }));
                e.keystrokes.set(SS, ((t, e) => {
                    this._addFormView();
                    e()
                }));
                return e
            }

            _createFormView() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.config.get("link.defaultProtocol");
                const i = new iN(t.locale, e);
                i.urlInputView.fieldView.bind("value").to(e, "value");
                i.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t));
                i.saveButtonView.bind("isEnabled").to(e);
                this.listenTo(i, "submit", (() => {
                    const {value: e} = i.urlInputView.fieldView.element;
                    const o = FS(e, n);
                    t.execute("link", o, i.getDecoratorSwitchesState());
                    this._closeFormView()
                }));
                this.listenTo(i, "cancel", (() => {
                    this._closeFormView()
                }));
                i.keystrokes.set("Esc", ((t, e) => {
                    this._closeFormView();
                    e()
                }));
                return i
            }

            _createToolbarLinkButton() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.t;
                t.keystrokes.set(SS, ((t, n) => {
                    n();
                    if (e.isEnabled) {
                        this._showUI(true)
                    }
                }));
                t.ui.componentFactory.add("link", (t => {
                    const i = new LC(t);
                    i.isEnabled = true;
                    i.label = n("Link");
                    i.icon = dN;
                    i.keystroke = SS;
                    i.tooltip = true;
                    i.isToggleable = true;
                    i.bind("isEnabled").to(e, "isEnabled");
                    i.bind("isOn").to(e, "value", (t => !!t));
                    this.listenTo(i, "execute", (() => this._showUI(true)));
                    return i
                }))
            }

            _enableUserBalloonInteractions() {
                const t = this.editor.editing.view.document;
                this.listenTo(t, "click", (() => {
                    const t = this._getSelectedLinkElement();
                    if (t) {
                        this._showUI()
                    }
                }));
                this.editor.keystrokes.set("Tab", ((t, e) => {
                    if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                        this.actionsView.focus();
                        e()
                    }
                }), {priority: "high"});
                this.editor.keystrokes.set("Esc", ((t, e) => {
                    if (this._isUIVisible) {
                        this._hideUI();
                        e()
                    }
                }));
                vC({
                    emitter: this.formView,
                    activator: () => this._isUIInPanel,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideUI()
                })
            }

            _addActionsView() {
                if (this._areActionsInPanel) {
                    return
                }
                this._balloon.add({view: this.actionsView, position: this._getBalloonPositionData()})
            }

            _addFormView() {
                if (this._isFormInPanel) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("link");
                this.formView.disableCssTransitions();
                this._balloon.add({view: this.formView, position: this._getBalloonPositionData()});
                if (this._balloon.visibleView === this.formView) {
                    this.formView.urlInputView.fieldView.select()
                }
                this.formView.enableCssTransitions();
                this.formView.urlInputView.fieldView.element.value = e.value || ""
            }

            _closeFormView() {
                const t = this.editor.commands.get("link");
                t.restoreManualDecoratorStates();
                if (t.value !== undefined) {
                    this._removeFormView()
                } else {
                    this._hideUI()
                }
            }

            _removeFormView() {
                if (this._isFormInPanel) {
                    this.formView.saveButtonView.focus();
                    this._balloon.remove(this.formView);
                    this.editor.editing.view.focus();
                    this._hideFakeVisualSelection()
                }
            }

            _showUI(t = false) {
                if (!this._getSelectedLinkElement()) {
                    this._showFakeVisualSelection();
                    this._addActionsView();
                    if (t) {
                        this._balloon.showStack("main")
                    }
                    this._addFormView()
                } else {
                    if (this._areActionsVisible) {
                        this._addFormView()
                    } else {
                        this._addActionsView()
                    }
                    if (t) {
                        this._balloon.showStack("main")
                    }
                }
                this._startUpdatingUI()
            }

            _hideUI() {
                if (!this._isUIInPanel) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.stopListening(this._balloon, "change:visibleView");
                t.editing.view.focus();
                this._removeFormView();
                this._balloon.remove(this.actionsView);
                this._hideFakeVisualSelection()
            }

            _startUpdatingUI() {
                const t = this.editor;
                const e = t.editing.view.document;
                let n = this._getSelectedLinkElement();
                let i = r();
                const o = () => {
                    const t = this._getSelectedLinkElement();
                    const e = r();
                    if (n && !t || !n && e !== i) {
                        this._hideUI()
                    } else if (this._isUIVisible) {
                        this._balloon.updatePosition(this._getBalloonPositionData())
                    }
                    n = t;
                    i = e
                };

                function r() {
                    return e.selection.focus.getAncestors().reverse().find((t => t.is("element")))
                }

                this.listenTo(t.ui, "update", o);
                this.listenTo(this._balloon, "change:visibleView", o)
            }

            get _isFormInPanel() {
                return this._balloon.hasView(this.formView)
            }

            get _areActionsInPanel() {
                return this._balloon.hasView(this.actionsView)
            }

            get _areActionsVisible() {
                return this._balloon.visibleView === this.actionsView
            }

            get _isUIInPanel() {
                return this._isFormInPanel || this._areActionsInPanel
            }

            get _isUIVisible() {
                const t = this._balloon.visibleView;
                return t == this.formView || this._areActionsVisible
            }

            _getBalloonPositionData() {
                const t = this.editor.editing.view;
                const e = this.editor.model;
                const n = t.document;
                let i = null;
                if (e.markers.has(uN)) {
                    const e = Array.from(this.editor.editing.mapper.markerNameToElements(uN));
                    const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
                    i = t.domConverter.viewRangeToDom(n)
                } else {
                    i = () => {
                        const e = this._getSelectedLinkElement();
                        return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange())
                    }
                }
                return {target: i}
            }

            _getSelectedLinkElement() {
                const t = this.editor.editing.view;
                const e = t.document.selection;
                const n = e.getSelectedElement();
                if (e.isCollapsed || n && GP(n)) {
                    return fN(e.getFirstPosition())
                } else {
                    const n = e.getFirstRange().getTrimmed();
                    const i = fN(n.start);
                    const o = fN(n.end);
                    if (!i || i != o) {
                        return null
                    }
                    if (t.createRangeIn(i).getTrimmed().isEqual(n)) {
                        return i
                    } else {
                        return null
                    }
                }
            }

            _showFakeVisualSelection() {
                const t = this.editor.model;
                t.change((e => {
                    const n = t.document.selection.getFirstRange();
                    if (t.markers.has(uN)) {
                        e.updateMarker(uN, {range: n})
                    } else {
                        if (n.start.isAtEnd) {
                            const i = n.start.getLastMatchingPosition((({item: e}) => !t.schema.isContent(e)), {boundaries: n});
                            e.addMarker(uN, {usingOperation: false, affectsData: false, range: e.createRange(i, n.end)})
                        } else {
                            e.addMarker(uN, {usingOperation: false, affectsData: false, range: n})
                        }
                    }
                }))
            }

            _hideFakeVisualSelection() {
                const t = this.editor.model;
                if (t.markers.has(uN)) {
                    t.change((t => {
                        t.removeMarker(uN)
                    }))
                }
            }
        }

        function fN(t) {
            return t.getAncestors().find((t => DS(t)))
        }

        class gN extends Ac {
            static get requires() {
                return [KO, hN, WS]
            }

            static get pluginName() {
                return "Link"
            }
        }

        const mN = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
        const pN = "removeFormat";

        class bN extends Ac {
            static get pluginName() {
                return "RemoveFormatUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(pN, (n => {
                    const i = t.commands.get(pN);
                    const o = new LC(n);
                    o.set({label: e("Remove Format"), icon: mN, tooltip: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(pN);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class kN extends vc {
            refresh() {
                const t = this.editor.model;
                this.isEnabled = !!sc(this._getFormattingItems(t.document.selection, t.schema))
            }

            execute() {
                const t = this.editor.model;
                const e = t.schema;
                t.change((n => {
                    for (const i of this._getFormattingItems(t.document.selection, e)) {
                        if (i.is("selection")) {
                            for (const t of this._getFormattingAttributes(i, e)) {
                                n.removeSelectionAttribute(t)
                            }
                        } else {
                            const t = n.createRangeOn(i);
                            for (const o of this._getFormattingAttributes(i, e)) {
                                n.removeAttribute(o, t)
                            }
                        }
                    }
                }))
            }

            * _getFormattingItems(t, e) {
                const n = t => !!sc(this._getFormattingAttributes(t, e));
                for (const i of t.getRanges()) {
                    for (const t of i.getItems()) {
                        if (!e.isBlock(t) && n(t)) {
                            yield t
                        }
                    }
                }
                for (const e of t.getSelectedBlocks()) {
                    if (n(e)) {
                        yield e
                    }
                }
                if (n(t)) {
                    yield t
                }
            }

            * _getFormattingAttributes(t, e) {
                for (const [n] of t.getAttributes()) {
                    const t = e.getAttributeProperties(n);
                    if (t && t.isFormatting) {
                        yield n
                    }
                }
            }
        }

        class wN extends Ac {
            static get pluginName() {
                return "RemoveFormatEditing"
            }

            init() {
                const t = this.editor;
                t.commands.add("removeFormat", new kN(t))
            }
        }

        class _N extends Ac {
            static get requires() {
                return [wN, bN]
            }

            static get pluginName() {
                return "RemoveFormat"
            }
        }

        class AN extends by {
            constructor(t, e) {
                super(t);
                const n = t.t;
                this.set("class", "ck-special-characters-navigation");
                this.groupDropdownView = this._createGroupDropdown(e);
                this.groupDropdownView.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw";
                this.label = n("Special characters");
                this.children.add(this.groupDropdownView)
            }

            get currentGroupName() {
                return this.groupDropdownView.value
            }

            focus() {
                this.groupDropdownView.focus()
            }

            _createGroupDropdown(t) {
                const e = this.locale;
                const n = e.t;
                const i = qv(e);
                const o = this._getCharacterGroupListItemDefinitions(i, t);
                i.set("value", o.first.model.label);
                i.buttonView.bind("label").to(i, "value");
                i.buttonView.set({
                    isOn: false,
                    withText: true,
                    tooltip: n("Character categories"),
                    class: ["ck-dropdown__button_label-width_auto"]
                });
                i.on("execute", (t => {
                    i.value = t.source.label
                }));
                i.delegate("execute").to(this);
                $v(i, o);
                return i
            }

            _getCharacterGroupListItemDefinitions(t, e) {
                const n = new rc;
                for (const i of e) {
                    const e = {type: "button", model: new Fy({label: i, withText: true})};
                    e.model.bind("isOn").to(t, "value", (t => t === e.model.label));
                    n.add(e)
                }
                return n
            }
        }

        var CN = n(4046);
        var vN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        vN.insert = "head";
        vN.singleton = true;
        var yN = Bc()(CN.Z, vN);
        const xN = CN.Z.locals || {};

        class EN extends pA {
            constructor(t) {
                super(t);
                this.tiles = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck", "ck-character-grid__tiles"]},
                        children: this.tiles
                    }],
                    attributes: {class: ["ck", "ck-character-grid"]}
                });
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                EC({
                    keystrokeHandler: this.keystrokes,
                    focusTracker: this.focusTracker,
                    gridItems: this.tiles,
                    numberOfColumns: () => Xa.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length,
                    uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                })
            }

            createTile(t, e) {
                const n = new LC(this.locale);
                n.set({label: t, withText: true, class: "ck-character-grid__tile"});
                n.extendTemplate({
                    attributes: {title: e},
                    on: {mouseover: n.bindTemplate.to("mouseover"), focus: n.bindTemplate.to("focus")}
                });
                n.on("mouseover", (() => {
                    this.fire("tileHover", {name: e, character: t})
                }));
                n.on("focus", (() => {
                    this.fire("tileFocus", {name: e, character: t})
                }));
                n.on("execute", (() => {
                    this.fire("execute", {name: e, character: t})
                }));
                return n
            }

            render() {
                super.render();
                for (const t of this.tiles) {
                    this.focusTracker.add(t.element)
                }
                this.tiles.on("change", ((t, {added: e, removed: n}) => {
                    if (e.length > 0) {
                        for (const t of e) {
                            this.focusTracker.add(t.element)
                        }
                    }
                    if (n.length > 0) {
                        for (const t of n) {
                            this.focusTracker.remove(t.element)
                        }
                    }
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this.tiles.get(0).focus()
            }
        }

        var SN = n(4779);
        var DN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        DN.insert = "head";
        DN.singleton = true;
        var TN = Bc()(SN.Z, DN);
        const BN = SN.Z.locals || {};

        class PN extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("character", null);
                this.set("name", null);
                this.bind("code").to(this, "character", IN);
                this.setTemplate({
                    tag: "div",
                    children: [{
                        tag: "span",
                        attributes: {class: ["ck-character-info__name"]},
                        children: [{text: e.to("name", (t => t ? t : "​"))}]
                    }, {
                        tag: "span",
                        attributes: {class: ["ck-character-info__code"]},
                        children: [{text: e.to("code")}]
                    }],
                    attributes: {class: ["ck", "ck-character-info"]}
                })
            }
        }

        function IN(t) {
            if (t === null) {
                return ""
            }
            const e = t.codePointAt(0).toString(16);
            return "U+" + ("0000" + e).slice(-4)
        }

        class RN extends pA {
            constructor(t, e, n, i) {
                super(t);
                this.items = this.createCollection();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this._focusCycler = new hv({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.navigationView = e;
                this.gridView = n;
                this.infoView = i;
                this.setTemplate({
                    tag: "div",
                    children: [this.navigationView, this.gridView, this.infoView],
                    attributes: {tabindex: "-1"}
                });
                this.items.add(this.navigationView.groupDropdownView.buttonView);
                this.items.add(this.gridView)
            }

            render() {
                super.render();
                this.focusTracker.add(this.navigationView.groupDropdownView.buttonView.element);
                this.focusTracker.add(this.gridView.element);
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this.navigationView.focus()
            }
        }

        const zN = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
        var VN = n(8170);
        var FN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        FN.insert = "head";
        FN.singleton = true;
        var LN = Bc()(VN.Z, FN);
        const ON = VN.Z.locals || {};
        const NN = "All";

        class MN extends Ac {
            static get requires() {
                return [iE]
            }

            static get pluginName() {
                return "SpecialCharacters"
            }

            constructor(t) {
                super(t);
                this._characters = new Map;
                this._groups = new Map
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = t.commands.get("input");
                t.ui.componentFactory.add("specialCharacters", (i => {
                    const o = qv(i);
                    let r;
                    o.buttonView.set({label: e("Special characters"), icon: zN, tooltip: true});
                    o.bind("isEnabled").to(n);
                    o.on("execute", ((e, n) => {
                        t.execute("insertText", {text: n.character});
                        t.editing.view.focus()
                    }));
                    o.on("change:isOpen", (() => {
                        if (!r) {
                            r = this._createDropdownPanelContent(i, o);
                            const t = new RN(i, r.navigationView, r.gridView, r.infoView);
                            o.panelView.children.add(t)
                        }
                        r.infoView.set({character: null, name: null})
                    }));
                    return o
                }))
            }

            addItems(t, e) {
                if (t === NN) {
                    throw new P(`special-character-invalid-group-name: The name "${NN}" is reserved and cannot be used.`)
                }
                const n = this._getGroup(t);
                for (const t of e) {
                    n.add(t.title);
                    this._characters.set(t.title, t.character)
                }
            }

            getGroups() {
                return this._groups.keys()
            }

            getCharactersForGroup(t) {
                if (t === NN) {
                    return new Set(this._characters.keys())
                }
                return this._groups.get(t)
            }

            getCharacter(t) {
                return this._characters.get(t)
            }

            _getGroup(t) {
                if (!this._groups.has(t)) {
                    this._groups.set(t, new Set)
                }
                return this._groups.get(t)
            }

            _updateGrid(t, e) {
                e.tiles.clear();
                const n = this.getCharactersForGroup(t);
                for (const t of n) {
                    const n = this.getCharacter(t);
                    e.tiles.add(e.createTile(n, t))
                }
            }

            _createDropdownPanelContent(t, e) {
                const n = [...this.getGroups()];
                n.unshift(NN);
                const i = new AN(t, n);
                const o = new EN(t);
                const r = new PN(t);
                o.delegate("execute").to(e);
                o.on("tileHover", ((t, e) => {
                    r.set(e)
                }));
                o.on("tileFocus", ((t, e) => {
                    r.set(e)
                }));
                i.on("execute", (() => {
                    this._updateGrid(i.currentGroupName, o)
                }));
                this._updateGrid(i.currentGroupName, o);
                return {navigationView: i, gridView: o, infoView: r}
            }
        }

        class HN extends Ac {
            static get pluginName() {
                return "SpecialCharactersArrows"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Arrows", [{
                    title: e("leftwards simple arrow"),
                    character: "←"
                }, {title: e("rightwards simple arrow"), character: "→"}, {
                    title: e("upwards simple arrow"),
                    character: "↑"
                }, {title: e("downwards simple arrow"), character: "↓"}, {
                    title: e("leftwards double arrow"),
                    character: "⇐"
                }, {title: e("rightwards double arrow"), character: "⇒"}, {
                    title: e("upwards double arrow"),
                    character: "⇑"
                }, {title: e("downwards double arrow"), character: "⇓"}, {
                    title: e("leftwards dashed arrow"),
                    character: "⇠"
                }, {title: e("rightwards dashed arrow"), character: "⇢"}, {
                    title: e("upwards dashed arrow"),
                    character: "⇡"
                }, {title: e("downwards dashed arrow"), character: "⇣"}, {
                    title: e("leftwards arrow to bar"),
                    character: "⇤"
                }, {title: e("rightwards arrow to bar"), character: "⇥"}, {
                    title: e("upwards arrow to bar"),
                    character: "⤒"
                }, {title: e("downwards arrow to bar"), character: "⤓"}, {
                    title: e("up down arrow with base"),
                    character: "↨"
                }, {
                    title: e("back with leftwards arrow above"),
                    character: "🔙"
                }, {
                    title: e("end with leftwards arrow above"),
                    character: "🔚"
                }, {
                    title: e("on with exclamation mark with left right arrow above"),
                    character: "🔛"
                }, {
                    title: e("soon with rightwards arrow above"),
                    character: "🔜"
                }, {title: e("top with upwards arrow above"), character: "🔝"}])
            }
        }

        class WN extends Ac {
            static get pluginName() {
                return "SpecialCharactersCurrency"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Currency", [{
                    character: "$",
                    title: e("Dollar sign")
                }, {character: "€", title: e("Euro sign")}, {character: "¥", title: e("Yen sign")}, {
                    character: "£",
                    title: e("Pound sign")
                }, {character: "¢", title: e("Cent sign")}, {
                    character: "₠",
                    title: e("Euro-currency sign")
                }, {character: "₡", title: e("Colon sign")}, {
                    character: "₢",
                    title: e("Cruzeiro sign")
                }, {character: "₣", title: e("French franc sign")}, {
                    character: "₤",
                    title: e("Lira sign")
                }, {character: "¤", title: e("Currency sign")}, {
                    character: "₿",
                    title: e("Bitcoin sign")
                }, {character: "₥", title: e("Mill sign")}, {character: "₦", title: e("Naira sign")}, {
                    character: "₧",
                    title: e("Peseta sign")
                }, {character: "₨", title: e("Rupee sign")}, {character: "₩", title: e("Won sign")}, {
                    character: "₪",
                    title: e("New sheqel sign")
                }, {character: "₫", title: e("Dong sign")}, {character: "₭", title: e("Kip sign")}, {
                    character: "₮",
                    title: e("Tugrik sign")
                }, {character: "₯", title: e("Drachma sign")}, {
                    character: "₰",
                    title: e("German penny sign")
                }, {character: "₱", title: e("Peso sign")}, {character: "₲", title: e("Guarani sign")}, {
                    character: "₳",
                    title: e("Austral sign")
                }, {character: "₴", title: e("Hryvnia sign")}, {character: "₵", title: e("Cedi sign")}, {
                    character: "₶",
                    title: e("Livre tournois sign")
                }, {character: "₷", title: e("Spesmilo sign")}, {
                    character: "₸",
                    title: e("Tenge sign")
                }, {character: "₹", title: e("Indian rupee sign")}, {
                    character: "₺",
                    title: e("Turkish lira sign")
                }, {character: "₻", title: e("Nordic mark sign")}, {
                    character: "₼",
                    title: e("Manat sign")
                }, {character: "₽", title: e("Ruble sign")}])
            }
        }

        class qN extends Ac {
            static get pluginName() {
                return "SpecialCharactersMathematical"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Mathematical", [{
                    character: "<",
                    title: e("Less-than sign")
                }, {character: ">", title: e("Greater-than sign")}, {
                    character: "≤",
                    title: e("Less-than or equal to")
                }, {character: "≥", title: e("Greater-than or equal to")}, {
                    character: "–",
                    title: e("En dash")
                }, {character: "—", title: e("Em dash")}, {character: "¯", title: e("Macron")}, {
                    character: "‾",
                    title: e("Overline")
                }, {character: "°", title: e("Degree sign")}, {character: "−", title: e("Minus sign")}, {
                    character: "±",
                    title: e("Plus-minus sign")
                }, {character: "÷", title: e("Division sign")}, {
                    character: "⁄",
                    title: e("Fraction slash")
                }, {character: "×", title: e("Multiplication sign")}, {
                    character: "ƒ",
                    title: e("Latin small letter f with hook")
                }, {character: "∫", title: e("Integral")}, {
                    character: "∑",
                    title: e("N-ary summation")
                }, {character: "∞", title: e("Infinity")}, {character: "√", title: e("Square root")}, {
                    character: "∼",
                    title: e("Tilde operator")
                }, {character: "≅", title: e("Approximately equal to")}, {
                    character: "≈",
                    title: e("Almost equal to")
                }, {character: "≠", title: e("Not equal to")}, {
                    character: "≡",
                    title: e("Identical to")
                }, {character: "∈", title: e("Element of")}, {
                    character: "∉",
                    title: e("Not an element of")
                }, {character: "∋", title: e("Contains as member")}, {
                    character: "∏",
                    title: e("N-ary product")
                }, {character: "∧", title: e("Logical and")}, {character: "∨", title: e("Logical or")}, {
                    character: "¬",
                    title: e("Not sign")
                }, {character: "∩", title: e("Intersection")}, {character: "∪", title: e("Union")}, {
                    character: "∂",
                    title: e("Partial differential")
                }, {character: "∀", title: e("For all")}, {character: "∃", title: e("There exists")}, {
                    character: "∅",
                    title: e("Empty set")
                }, {character: "∇", title: e("Nabla")}, {
                    character: "∗",
                    title: e("Asterisk operator")
                }, {character: "∝", title: e("Proportional to")}, {character: "∠", title: e("Angle")}, {
                    character: "¼",
                    title: e("Vulgar fraction one quarter")
                }, {character: "½", title: e("Vulgar fraction one half")}, {
                    character: "¾",
                    title: e("Vulgar fraction three quarters")
                }])
            }
        }

        class jN extends Ac {
            static get pluginName() {
                return "SpecialCharactersLatin"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Latin", [{
                    character: "Ā",
                    title: e("Latin capital letter a with macron")
                }, {character: "ā", title: e("Latin small letter a with macron")}, {
                    character: "Ă",
                    title: e("Latin capital letter a with breve")
                }, {character: "ă", title: e("Latin small letter a with breve")}, {
                    character: "Ą",
                    title: e("Latin capital letter a with ogonek")
                }, {character: "ą", title: e("Latin small letter a with ogonek")}, {
                    character: "Ć",
                    title: e("Latin capital letter c with acute")
                }, {character: "ć", title: e("Latin small letter c with acute")}, {
                    character: "Ĉ",
                    title: e("Latin capital letter c with circumflex")
                }, {character: "ĉ", title: e("Latin small letter c with circumflex")}, {
                    character: "Ċ",
                    title: e("Latin capital letter c with dot above")
                }, {character: "ċ", title: e("Latin small letter c with dot above")}, {
                    character: "Č",
                    title: e("Latin capital letter c with caron")
                }, {character: "č", title: e("Latin small letter c with caron")}, {
                    character: "Ď",
                    title: e("Latin capital letter d with caron")
                }, {character: "ď", title: e("Latin small letter d with caron")}, {
                    character: "Đ",
                    title: e("Latin capital letter d with stroke")
                }, {character: "đ", title: e("Latin small letter d with stroke")}, {
                    character: "Ē",
                    title: e("Latin capital letter e with macron")
                }, {character: "ē", title: e("Latin small letter e with macron")}, {
                    character: "Ĕ",
                    title: e("Latin capital letter e with breve")
                }, {character: "ĕ", title: e("Latin small letter e with breve")}, {
                    character: "Ė",
                    title: e("Latin capital letter e with dot above")
                }, {character: "ė", title: e("Latin small letter e with dot above")}, {
                    character: "Ę",
                    title: e("Latin capital letter e with ogonek")
                }, {character: "ę", title: e("Latin small letter e with ogonek")}, {
                    character: "Ě",
                    title: e("Latin capital letter e with caron")
                }, {character: "ě", title: e("Latin small letter e with caron")}, {
                    character: "Ĝ",
                    title: e("Latin capital letter g with circumflex")
                }, {character: "ĝ", title: e("Latin small letter g with circumflex")}, {
                    character: "Ğ",
                    title: e("Latin capital letter g with breve")
                }, {character: "ğ", title: e("Latin small letter g with breve")}, {
                    character: "Ġ",
                    title: e("Latin capital letter g with dot above")
                }, {character: "ġ", title: e("Latin small letter g with dot above")}, {
                    character: "Ģ",
                    title: e("Latin capital letter g with cedilla")
                }, {character: "ģ", title: e("Latin small letter g with cedilla")}, {
                    character: "Ĥ",
                    title: e("Latin capital letter h with circumflex")
                }, {character: "ĥ", title: e("Latin small letter h with circumflex")}, {
                    character: "Ħ",
                    title: e("Latin capital letter h with stroke")
                }, {character: "ħ", title: e("Latin small letter h with stroke")}, {
                    character: "Ĩ",
                    title: e("Latin capital letter i with tilde")
                }, {character: "ĩ", title: e("Latin small letter i with tilde")}, {
                    character: "Ī",
                    title: e("Latin capital letter i with macron")
                }, {character: "ī", title: e("Latin small letter i with macron")}, {
                    character: "Ĭ",
                    title: e("Latin capital letter i with breve")
                }, {character: "ĭ", title: e("Latin small letter i with breve")}, {
                    character: "Į",
                    title: e("Latin capital letter i with ogonek")
                }, {character: "į", title: e("Latin small letter i with ogonek")}, {
                    character: "İ",
                    title: e("Latin capital letter i with dot above")
                }, {character: "ı", title: e("Latin small letter dotless i")}, {
                    character: "Ĳ",
                    title: e("Latin capital ligature ij")
                }, {character: "ĳ", title: e("Latin small ligature ij")}, {
                    character: "Ĵ",
                    title: e("Latin capital letter j with circumflex")
                }, {character: "ĵ", title: e("Latin small letter j with circumflex")}, {
                    character: "Ķ",
                    title: e("Latin capital letter k with cedilla")
                }, {character: "ķ", title: e("Latin small letter k with cedilla")}, {
                    character: "ĸ",
                    title: e("Latin small letter kra")
                }, {character: "Ĺ", title: e("Latin capital letter l with acute")}, {
                    character: "ĺ",
                    title: e("Latin small letter l with acute")
                }, {character: "Ļ", title: e("Latin capital letter l with cedilla")}, {
                    character: "ļ",
                    title: e("Latin small letter l with cedilla")
                }, {character: "Ľ", title: e("Latin capital letter l with caron")}, {
                    character: "ľ",
                    title: e("Latin small letter l with caron")
                }, {character: "Ŀ", title: e("Latin capital letter l with middle dot")}, {
                    character: "ŀ",
                    title: e("Latin small letter l with middle dot")
                }, {character: "Ł", title: e("Latin capital letter l with stroke")}, {
                    character: "ł",
                    title: e("Latin small letter l with stroke")
                }, {character: "Ń", title: e("Latin capital letter n with acute")}, {
                    character: "ń",
                    title: e("Latin small letter n with acute")
                }, {character: "Ņ", title: e("Latin capital letter n with cedilla")}, {
                    character: "ņ",
                    title: e("Latin small letter n with cedilla")
                }, {character: "Ň", title: e("Latin capital letter n with caron")}, {
                    character: "ň",
                    title: e("Latin small letter n with caron")
                }, {character: "ŉ", title: e("Latin small letter n preceded by apostrophe")}, {
                    character: "Ŋ",
                    title: e("Latin capital letter eng")
                }, {character: "ŋ", title: e("Latin small letter eng")}, {
                    character: "Ō",
                    title: e("Latin capital letter o with macron")
                }, {character: "ō", title: e("Latin small letter o with macron")}, {
                    character: "Ŏ",
                    title: e("Latin capital letter o with breve")
                }, {character: "ŏ", title: e("Latin small letter o with breve")}, {
                    character: "Ő",
                    title: e("Latin capital letter o with double acute")
                }, {character: "ő", title: e("Latin small letter o with double acute")}, {
                    character: "Œ",
                    title: e("Latin capital ligature oe")
                }, {character: "œ", title: e("Latin small ligature oe")}, {
                    character: "Ŕ",
                    title: e("Latin capital letter r with acute")
                }, {character: "ŕ", title: e("Latin small letter r with acute")}, {
                    character: "Ŗ",
                    title: e("Latin capital letter r with cedilla")
                }, {character: "ŗ", title: e("Latin small letter r with cedilla")}, {
                    character: "Ř",
                    title: e("Latin capital letter r with caron")
                }, {character: "ř", title: e("Latin small letter r with caron")}, {
                    character: "Ś",
                    title: e("Latin capital letter s with acute")
                }, {character: "ś", title: e("Latin small letter s with acute")}, {
                    character: "Ŝ",
                    title: e("Latin capital letter s with circumflex")
                }, {character: "ŝ", title: e("Latin small letter s with circumflex")}, {
                    character: "Ş",
                    title: e("Latin capital letter s with cedilla")
                }, {character: "ş", title: e("Latin small letter s with cedilla")}, {
                    character: "Š",
                    title: e("Latin capital letter s with caron")
                }, {character: "š", title: e("Latin small letter s with caron")}, {
                    character: "Ţ",
                    title: e("Latin capital letter t with cedilla")
                }, {character: "ţ", title: e("Latin small letter t with cedilla")}, {
                    character: "Ť",
                    title: e("Latin capital letter t with caron")
                }, {character: "ť", title: e("Latin small letter t with caron")}, {
                    character: "Ŧ",
                    title: e("Latin capital letter t with stroke")
                }, {character: "ŧ", title: e("Latin small letter t with stroke")}, {
                    character: "Ũ",
                    title: e("Latin capital letter u with tilde")
                }, {character: "ũ", title: e("Latin small letter u with tilde")}, {
                    character: "Ū",
                    title: e("Latin capital letter u with macron")
                }, {character: "ū", title: e("Latin small letter u with macron")}, {
                    character: "Ŭ",
                    title: e("Latin capital letter u with breve")
                }, {character: "ŭ", title: e("Latin small letter u with breve")}, {
                    character: "Ů",
                    title: e("Latin capital letter u with ring above")
                }, {character: "ů", title: e("Latin small letter u with ring above")}, {
                    character: "Ű",
                    title: e("Latin capital letter u with double acute")
                }, {character: "ű", title: e("Latin small letter u with double acute")}, {
                    character: "Ų",
                    title: e("Latin capital letter u with ogonek")
                }, {character: "ų", title: e("Latin small letter u with ogonek")}, {
                    character: "Ŵ",
                    title: e("Latin capital letter w with circumflex")
                }, {character: "ŵ", title: e("Latin small letter w with circumflex")}, {
                    character: "Ŷ",
                    title: e("Latin capital letter y with circumflex")
                }, {character: "ŷ", title: e("Latin small letter y with circumflex")}, {
                    character: "Ÿ",
                    title: e("Latin capital letter y with diaeresis")
                }, {character: "Ź", title: e("Latin capital letter z with acute")}, {
                    character: "ź",
                    title: e("Latin small letter z with acute")
                }, {character: "Ż", title: e("Latin capital letter z with dot above")}, {
                    character: "ż",
                    title: e("Latin small letter z with dot above")
                }, {character: "Ž", title: e("Latin capital letter z with caron")}, {
                    character: "ž",
                    title: e("Latin small letter z with caron")
                }, {character: "ſ", title: e("Latin small letter long s")}])
            }
        }

        class $N extends Ac {
            static get pluginName() {
                return "SpecialCharactersText"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Text", [{
                    character: "‹",
                    title: e("Single left-pointing angle quotation mark")
                }, {character: "›", title: e("Single right-pointing angle quotation mark")}, {
                    character: "«",
                    title: e("Left-pointing double angle quotation mark")
                }, {character: "»", title: e("Right-pointing double angle quotation mark")}, {
                    character: "‘",
                    title: e("Left single quotation mark")
                }, {character: "’", title: e("Right single quotation mark")}, {
                    character: "“",
                    title: e("Left double quotation mark")
                }, {character: "”", title: e("Right double quotation mark")}, {
                    character: "‚",
                    title: e("Single low-9 quotation mark")
                }, {character: "„", title: e("Double low-9 quotation mark")}, {
                    character: "¡",
                    title: e("Inverted exclamation mark")
                }, {character: "¿", title: e("Inverted question mark")}, {
                    character: "‥",
                    title: e("Two dot leader")
                }, {character: "…", title: e("Horizontal ellipsis")}, {
                    character: "‡",
                    title: e("Double dagger")
                }, {character: "‰", title: e("Per mille sign")}, {
                    character: "‱",
                    title: e("Per ten thousand sign")
                }, {character: "‼", title: e("Double exclamation mark")}, {
                    character: "⁈",
                    title: e("Question exclamation mark")
                }, {character: "⁉", title: e("Exclamation question mark")}, {
                    character: "⁇",
                    title: e("Double question mark")
                }, {character: "©", title: e("Copyright sign")}, {
                    character: "®",
                    title: e("Registered sign")
                }, {character: "™", title: e("Trade mark sign")}, {
                    character: "§",
                    title: e("Section sign")
                }, {character: "¶", title: e("Paragraph sign")}, {character: "⁋", title: e("Reversed paragraph sign")}])
            }
        }

        class UN extends Ac {
            static get requires() {
                return [WN, $N, qN, HN, jN]
            }
        }

        const GN = "strikethrough";

        class KN extends Ac {
            static get pluginName() {
                return "StrikethroughEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: GN});
                t.model.schema.setAttributeProperties(GN, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: GN,
                    view: "s",
                    upcastAlso: ["del", "strike", {styles: {"text-decoration": "line-through"}}]
                });
                t.commands.add(GN, new AD(t, GN));
                t.keystrokes.set("CTRL+SHIFT+X", "strikethrough")
            }
        }

        const ZN = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
        const JN = "strikethrough";

        class YN extends Ac {
            static get pluginName() {
                return "StrikethroughUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(JN, (n => {
                    const i = t.commands.get(JN);
                    const o = new LC(n);
                    o.set({
                        label: e("Strikethrough"),
                        icon: ZN,
                        keystroke: "CTRL+SHIFT+X",
                        tooltip: true,
                        isToggleable: true
                    });
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(JN);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class QN extends Ac {
            static get requires() {
                return [KN, YN]
            }

            static get pluginName() {
                return "Strikethrough"
            }
        }

        const XN = "subscript";

        class tM extends Ac {
            static get pluginName() {
                return "SubscriptEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: XN});
                t.model.schema.setAttributeProperties(XN, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: XN,
                    view: "sub",
                    upcastAlso: [{styles: {"vertical-align": "sub"}}]
                });
                t.commands.add(XN, new AD(t, XN))
            }
        }

        const eM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
        const nM = "subscript";

        class iM extends Ac {
            static get pluginName() {
                return "SubscriptUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(nM, (n => {
                    const i = t.commands.get(nM);
                    const o = new LC(n);
                    o.set({label: e("Subscript"), icon: eM, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(nM);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class oM extends Ac {
            static get requires() {
                return [tM, iM]
            }

            static get pluginName() {
                return "Subscript"
            }
        }

        const rM = "superscript";

        class sM extends Ac {
            static get pluginName() {
                return "SuperscriptEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: rM});
                t.model.schema.setAttributeProperties(rM, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: rM,
                    view: "sup",
                    upcastAlso: [{styles: {"vertical-align": "super"}}]
                });
                t.commands.add(rM, new AD(t, rM))
            }
        }

        const aM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
        const lM = "superscript";

        class cM extends Ac {
            static get pluginName() {
                return "SuperscriptUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(lM, (n => {
                    const i = t.commands.get(lM);
                    const o = new LC(n);
                    o.set({label: e("Superscript"), icon: aM, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(lM);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class dM extends Ac {
            static get requires() {
                return [sM, cM]
            }

            static get pluginName() {
                return "Superscript"
            }
        }

        function uM(t, e) {
            const {
                viewElement: n,
                defaultValue: i,
                modelAttribute: o,
                styleName: r,
                reduceBoxSides: s = false,
                shouldUpcast: a = (() => true)
            } = e;
            t.for("upcast").attributeToAttribute({
                view: {name: n, styles: {[r]: /[\s\S]+/}},
                model: {
                    key: o, value: t => {
                        if (!a(t)) {
                            return
                        }
                        const e = t.getNormalizedStyle(r);
                        const n = s ? mM(e) : e;
                        if (i !== n) {
                            return n
                        }
                    }
                }
            })
        }

        function hM(t, e, n, i) {
            t.for("upcast").add((t => t.on("element:" + e, ((t, e, o) => {
                if (!e.modelRange) {
                    return
                }
                const r = ["border-top-width", "border-top-color", "border-top-style", "border-bottom-width", "border-bottom-color", "border-bottom-style", "border-right-width", "border-right-color", "border-right-style", "border-left-width", "border-left-color", "border-left-style"].filter((t => e.viewItem.hasStyle(t)));
                if (!r.length) {
                    return
                }
                const s = {styles: r};
                if (!o.consumable.test(e.viewItem, s)) {
                    return
                }
                const a = [...e.modelRange.getItems({shallow: true})].pop();
                o.consumable.consume(e.viewItem, s);
                const l = {
                    style: e.viewItem.getNormalizedStyle("border-style"),
                    color: e.viewItem.getNormalizedStyle("border-color"),
                    width: e.viewItem.getNormalizedStyle("border-width")
                };
                const c = {style: mM(l.style), color: mM(l.color), width: mM(l.width)};
                if (c.style !== i.style) {
                    o.writer.setAttribute(n.style, c.style, a)
                }
                if (c.color !== i.color) {
                    o.writer.setAttribute(n.color, c.color, a)
                }
                if (c.width !== i.width) {
                    o.writer.setAttribute(n.width, c.width, a)
                }
            }))))
        }

        function fM(t, {modelElement: e, modelAttribute: n, styleName: i}) {
            t.for("downcast").attributeToAttribute({
                model: {name: e, key: n},
                view: t => ({key: "style", value: {[i]: t}})
            })
        }

        function gM(t, {modelAttribute: e, styleName: n}) {
            t.for("downcast").add((t => t.on(`attribute:${e}:table`, ((t, e, i) => {
                const {item: o, attributeNewValue: r} = e;
                const {mapper: s, writer: a} = i;
                if (!i.consumable.consume(e.item, t.name)) {
                    return
                }
                const l = [...s.toViewElement(o).getChildren()].find((t => t.is("element", "table")));
                if (r) {
                    a.setStyle(n, r, l)
                } else {
                    a.removeStyle(n, l)
                }
            }))))
        }

        function mM(t) {
            if (!t) {
                return
            }
            const e = ["top", "right", "bottom", "left"].map((e => t[e])).reduce(((t, e) => t == e ? t : null));
            return e || t
        }

        function pM(t, e, n, i, o = 1) {
            if (e > o) {
                i.setAttribute(t, e, n)
            } else {
                i.removeAttribute(t, n)
            }
        }

        function bM(t, e, n = {}) {
            const i = t.createElement("tableCell", n);
            t.insertElement("paragraph", i);
            t.insert(i, e);
            return i
        }

        function kM(t, e) {
            const n = e.parent.parent;
            const i = parseInt(n.getAttribute("headingColumns") || 0);
            const {column: o} = t.getCellLocation(e);
            return !!i && o < i
        }

        function wM(t, e, n) {
            const {modelAttribute: i} = n;
            t.extend("tableCell", {allowAttributes: [i]});
            uM(e, {viewElement: /^(td|th)$/, ...n});
            fM(e, {modelElement: "tableCell", ...n})
        }

        function _M() {
            return t => {
                t.on("element:figure", ((t, e, n) => {
                    if (!n.consumable.test(e.viewItem, {name: true, classes: "table"})) {
                        return
                    }
                    const i = yM(e.viewItem);
                    if (!i || !n.consumable.test(i, {name: true})) {
                        return
                    }
                    n.consumable.consume(e.viewItem, {name: true, classes: "table"});
                    const o = n.convertItem(i, e.modelCursor);
                    const r = sc(o.modelRange.getItems());
                    if (!r) {
                        n.consumable.revert(e.viewItem, {name: true, classes: "table"});
                        return
                    }
                    n.convertChildren(e.viewItem, n.writer.createPositionAt(r, "end"));
                    n.updateConversionResult(r, e)
                }))
            }
        }

        function AM() {
            return t => {
                t.on("element:table", ((t, e, n) => {
                    const i = e.viewItem;
                    if (!n.consumable.test(i, {name: true})) {
                        return
                    }
                    const {rows: o, headingRows: r, headingColumns: s} = xM(i);
                    const a = {};
                    if (s) {
                        a.headingColumns = s
                    }
                    if (r) {
                        a.headingRows = r
                    }
                    const l = n.writer.createElement("table", a);
                    if (!n.safeInsert(l, e.modelCursor)) {
                        return
                    }
                    n.consumable.consume(i, {name: true});
                    o.forEach((t => n.convertItem(t, n.writer.createPositionAt(l, "end"))));
                    n.convertChildren(i, n.writer.createPositionAt(l, "end"));
                    if (l.isEmpty) {
                        const t = n.writer.createElement("tableRow");
                        n.writer.insert(t, n.writer.createPositionAt(l, "end"));
                        bM(n.writer, n.writer.createPositionAt(t, "end"))
                    }
                    n.updateConversionResult(l, e)
                }))
            }
        }

        function CM() {
            return t => {
                t.on("element:tr", ((t, e) => {
                    if (e.viewItem.isEmpty && e.modelCursor.index == 0) {
                        t.stop()
                    }
                }), {priority: "high"})
            }
        }

        function vM(t) {
            return e => {
                e.on(`element:${t}`, ((t, e, n) => {
                    if (!e.modelRange) {
                        return
                    }
                    if (e.viewItem.isEmpty) {
                        const t = e.modelRange.start.nodeAfter;
                        const i = n.writer.createPositionAt(t, 0);
                        n.writer.insertElement("paragraph", i)
                    }
                }), {priority: "low"})
            }
        }

        function yM(t) {
            for (const e of t.getChildren()) {
                if (e.is("element", "table")) {
                    return e
                }
            }
        }

        function xM(t) {
            const e = {headingRows: 0, headingColumns: 0};
            const n = [];
            const i = [];
            let o;
            for (const r of Array.from(t.getChildren())) {
                if (r.name === "tbody" || r.name === "thead" || r.name === "tfoot") {
                    if (r.name === "thead" && !o) {
                        o = r
                    }
                    const t = Array.from(r.getChildren()).filter((t => t.is("element", "tr")));
                    for (const r of t) {
                        if (r.parent.name === "thead" && r.parent === o) {
                            e.headingRows++;
                            n.push(r)
                        } else {
                            i.push(r);
                            const t = EM(r, e, o);
                            if (t > e.headingColumns) {
                                e.headingColumns = t
                            }
                        }
                    }
                }
            }
            e.rows = [...n, ...i];
            return e
        }

        function EM(t) {
            let e = 0;
            let n = 0;
            const i = Array.from(t.getChildren()).filter((t => t.name === "th" || t.name === "td"));
            while (n < i.length && i[n].name === "th") {
                const t = i[n];
                const o = parseInt(t.getAttribute("colspan") || 1);
                e = e + o;
                n++
            }
            return e
        }

        class SM {
            constructor(t, e = {}) {
                this._table = t;
                this._startRow = e.row !== undefined ? e.row : e.startRow || 0;
                this._endRow = e.row !== undefined ? e.row : e.endRow;
                this._startColumn = e.column !== undefined ? e.column : e.startColumn || 0;
                this._endColumn = e.column !== undefined ? e.column : e.endColumn;
                this._includeAllSlots = !!e.includeAllSlots;
                this._skipRows = new Set;
                this._row = 0;
                this._rowIndex = 0;
                this._column = 0;
                this._cellIndex = 0;
                this._spannedCells = new Map;
                this._nextCellAtColumn = -1
            }

            [Symbol.iterator]() {
                return this
            }

            next() {
                const t = this._table.getChild(this._rowIndex);
                if (!t || this._isOverEndRow()) {
                    return {done: true}
                }
                if (!t.is("element", "tableRow")) {
                    this._rowIndex++;
                    return this.next()
                }
                if (this._isOverEndColumn()) {
                    return this._advanceToNextRow()
                }
                let e = null;
                const n = this._getSpanned();
                if (n) {
                    if (this._includeAllSlots && !this._shouldSkipSlot()) {
                        e = this._formatOutValue(n.cell, n.row, n.column)
                    }
                } else {
                    const n = t.getChild(this._cellIndex);
                    if (!n) {
                        return this._advanceToNextRow()
                    }
                    const i = parseInt(n.getAttribute("colspan") || 1);
                    const o = parseInt(n.getAttribute("rowspan") || 1);
                    if (i > 1 || o > 1) {
                        this._recordSpans(n, o, i)
                    }
                    if (!this._shouldSkipSlot()) {
                        e = this._formatOutValue(n)
                    }
                    this._nextCellAtColumn = this._column + i
                }
                this._column++;
                if (this._column == this._nextCellAtColumn) {
                    this._cellIndex++
                }
                return e || this.next()
            }

            skipRow(t) {
                this._skipRows.add(t)
            }

            _advanceToNextRow() {
                this._row++;
                this._rowIndex++;
                this._column = 0;
                this._cellIndex = 0;
                this._nextCellAtColumn = -1;
                return this.next()
            }

            _isOverEndRow() {
                return this._endRow !== undefined && this._row > this._endRow
            }

            _isOverEndColumn() {
                return this._endColumn !== undefined && this._column > this._endColumn
            }

            _formatOutValue(t, e = this._row, n = this._column) {
                return {done: false, value: new DM(this, t, e, n)}
            }

            _shouldSkipSlot() {
                const t = this._skipRows.has(this._row);
                const e = this._row < this._startRow;
                const n = this._column < this._startColumn;
                const i = this._endColumn !== undefined && this._column > this._endColumn;
                return t || e || n || i
            }

            _getSpanned() {
                const t = this._spannedCells.get(this._row);
                if (!t) {
                    return null
                }
                return t.get(this._column) || null
            }

            _recordSpans(t, e, n) {
                const i = {cell: t, row: this._row, column: this._column};
                for (let t = this._row; t < this._row + e; t++) {
                    for (let e = this._column; e < this._column + n; e++) {
                        if (t != this._row || e != this._column) {
                            this._markSpannedCell(t, e, i)
                        }
                    }
                }
            }

            _markSpannedCell(t, e, n) {
                if (!this._spannedCells.has(t)) {
                    this._spannedCells.set(t, new Map)
                }
                const i = this._spannedCells.get(t);
                i.set(e, n)
            }
        }

        class DM {
            constructor(t, e, n, i) {
                this.cell = e;
                this.row = t._row;
                this.column = t._column;
                this.cellAnchorRow = n;
                this.cellAnchorColumn = i;
                this._cellIndex = t._cellIndex;
                this._rowIndex = t._rowIndex;
                this._table = t._table
            }

            get isAnchor() {
                return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
            }

            get cellWidth() {
                return parseInt(this.cell.getAttribute("colspan") || 1)
            }

            get cellHeight() {
                return parseInt(this.cell.getAttribute("rowspan") || 1)
            }

            get rowIndex() {
                return this._rowIndex
            }

            getPositionBefore() {
                const t = this._table.root.document.model;
                return t.createPositionAt(this._table.getChild(this.row), this._cellIndex)
            }
        }

        function TM(t, e = {}) {
            return (n, {writer: i}) => {
                const o = n.getAttribute("headingRows") || 0;
                const r = [];
                if (o > 0) {
                    r.push(i.createContainerElement("thead", null, i.createSlot((t => t.is("element", "tableRow") && t.index < o))))
                }
                if (o < t.getRows(n)) {
                    r.push(i.createContainerElement("tbody", null, i.createSlot((t => t.is("element", "tableRow") && t.index >= o))))
                }
                const s = i.createContainerElement("figure", {class: "table"}, [i.createContainerElement("table", null, r), i.createSlot((t => !t.is("element", "tableRow")))]);
                return e.asWidget ? zM(s, i) : s
            }
        }

        function BM() {
            return (t, {writer: e}) => t.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr")
        }

        function PM(t = {}) {
            return (e, {writer: n}) => {
                const i = e.parent;
                const o = i.parent;
                const r = o.getChildIndex(i);
                const s = new SM(o, {row: r});
                const a = o.getAttribute("headingRows") || 0;
                const l = o.getAttribute("headingColumns") || 0;
                for (const i of s) {
                    if (i.cell == e) {
                        const e = i.row < a || i.column < l;
                        const o = e ? "th" : "td";
                        return t.asWidget ? tI(n.createEditableElement(o), n) : n.createContainerElement(o)
                    }
                }
            }
        }

        function IM(t = {}) {
            return (e, {writer: n, consumable: i, mapper: o}) => {
                if (!e.parent.is("element", "tableCell")) {
                    return
                }
                if (!RM(e)) {
                    return
                }
                if (t.asWidget) {
                    return n.createContainerElement("span", {class: "ck-table-bogus-paragraph"})
                } else {
                    i.consume(e, "insert");
                    o.bindElements(e, o.toViewElement(e.parent))
                }
            }
        }

        function RM(t) {
            const e = t.parent;
            const n = e.childCount == 1;
            return n && !VM(t)
        }

        function zM(t, e) {
            e.setCustomProperty("table", true, t);
            return KP(t, e, {hasSelectionHandle: true})
        }

        function VM(t) {
            return !![...t.getAttributeKeys()].length
        }

        class FM extends vc {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = t.schema;
                this.isEnabled = LM(e, n)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = this.editor.plugins.get("TableUtils");
                const i = this.editor.config.get("table");
                const o = i.defaultHeadings.rows;
                const r = i.defaultHeadings.columns;
                if (t.headingRows === undefined && o) {
                    t.headingRows = o
                }
                if (t.headingColumns === undefined && r) {
                    t.headingColumns = r
                }
                e.change((i => {
                    const o = n.createTable(i, t);
                    e.insertObject(o, null, null, {findOptimalPosition: "auto"});
                    i.setSelection(i.createPositionAt(o.getNodeByPath([0, 0, 0]), 0))
                }))
            }
        }

        function LM(t, e) {
            const n = t.getFirstPosition().parent;
            const i = n === n.root ? n : n.parent;
            return e.checkChild(i, "table")
        }

        class OM extends vc {
            constructor(t, e = {}) {
                super(t);
                this.order = e.order || "below"
            }

            refresh() {
                const t = this.editor.model.document.selection;
                const e = this.editor.plugins.get("TableUtils");
                const n = !!e.getSelectionAffectedTableCells(t).length;
                this.isEnabled = n
            }

            execute() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = t.plugins.get("TableUtils");
                const i = this.order === "above";
                const o = n.getSelectionAffectedTableCells(e);
                const r = n.getRowIndexes(o);
                const s = i ? r.first : r.last;
                const a = o[0].findAncestor("table");
                n.insertRows(a, {at: i ? s : s + 1, copyStructureFromAbove: !i})
            }
        }

        class NM extends vc {
            constructor(t, e = {}) {
                super(t);
                this.order = e.order || "right"
            }

            refresh() {
                const t = this.editor.model.document.selection;
                const e = this.editor.plugins.get("TableUtils");
                const n = !!e.getSelectionAffectedTableCells(t).length;
                this.isEnabled = n
            }

            execute() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = t.plugins.get("TableUtils");
                const i = this.order === "left";
                const o = n.getSelectionAffectedTableCells(e);
                const r = n.getColumnIndexes(o);
                const s = i ? r.first : r.last;
                const a = o[0].findAncestor("table");
                n.insertColumns(a, {columns: 1, at: i ? s : s + 1})
            }
        }

        class MM extends vc {
            constructor(t, e = {}) {
                super(t);
                this.direction = e.direction || "horizontally"
            }

            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = e.length === 1
            }

            execute() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
                const n = this.direction === "horizontally";
                if (n) {
                    t.splitCellHorizontally(e, 2)
                } else {
                    t.splitCellVertically(e, 2)
                }
            }
        }

        function HM(t, e, n) {
            const {startRow: i, startColumn: o, endRow: r, endColumn: s} = e;
            const a = n.createElement("table");
            const l = r - i + 1;
            for (let t = 0; t < l; t++) {
                n.insertElement("tableRow", a, "end")
            }
            const c = [...new SM(t, {startRow: i, endRow: r, startColumn: o, endColumn: s, includeAllSlots: true})];
            for (const {row: t, column: e, cell: l, isAnchor: d, cellAnchorRow: u, cellAnchorColumn: h} of c) {
                const c = t - i;
                const f = a.getChild(c);
                if (!d) {
                    if (u < i || h < o) {
                        bM(n, n.createPositionAt(f, "end"))
                    }
                } else {
                    const i = n.cloneElement(l);
                    n.append(i, f);
                    UM(i, t, e, r, s, n)
                }
            }
            GM(a, t, i, o, n);
            return a
        }

        function WM(t, e, n = 0) {
            const i = [];
            const o = new SM(t, {startRow: n, endRow: e - 1});
            for (const t of o) {
                const {row: n, cellHeight: o} = t;
                const r = n + o - 1;
                if (n < e && e <= r) {
                    i.push(t)
                }
            }
            return i
        }

        function qM(t, e, n) {
            const i = t.parent;
            const o = i.parent;
            const r = i.index;
            const s = parseInt(t.getAttribute("rowspan"));
            const a = e - r;
            const l = {};
            const c = s - a;
            if (c > 1) {
                l.rowspan = c
            }
            const d = parseInt(t.getAttribute("colspan") || 1);
            if (d > 1) {
                l.colspan = d
            }
            const u = r;
            const h = u + a;
            const f = [...new SM(o, {startRow: u, endRow: h, includeAllSlots: true})];
            let g = null;
            let m;
            for (const e of f) {
                const {row: i, column: o, cell: r} = e;
                if (r === t && m === undefined) {
                    m = o
                }
                if (m !== undefined && m === o && i === h) {
                    g = bM(n, e.getPositionBefore(), l)
                }
            }
            pM("rowspan", a, t, n);
            return g
        }

        function jM(t, e) {
            const n = [];
            const i = new SM(t);
            for (const t of i) {
                const {column: i, cellWidth: o} = t;
                const r = i + o - 1;
                if (i < e && e <= r) {
                    n.push(t)
                }
            }
            return n
        }

        function $M(t, e, n, i) {
            const o = parseInt(t.getAttribute("colspan"));
            const r = n - e;
            const s = {};
            const a = o - r;
            if (a > 1) {
                s.colspan = a
            }
            const l = parseInt(t.getAttribute("rowspan") || 1);
            if (l > 1) {
                s.rowspan = l
            }
            const c = bM(i, i.createPositionAfter(t), s);
            pM("colspan", r, t, i);
            return c
        }

        function UM(t, e, n, i, o, r) {
            const s = parseInt(t.getAttribute("colspan") || 1);
            const a = parseInt(t.getAttribute("rowspan") || 1);
            const l = n + s - 1;
            if (l > o) {
                const e = o - n + 1;
                pM("colspan", e, t, r, 1)
            }
            const c = e + a - 1;
            if (c > i) {
                const n = i - e + 1;
                pM("rowspan", n, t, r, 1)
            }
        }

        function GM(t, e, n, i, o) {
            const r = parseInt(e.getAttribute("headingRows") || 0);
            if (r > 0) {
                const e = r - n;
                pM("headingRows", e, t, o, 0)
            }
            const s = parseInt(e.getAttribute("headingColumns") || 0);
            if (s > 0) {
                const e = s - i;
                pM("headingColumns", e, t, o, 0)
            }
        }

        function KM(t, e) {
            const n = e.getColumns(t);
            const i = new Array(n).fill(0);
            for (const {column: e} of new SM(t)) {
                i[e]++
            }
            const o = i.reduce(((t, e, n) => e ? t : [...t, n]), []);
            if (o.length > 0) {
                const n = o[o.length - 1];
                e.removeColumns(t, {at: n});
                return true
            }
            return false
        }

        function ZM(t, e) {
            const n = [];
            const i = e.getRows(t);
            for (let e = 0; e < i; e++) {
                const i = t.getChild(e);
                if (i.isEmpty) {
                    n.push(e)
                }
            }
            if (n.length > 0) {
                const i = n[n.length - 1];
                e.removeRows(t, {at: i});
                return true
            }
            return false
        }

        function JM(t, e) {
            const n = KM(t, e);
            if (!n) {
                ZM(t, e)
            }
        }

        function YM(t, e) {
            const n = Array.from(new SM(t, {startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow}));
            const i = n.every((({cellHeight: t}) => t === 1));
            if (i) {
                return e.lastRow
            }
            const o = n[0].cellHeight - 1;
            return e.lastRow + o
        }

        function QM(t, e) {
            const n = Array.from(new SM(t, {startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn}));
            const i = n.every((({cellWidth: t}) => t === 1));
            if (i) {
                return e.lastColumn
            }
            const o = n[0].cellWidth - 1;
            return e.lastColumn + o
        }

        class XM extends vc {
            constructor(t, e) {
                super(t);
                this.direction = e.direction;
                this.isHorizontal = this.direction == "right" || this.direction == "left"
            }

            refresh() {
                const t = this._getMergeableCell();
                this.value = t;
                this.isEnabled = !!t
            }

            execute() {
                const t = this.editor.model;
                const e = t.document;
                const n = this.editor.plugins.get("TableUtils");
                const i = n.getTableCellsContainingSelection(e.selection)[0];
                const o = this.value;
                const r = this.direction;
                t.change((t => {
                    const e = r == "right" || r == "down";
                    const n = e ? i : o;
                    const s = e ? o : i;
                    const a = s.parent;
                    nH(s, n, t);
                    const l = this.isHorizontal ? "colspan" : "rowspan";
                    const c = parseInt(i.getAttribute(l) || 1);
                    const d = parseInt(o.getAttribute(l) || 1);
                    t.setAttribute(l, c + d, n);
                    t.setSelection(t.createRangeIn(n));
                    const u = this.editor.plugins.get("TableUtils");
                    const h = a.findAncestor("table");
                    JM(h, u)
                }))
            }

            _getMergeableCell() {
                const t = this.editor.model;
                const e = t.document;
                const n = this.editor.plugins.get("TableUtils");
                const i = n.getTableCellsContainingSelection(e.selection)[0];
                if (!i) {
                    return
                }
                const o = this.isHorizontal ? tH(i, this.direction, n) : eH(i, this.direction, n);
                if (!o) {
                    return
                }
                const r = this.isHorizontal ? "rowspan" : "colspan";
                const s = parseInt(i.getAttribute(r) || 1);
                const a = parseInt(o.getAttribute(r) || 1);
                if (a === s) {
                    return o
                }
            }
        }

        function tH(t, e, n) {
            const i = t.parent;
            const o = i.parent;
            const r = e == "right" ? t.nextSibling : t.previousSibling;
            const s = (o.getAttribute("headingColumns") || 0) > 0;
            if (!r) {
                return
            }
            const a = e == "right" ? t : r;
            const l = e == "right" ? r : t;
            const {column: c} = n.getCellLocation(a);
            const {column: d} = n.getCellLocation(l);
            const u = parseInt(a.getAttribute("colspan") || 1);
            const h = kM(n, a, o);
            const f = kM(n, l, o);
            if (s && h != f) {
                return
            }
            const g = c + u === d;
            return g ? r : undefined
        }

        function eH(t, e, n) {
            const i = t.parent;
            const o = i.parent;
            const r = o.getChildIndex(i);
            if (e == "down" && r === n.getRows(o) - 1 || e == "up" && r === 0) {
                return
            }
            const s = parseInt(t.getAttribute("rowspan") || 1);
            const a = o.getAttribute("headingRows") || 0;
            const l = e == "down" && r + s === a;
            const c = e == "up" && r === a;
            if (a && (l || c)) {
                return
            }
            const d = parseInt(t.getAttribute("rowspan") || 1);
            const u = e == "down" ? r + d : r;
            const h = [...new SM(o, {endRow: u})];
            const f = h.find((e => e.cell === t));
            const g = f.column;
            const m = h.find((({row: t, cellHeight: n, column: i}) => {
                if (i !== g) {
                    return false
                }
                if (e == "down") {
                    return t === u
                } else {
                    return u === t + n
                }
            }));
            return m && m.cell
        }

        function nH(t, e, n) {
            if (!iH(t)) {
                if (iH(e)) {
                    n.remove(n.createRangeIn(e))
                }
                n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))
            }
            n.remove(t)
        }

        function iH(t) {
            return t.childCount == 1 && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
        }

        class oH extends vc {
            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection);
                const n = e[0];
                if (n) {
                    const i = n.findAncestor("table");
                    const o = this.editor.plugins.get("TableUtils").getRows(i);
                    const r = o - 1;
                    const s = t.getRowIndexes(e);
                    const a = s.first === 0 && s.last === r;
                    this.isEnabled = !a
                } else {
                    this.isEnabled = false
                }
            }

            execute() {
                const t = this.editor.model;
                const e = this.editor.plugins.get("TableUtils");
                const n = e.getSelectionAffectedTableCells(t.document.selection);
                const i = e.getRowIndexes(n);
                const o = n[0];
                const r = o.findAncestor("table");
                const s = e.getCellLocation(o).column;
                t.change((t => {
                    const n = i.last - i.first + 1;
                    e.removeRows(r, {at: i.first, rows: n});
                    const o = rH(r, i.first, s, e.getRows(r));
                    t.setSelection(t.createPositionAt(o, 0))
                }))
            }
        }

        function rH(t, e, n, i) {
            const o = t.getChild(Math.min(e, i - 1));
            let r = o.getChild(0);
            let s = 0;
            for (const t of o.getChildren()) {
                if (s > n) {
                    return r
                }
                r = t;
                s += parseInt(t.getAttribute("colspan") || 1)
            }
            return r
        }

        class sH extends vc {
            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection);
                const n = e[0];
                if (n) {
                    const i = n.findAncestor("table");
                    const o = t.getColumns(i);
                    const {first: r, last: s} = t.getColumnIndexes(e);
                    this.isEnabled = s - r < o - 1
                } else {
                    this.isEnabled = false
                }
            }

            execute() {
                const t = this.editor.plugins.get("TableUtils");
                const [e, n] = lH(this.editor.model.document.selection, t);
                const i = e.parent.parent;
                const o = [...new SM(i)];
                const r = {first: o.find((t => t.cell === e)).column, last: o.find((t => t.cell === n)).column};
                const s = aH(o, e, n, r);
                this.editor.model.change((t => {
                    const e = r.last - r.first + 1;
                    this.editor.plugins.get("TableUtils").removeColumns(i, {at: r.first, columns: e});
                    t.setSelection(t.createPositionAt(s, 0))
                }))
            }
        }

        function aH(t, e, n, i) {
            const o = parseInt(n.getAttribute("colspan") || 1);
            if (o > 1) {
                return n
            } else if (e.previousSibling || n.nextSibling) {
                return n.nextSibling || e.previousSibling
            } else {
                if (i.first) {
                    return t.reverse().find((({column: t}) => t < i.first)).cell
                } else {
                    return t.reverse().find((({column: t}) => t > i.last)).cell
                }
            }
        }

        function lH(t, e) {
            const n = e.getSelectionAffectedTableCells(t);
            const i = n[0];
            const o = n.pop();
            const r = [i, o];
            return i.isBefore(o) ? r : r.reverse()
        }

        class cH extends vc {
            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = this.editor.model;
                const n = t.getSelectionAffectedTableCells(e.document.selection);
                const i = n.length > 0;
                this.isEnabled = i;
                this.value = i && n.every((t => this._isInHeading(t, t.parent.parent)))
            }

            execute(t = {}) {
                if (t.forceValue === this.value) {
                    return
                }
                const e = this.editor.plugins.get("TableUtils");
                const n = this.editor.model;
                const i = e.getSelectionAffectedTableCells(n.document.selection);
                const o = i[0].findAncestor("table");
                const {first: r, last: s} = e.getRowIndexes(i);
                const a = this.value ? r : s + 1;
                const l = o.getAttribute("headingRows") || 0;
                n.change((t => {
                    if (a) {
                        const e = a > l ? l : 0;
                        const n = WM(o, a, e);
                        for (const {cell: e} of n) {
                            qM(e, a, t)
                        }
                    }
                    pM("headingRows", a, o, t, 0)
                }))
            }

            _isInHeading(t, e) {
                const n = parseInt(e.getAttribute("headingRows") || 0);
                return !!n && t.parent.index < n
            }
        }

        class dH extends vc {
            refresh() {
                const t = this.editor.model;
                const e = this.editor.plugins.get("TableUtils");
                const n = e.getSelectionAffectedTableCells(t.document.selection);
                const i = n.length > 0;
                this.isEnabled = i;
                this.value = i && n.every((t => kM(e, t)))
            }

            execute(t = {}) {
                if (t.forceValue === this.value) {
                    return
                }
                const e = this.editor.plugins.get("TableUtils");
                const n = this.editor.model;
                const i = e.getSelectionAffectedTableCells(n.document.selection);
                const o = i[0].findAncestor("table");
                const {first: r, last: s} = e.getColumnIndexes(i);
                const a = this.value ? r : s + 1;
                n.change((t => {
                    if (a) {
                        const e = jM(o, a);
                        for (const {cell: n, column: i} of e) {
                            $M(n, i, a, t)
                        }
                    }
                    pM("headingColumns", a, o, t, 0)
                }))
            }
        }

        class uH extends Ac {
            static get pluginName() {
                return "TableUtils"
            }

            init() {
                this.decorate("insertColumns");
                this.decorate("insertRows")
            }

            getCellLocation(t) {
                const e = t.parent;
                const n = e.parent;
                const i = n.getChildIndex(e);
                const o = new SM(n, {row: i});
                for (const {cell: e, row: n, column: i} of o) {
                    if (e === t) {
                        return {row: n, column: i}
                    }
                }
            }

            createTable(t, e) {
                const n = t.createElement("table");
                const i = parseInt(e.rows) || 2;
                const o = parseInt(e.columns) || 2;
                hH(t, n, 0, i, o);
                if (e.headingRows) {
                    pM("headingRows", Math.min(e.headingRows, i), n, t, 0)
                }
                if (e.headingColumns) {
                    pM("headingColumns", Math.min(e.headingColumns, o), n, t, 0)
                }
                return n
            }

            insertRows(t, e = {}) {
                const n = this.editor.model;
                const i = e.at || 0;
                const o = e.rows || 1;
                const r = e.copyStructureFromAbove !== undefined;
                const s = e.copyStructureFromAbove ? i - 1 : i;
                const a = this.getRows(t);
                const l = this.getColumns(t);
                if (i > a) {
                    throw new P("tableutils-insertrows-insert-out-of-range", this, {options: e})
                }
                n.change((e => {
                    const n = t.getAttribute("headingRows") || 0;
                    if (n > i) {
                        pM("headingRows", n + o, t, e, 0)
                    }
                    if (!r && (i === 0 || i === a)) {
                        hH(e, t, i, o, l);
                        return
                    }
                    const c = r ? Math.max(i, s) : i;
                    const d = new SM(t, {endRow: c});
                    const u = new Array(l).fill(1);
                    for (const {row: t, column: n, cellHeight: a, cellWidth: l, cell: c} of d) {
                        const d = t + a - 1;
                        const h = t < i && i <= d;
                        const f = t <= s && s <= d;
                        if (h) {
                            e.setAttribute("rowspan", a + o, c);
                            u[n] = -l
                        } else if (r && f) {
                            u[n] = l
                        }
                    }
                    for (let n = 0; n < o; n++) {
                        const n = e.createElement("tableRow");
                        e.insert(n, t, i);
                        for (let t = 0; t < u.length; t++) {
                            const i = u[t];
                            const o = e.createPositionAt(n, "end");
                            if (i > 0) {
                                bM(e, o, i > 1 ? {colspan: i} : null)
                            }
                            t += Math.abs(i) - 1
                        }
                    }
                }))
            }

            insertColumns(t, e = {}) {
                const n = this.editor.model;
                const i = e.at || 0;
                const o = e.columns || 1;
                n.change((e => {
                    const n = t.getAttribute("headingColumns");
                    if (i < n) {
                        e.setAttribute("headingColumns", n + o, t)
                    }
                    const r = this.getColumns(t);
                    if (i === 0 || r === i) {
                        for (const n of t.getChildren()) {
                            if (!n.is("element", "tableRow")) {
                                continue
                            }
                            fH(o, e, e.createPositionAt(n, i ? "end" : 0))
                        }
                        return
                    }
                    const s = new SM(t, {column: i, includeAllSlots: true});
                    for (const t of s) {
                        const {row: n, cell: r, cellAnchorColumn: a, cellAnchorRow: l, cellWidth: c, cellHeight: d} = t;
                        if (a < i) {
                            e.setAttribute("colspan", c + o, r);
                            const t = l + d - 1;
                            for (let e = n; e <= t; e++) {
                                s.skipRow(e)
                            }
                        } else {
                            fH(o, e, t.getPositionBefore())
                        }
                    }
                }))
            }

            removeRows(t, e) {
                const n = this.editor.model;
                const i = e.rows || 1;
                const o = this.getRows(t);
                const r = e.at;
                const s = r + i - 1;
                if (s > o - 1) {
                    throw new P("tableutils-removerows-row-index-out-of-range", this, {table: t, options: e})
                }
                n.change((e => {
                    const {cellsToMove: n, cellsToTrim: i} = bH(t, r, s);
                    if (n.size) {
                        const i = s + 1;
                        kH(t, i, n, e)
                    }
                    for (let n = s; n >= r; n--) {
                        e.remove(t.getChild(n))
                    }
                    for (const {rowspan: t, cell: n} of i) {
                        pM("rowspan", t, n, e)
                    }
                    pH(t, r, s, e);
                    if (!KM(t, this)) {
                        ZM(t, this)
                    }
                }))
            }

            removeColumns(t, e) {
                const n = this.editor.model;
                const i = e.at;
                const o = e.columns || 1;
                const r = e.at + o - 1;
                n.change((e => {
                    mH(t, {first: i, last: r}, e);
                    for (let n = r; n >= i; n--) {
                        for (const {cell: i, column: o, cellWidth: r} of [...new SM(t)]) {
                            if (o <= n && r > 1 && o + r > n) {
                                pM("colspan", r - 1, i, e)
                            } else if (o === n) {
                                e.remove(i)
                            }
                        }
                    }
                    if (!ZM(t, this)) {
                        KM(t, this)
                    }
                }))
            }

            splitCellVertically(t, e = 2) {
                const n = this.editor.model;
                const i = t.parent;
                const o = i.parent;
                const r = parseInt(t.getAttribute("rowspan") || 1);
                const s = parseInt(t.getAttribute("colspan") || 1);
                n.change((n => {
                    if (s > 1) {
                        const {newCellsSpan: i, updatedSpan: o} = gH(s, e);
                        pM("colspan", o, t, n);
                        const a = {};
                        if (i > 1) {
                            a.colspan = i
                        }
                        if (r > 1) {
                            a.rowspan = r
                        }
                        const l = s > e ? e - 1 : s - 1;
                        fH(l, n, n.createPositionAfter(t), a)
                    }
                    if (s < e) {
                        const i = e - s;
                        const a = [...new SM(o)];
                        const {column: l} = a.find((({cell: e}) => e === t));
                        const c = a.filter((({cell: e, cellWidth: n, column: i}) => {
                            const o = e !== t && i === l;
                            const r = i < l && i + n > l;
                            return o || r
                        }));
                        for (const {cell: t, cellWidth: e} of c) {
                            n.setAttribute("colspan", e + i, t)
                        }
                        const d = {};
                        if (r > 1) {
                            d.rowspan = r
                        }
                        fH(i, n, n.createPositionAfter(t), d);
                        const u = o.getAttribute("headingColumns") || 0;
                        if (u > l) {
                            pM("headingColumns", u + i, o, n)
                        }
                    }
                }))
            }

            splitCellHorizontally(t, e = 2) {
                const n = this.editor.model;
                const i = t.parent;
                const o = i.parent;
                const r = o.getChildIndex(i);
                const s = parseInt(t.getAttribute("rowspan") || 1);
                const a = parseInt(t.getAttribute("colspan") || 1);
                n.change((n => {
                    if (s > 1) {
                        const i = [...new SM(o, {startRow: r, endRow: r + s - 1, includeAllSlots: true})];
                        const {newCellsSpan: l, updatedSpan: c} = gH(s, e);
                        pM("rowspan", c, t, n);
                        const {column: d} = i.find((({cell: e}) => e === t));
                        const u = {};
                        if (l > 1) {
                            u.rowspan = l
                        }
                        if (a > 1) {
                            u.colspan = a
                        }
                        for (const t of i) {
                            const {column: e, row: i} = t;
                            const o = i >= r + c;
                            const s = e === d;
                            const a = (i + r + c) % l === 0;
                            if (o && s && a) {
                                fH(1, n, t.getPositionBefore(), u)
                            }
                        }
                    }
                    if (s < e) {
                        const i = e - s;
                        const l = [...new SM(o, {startRow: 0, endRow: r})];
                        for (const {cell: e, cellHeight: o, row: s} of l) {
                            if (e !== t && s + o > r) {
                                const t = o + i;
                                n.setAttribute("rowspan", t, e)
                            }
                        }
                        const c = {};
                        if (a > 1) {
                            c.colspan = a
                        }
                        hH(n, o, r + 1, i, 1, c);
                        const d = o.getAttribute("headingRows") || 0;
                        if (d > r) {
                            pM("headingRows", d + i, o, n)
                        }
                    }
                }))
            }

            getColumns(t) {
                const e = t.getChild(0);
                return [...e.getChildren()].reduce(((t, e) => {
                    const n = parseInt(e.getAttribute("colspan") || 1);
                    return t + n
                }), 0)
            }

            getRows(t) {
                return Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0)
            }

            createTableWalker(t, e = {}) {
                return new SM(t, e)
            }

            getSelectedTableCells(t) {
                const e = [];
                for (const n of this.sortRanges(t.getRanges())) {
                    const t = n.getContainedElement();
                    if (t && t.is("element", "tableCell")) {
                        e.push(t)
                    }
                }
                return e
            }

            getTableCellsContainingSelection(t) {
                const e = [];
                for (const n of t.getRanges()) {
                    const t = n.start.findAncestor("tableCell");
                    if (t) {
                        e.push(t)
                    }
                }
                return e
            }

            getSelectionAffectedTableCells(t) {
                const e = this.getSelectedTableCells(t);
                if (e.length) {
                    return e
                }
                return this.getTableCellsContainingSelection(t)
            }

            getRowIndexes(t) {
                const e = t.map((t => t.parent.index));
                return this._getFirstLastIndexesObject(e)
            }

            getColumnIndexes(t) {
                const e = t[0].findAncestor("table");
                const n = [...new SM(e)];
                const i = n.filter((e => t.includes(e.cell))).map((t => t.column));
                return this._getFirstLastIndexesObject(i)
            }

            isSelectionRectangular(t) {
                if (t.length < 2 || !this._areCellInTheSameTableSection(t)) {
                    return false
                }
                const e = new Set;
                const n = new Set;
                let i = 0;
                for (const o of t) {
                    const {row: t, column: r} = this.getCellLocation(o);
                    const s = parseInt(o.getAttribute("rowspan") || 1);
                    const a = parseInt(o.getAttribute("colspan") || 1);
                    e.add(t);
                    n.add(r);
                    if (s > 1) {
                        e.add(t + s - 1)
                    }
                    if (a > 1) {
                        n.add(r + a - 1)
                    }
                    i += s * a
                }
                const o = _H(e, n);
                return o == i
            }

            sortRanges(t) {
                return Array.from(t).sort(wH)
            }

            _getFirstLastIndexesObject(t) {
                const e = t.sort(((t, e) => t - e));
                const n = e[0];
                const i = e[e.length - 1];
                return {first: n, last: i}
            }

            _areCellInTheSameTableSection(t) {
                const e = t[0].findAncestor("table");
                const n = this.getRowIndexes(t);
                const i = parseInt(e.getAttribute("headingRows") || 0);
                if (!this._areIndexesInSameSection(n, i)) {
                    return false
                }
                const o = parseInt(e.getAttribute("headingColumns") || 0);
                const r = this.getColumnIndexes(t);
                return this._areIndexesInSameSection(r, o)
            }

            _areIndexesInSameSection({first: t, last: e}, n) {
                const i = t < n;
                const o = e < n;
                return i === o
            }
        }

        function hH(t, e, n, i, o, r = {}) {
            for (let s = 0; s < i; s++) {
                const i = t.createElement("tableRow");
                t.insert(i, e, n);
                fH(o, t, t.createPositionAt(i, "end"), r)
            }
        }

        function fH(t, e, n, i = {}) {
            for (let o = 0; o < t; o++) {
                bM(e, n, i)
            }
        }

        function gH(t, e) {
            if (t < e) {
                return {newCellsSpan: 1, updatedSpan: 1}
            }
            const n = Math.floor(t / e);
            const i = t - n * e + n;
            return {newCellsSpan: n, updatedSpan: i}
        }

        function mH(t, e, n) {
            const i = t.getAttribute("headingColumns") || 0;
            if (i && e.first < i) {
                const o = Math.min(i - 1, e.last) - e.first + 1;
                n.setAttribute("headingColumns", i - o, t)
            }
        }

        function pH(t, e, n, i) {
            const o = t.getAttribute("headingRows") || 0;
            if (e < o) {
                const r = n < o ? o - (n - e + 1) : e;
                pM("headingRows", r, t, i, 0)
            }
        }

        function bH(t, e, n) {
            const i = new Map;
            const o = [];
            for (const {row: r, column: s, cellHeight: a, cell: l} of new SM(t, {endRow: n})) {
                const t = r + a - 1;
                const c = r >= e && r <= n && t > n;
                if (c) {
                    const t = n - r + 1;
                    const e = a - t;
                    i.set(s, {cell: l, rowspan: e})
                }
                const d = r < e && t >= e;
                if (d) {
                    let i;
                    if (t >= n) {
                        i = n - e + 1
                    } else {
                        i = t - e + 1
                    }
                    o.push({cell: l, rowspan: a - i})
                }
            }
            return {cellsToMove: i, cellsToTrim: o}
        }

        function kH(t, e, n, i) {
            const o = new SM(t, {includeAllSlots: true, row: e});
            const r = [...o];
            const s = t.getChild(e);
            let a;
            for (const {column: t, cell: e, isAnchor: o} of r) {
                if (n.has(t)) {
                    const {cell: e, rowspan: o} = n.get(t);
                    const r = a ? i.createPositionAfter(a) : i.createPositionAt(s, 0);
                    i.move(i.createRangeOn(e), r);
                    pM("rowspan", o, e, i);
                    a = e
                } else if (o) {
                    a = e
                }
            }
        }

        function wH(t, e) {
            const n = t.start;
            const i = e.start;
            return n.isBefore(i) ? -1 : 1
        }

        function _H(t, e) {
            const n = Array.from(t.values());
            const i = Array.from(e.values());
            const o = Math.max(...n);
            const r = Math.min(...n);
            const s = Math.max(...i);
            const a = Math.min(...i);
            return (o - r + 1) * (s - a + 1)
        }

        class AH extends vc {
            refresh() {
                const t = this.editor.plugins.get(uH);
                const e = t.getSelectedTableCells(this.editor.model.document.selection);
                this.isEnabled = t.isSelectionRectangular(e, this.editor.plugins.get(uH))
            }

            execute() {
                const t = this.editor.model;
                const e = this.editor.plugins.get(uH);
                t.change((n => {
                    const i = e.getSelectedTableCells(t.document.selection);
                    const o = i.shift();
                    const {mergeWidth: r, mergeHeight: s} = yH(o, i, e);
                    pM("colspan", r, o, n);
                    pM("rowspan", s, o, n);
                    for (const t of i) {
                        CH(t, o, n)
                    }
                    const a = o.findAncestor("table");
                    JM(a, e);
                    n.setSelection(o, "in")
                }))
            }
        }

        function CH(t, e, n) {
            if (!vH(t)) {
                if (vH(e)) {
                    n.remove(n.createRangeIn(e))
                }
                n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))
            }
            n.remove(t)
        }

        function vH(t) {
            return t.childCount == 1 && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
        }

        function yH(t, e, n) {
            let i = 0;
            let o = 0;
            for (const t of e) {
                const {row: e, column: r} = n.getCellLocation(t);
                i = xH(t, r, i, "colspan");
                o = xH(t, e, o, "rowspan")
            }
            const {row: r, column: s} = n.getCellLocation(t);
            const a = i - s;
            const l = o - r;
            return {mergeWidth: a, mergeHeight: l}
        }

        function xH(t, e, n, i) {
            const o = parseInt(t.getAttribute(i) || 1);
            return Math.max(n, e + o)
        }

        class EH extends vc {
            constructor(t) {
                super(t);
                this.affectsData = false
            }

            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = e.length > 0
            }

            execute() {
                const t = this.editor.model;
                const e = this.editor.plugins.get("TableUtils");
                const n = e.getSelectionAffectedTableCells(t.document.selection);
                const i = e.getRowIndexes(n);
                const o = n[0].findAncestor("table");
                const r = [];
                for (let e = i.first; e <= i.last; e++) {
                    for (const n of o.getChild(e).getChildren()) {
                        r.push(t.createRangeOn(n))
                    }
                }
                t.change((t => {
                    t.setSelection(r)
                }))
            }
        }

        class SH extends vc {
            constructor(t) {
                super(t);
                this.affectsData = false
            }

            refresh() {
                const t = this.editor.plugins.get("TableUtils");
                const e = t.getSelectionAffectedTableCells(this.editor.model.document.selection);
                this.isEnabled = e.length > 0
            }

            execute() {
                const t = this.editor.plugins.get("TableUtils");
                const e = this.editor.model;
                const n = t.getSelectionAffectedTableCells(e.document.selection);
                const i = n[0];
                const o = n.pop();
                const r = i.findAncestor("table");
                const s = t.getCellLocation(i);
                const a = t.getCellLocation(o);
                const l = Math.min(s.column, a.column);
                const c = Math.max(s.column, a.column);
                const d = [];
                for (const t of new SM(r, {startColumn: l, endColumn: c})) {
                    d.push(e.createRangeOn(t.cell))
                }
                e.change((t => {
                    t.setSelection(d)
                }))
            }
        }

        function DH(t) {
            t.document.registerPostFixer((e => TH(e, t)))
        }

        function TH(t, e) {
            const n = e.document.differ.getChanges();
            let i = false;
            const o = new Set;
            for (const e of n) {
                let n;
                if (e.name == "table" && e.type == "insert") {
                    n = e.position.nodeAfter
                }
                if (e.name == "tableRow" || e.name == "tableCell") {
                    n = e.position.findAncestor("table")
                }
                if (zH(e)) {
                    n = e.range.start.findAncestor("table")
                }
                if (n && !o.has(n)) {
                    i = BH(n, t) || i;
                    i = PH(n, t) || i;
                    o.add(n)
                }
            }
            return i
        }

        function BH(t, e) {
            let n = false;
            const i = IH(t);
            if (i.length) {
                n = true;
                for (const t of i) {
                    pM("rowspan", t.rowspan, t.cell, e, 1)
                }
            }
            return n
        }

        function PH(t, e) {
            let n = false;
            const i = RH(t);
            const o = [];
            for (const [e, n] of i.entries()) {
                if (!n && t.getChild(e).is("element", "tableRow")) {
                    o.push(e)
                }
            }
            if (o.length) {
                n = true;
                for (const n of o.reverse()) {
                    e.remove(t.getChild(n));
                    i.splice(n, 1)
                }
            }
            const r = i.filter(((e, n) => t.getChild(n).is("element", "tableRow")));
            const s = r[0];
            const a = r.every((t => t === s));
            if (!a) {
                const i = r.reduce(((t, e) => e > t ? e : t), 0);
                for (const [o, s] of r.entries()) {
                    const r = i - s;
                    if (r) {
                        for (let n = 0; n < r; n++) {
                            bM(e, e.createPositionAt(t.getChild(o), "end"))
                        }
                        n = true
                    }
                }
            }
            return n
        }

        function IH(t) {
            const e = parseInt(t.getAttribute("headingRows") || 0);
            const n = Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0);
            const i = [];
            for (const {row: o, cell: r, cellHeight: s} of new SM(t)) {
                if (s < 2) {
                    continue
                }
                const t = o < e;
                const a = t ? e : n;
                if (o + s > a) {
                    const t = a - o;
                    i.push({cell: r, rowspan: t})
                }
            }
            return i
        }

        function RH(t) {
            const e = new Array(t.childCount).fill(0);
            for (const {rowIndex: n} of new SM(t, {includeAllSlots: true})) {
                e[n]++
            }
            return e
        }

        function zH(t) {
            const e = t.type === "attribute";
            const n = t.attributeKey;
            return e && (n === "headingRows" || n === "colspan" || n === "rowspan")
        }

        function VH(t) {
            t.document.registerPostFixer((e => FH(e, t)))
        }

        function FH(t, e) {
            const n = e.document.differ.getChanges();
            let i = false;
            for (const e of n) {
                if (e.type == "insert" && e.name == "table") {
                    i = LH(e.position.nodeAfter, t) || i
                }
                if (e.type == "insert" && e.name == "tableRow") {
                    i = OH(e.position.nodeAfter, t) || i
                }
                if (e.type == "insert" && e.name == "tableCell") {
                    i = NH(e.position.nodeAfter, t) || i
                }
                if (MH(e)) {
                    i = NH(e.position.parent, t) || i
                }
            }
            return i
        }

        function LH(t, e) {
            let n = false;
            for (const i of t.getChildren()) {
                if (i.is("element", "tableRow")) {
                    n = OH(i, e) || n
                }
            }
            return n
        }

        function OH(t, e) {
            let n = false;
            for (const i of t.getChildren()) {
                n = NH(i, e) || n
            }
            return n
        }

        function NH(t, e) {
            if (t.childCount == 0) {
                e.insertElement("paragraph", t);
                return true
            }
            const n = Array.from(t.getChildren()).filter((t => t.is("$text")));
            for (const t of n) {
                e.wrap(e.createRangeOn(t), "paragraph")
            }
            return !!n.length
        }

        function MH(t) {
            if (!t.position || !t.position.parent.is("element", "tableCell")) {
                return false
            }
            return t.type == "insert" && t.name == "$text" || t.type == "remove"
        }

        function HH(t, e) {
            const n = t.document.differ;
            for (const t of n.getChanges()) {
                let n;
                let i = false;
                if (t.type == "attribute") {
                    const e = t.range.start.nodeAfter;
                    if (!e || !e.is("element", "table")) {
                        continue
                    }
                    if (t.attributeKey != "headingRows" && t.attributeKey != "headingColumns") {
                        continue
                    }
                    n = e;
                    i = t.attributeKey == "headingRows"
                } else if (t.name == "tableRow" || t.name == "tableCell") {
                    n = t.position.findAncestor("table");
                    i = t.name == "tableRow"
                }
                if (!n) {
                    continue
                }
                const o = n.getAttribute("headingRows") || 0;
                const r = n.getAttribute("headingColumns") || 0;
                const s = new SM(n);
                for (const t of s) {
                    const n = t.row < o || t.column < r;
                    const s = n ? "th" : "td";
                    const a = e.mapper.toViewElement(t.cell);
                    if (a && a.is("element") && a.name != s) {
                        e.reconvertItem(i ? t.cell.parent : t.cell)
                    }
                }
            }
        }

        function WH(t, e) {
            const n = t.document.differ;
            const i = new Set;
            for (const t of n.getChanges()) {
                const e = t.type == "attribute" ? t.range.start.parent : t.position.parent;
                if (e.is("element", "tableCell")) {
                    i.add(e)
                }
            }
            for (const t of i.values()) {
                const n = Array.from(t.getChildren()).filter((t => qH(t, e.mapper)));
                for (const t of n) {
                    e.reconvertItem(t)
                }
            }
        }

        function qH(t, e) {
            if (!t.is("element", "paragraph")) {
                return false
            }
            const n = e.toViewElement(t);
            if (!n) {
                return false
            }
            return RM(t) !== n.is("element", "span")
        }

        var jH = n(4777);
        var $H = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        $H.insert = "head";
        $H.singleton = true;
        var UH = Bc()(jH.Z, $H);
        const GH = jH.Z.locals || {};

        class KH extends Ac {
            static get pluginName() {
                return "TableEditing"
            }

            static get requires() {
                return [uH]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = e.schema;
                const i = t.conversion;
                const o = t.plugins.get(uH);
                n.register("table", {
                    inheritAllFrom: "$blockObject",
                    allowAttributes: ["headingRows", "headingColumns"]
                });
                n.register("tableRow", {allowIn: "table", isLimit: true});
                n.register("tableCell", {
                    allowContentOf: "$container",
                    allowIn: "tableRow",
                    allowAttributes: ["colspan", "rowspan"],
                    isLimit: true,
                    isSelectable: true
                });
                i.for("upcast").add(_M());
                i.for("upcast").add(AM());
                i.for("editingDowncast").elementToStructure({
                    model: {name: "table", attributes: ["headingRows"]},
                    view: TM(o, {asWidget: true})
                });
                i.for("dataDowncast").elementToStructure({
                    model: {name: "table", attributes: ["headingRows"]},
                    view: TM(o)
                });
                i.for("upcast").elementToElement({model: "tableRow", view: "tr"});
                i.for("upcast").add(CM());
                i.for("downcast").elementToElement({model: "tableRow", view: BM()});
                i.for("upcast").elementToElement({model: "tableCell", view: "td"});
                i.for("upcast").elementToElement({model: "tableCell", view: "th"});
                i.for("upcast").add(vM("td"));
                i.for("upcast").add(vM("th"));
                i.for("editingDowncast").elementToElement({model: "tableCell", view: PM({asWidget: true})});
                i.for("dataDowncast").elementToElement({model: "tableCell", view: PM()});
                i.for("editingDowncast").elementToElement({
                    model: "paragraph",
                    view: IM({asWidget: true}),
                    converterPriority: "high"
                });
                i.for("dataDowncast").elementToElement({model: "paragraph", view: IM(), converterPriority: "high"});
                i.for("downcast").attributeToAttribute({model: "colspan", view: "colspan"});
                i.for("upcast").attributeToAttribute({model: {key: "colspan", value: JH("colspan")}, view: "colspan"});
                i.for("downcast").attributeToAttribute({model: "rowspan", view: "rowspan"});
                i.for("upcast").attributeToAttribute({model: {key: "rowspan", value: JH("rowspan")}, view: "rowspan"});
                t.data.mapper.on("modelToViewPosition", ZH());
                t.config.define("table.defaultHeadings.rows", 0);
                t.config.define("table.defaultHeadings.columns", 0);
                t.commands.add("insertTable", new FM(t));
                t.commands.add("insertTableRowAbove", new OM(t, {order: "above"}));
                t.commands.add("insertTableRowBelow", new OM(t, {order: "below"}));
                t.commands.add("insertTableColumnLeft", new NM(t, {order: "left"}));
                t.commands.add("insertTableColumnRight", new NM(t, {order: "right"}));
                t.commands.add("removeTableRow", new oH(t));
                t.commands.add("removeTableColumn", new sH(t));
                t.commands.add("splitTableCellVertically", new MM(t, {direction: "vertically"}));
                t.commands.add("splitTableCellHorizontally", new MM(t, {direction: "horizontally"}));
                t.commands.add("mergeTableCells", new AH(t));
                t.commands.add("mergeTableCellRight", new XM(t, {direction: "right"}));
                t.commands.add("mergeTableCellLeft", new XM(t, {direction: "left"}));
                t.commands.add("mergeTableCellDown", new XM(t, {direction: "down"}));
                t.commands.add("mergeTableCellUp", new XM(t, {direction: "up"}));
                t.commands.add("setTableColumnHeader", new dH(t));
                t.commands.add("setTableRowHeader", new cH(t));
                t.commands.add("selectTableRow", new EH(t));
                t.commands.add("selectTableColumn", new SH(t));
                DH(e);
                VH(e);
                this.listenTo(e.document, "change:data", (() => {
                    HH(e, t.editing);
                    WH(e, t.editing)
                }))
            }
        }

        function ZH() {
            return (t, e) => {
                const n = e.modelPosition.parent;
                const i = e.modelPosition.nodeBefore;
                if (!n.is("element", "tableCell")) {
                    return
                }
                if (!i || !i.is("element", "paragraph")) {
                    return
                }
                const o = e.mapper.toViewElement(i);
                const r = e.mapper.toViewElement(n);
                if (o === r) {
                    e.viewPosition = e.mapper.findPositionIn(r, i.maxOffset)
                }
            }
        }

        function JH(t) {
            return e => {
                const n = parseInt(e.getAttribute(t));
                if (Number.isNaN(n) || n <= 0) {
                    return null
                }
                return n
            }
        }

        var YH = n(8085);
        var QH = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        QH.insert = "head";
        QH.singleton = true;
        var XH = Bc()(YH.Z, QH);
        const tW = YH.Z.locals || {};

        class eW extends pA {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.items = this._createGridCollection();
                this.keystrokes = new lc;
                this.focusTracker = new ac;
                this.set("rows", 0);
                this.set("columns", 0);
                this.bind("label").to(this, "columns", this, "rows", ((t, e) => `${e} × ${t}`));
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck"]},
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck-insert-table-dropdown__grid"]},
                        on: {"mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover")},
                        children: this.items
                    }, {
                        tag: "div",
                        attributes: {class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": true},
                        children: [{text: e.to("label")}]
                    }],
                    on: {
                        mousedown: e.to((t => {
                            t.preventDefault()
                        })), click: e.to((() => {
                            this.fire("execute")
                        }))
                    }
                });
                this.on("boxover", ((t, e) => {
                    const {row: n, column: i} = e.target.dataset;
                    this.items.get((parseInt(n, 10) - 1) * 10 + (parseInt(i, 10) - 1)).focus()
                }));
                this.focusTracker.on("change:focusedElement", ((t, e, n) => {
                    if (!n) {
                        return
                    }
                    const {row: i, column: o} = n.dataset;
                    this.set({rows: parseInt(i), columns: parseInt(o)})
                }));
                this.on("change:columns", (() => this._highlightGridBoxes()));
                this.on("change:rows", (() => this._highlightGridBoxes()))
            }

            render() {
                super.render();
                EC({
                    keystrokeHandler: this.keystrokes,
                    focusTracker: this.focusTracker,
                    gridItems: this.items,
                    numberOfColumns: 10,
                    uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                });
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this.items.get(0).focus()
            }

            focusLast() {
                this.items.get(0).focus()
            }

            _highlightGridBoxes() {
                const t = this.rows;
                const e = this.columns;
                this.items.map(((n, i) => {
                    const o = Math.floor(i / 10);
                    const r = i % 10;
                    const s = o < t && r < e;
                    n.set("isOn", s)
                }))
            }

            _createGridButton(t, e, n, i) {
                const o = new LC(t);
                o.set({label: i, class: "ck-insert-table-dropdown-grid-box"});
                o.extendTemplate({attributes: {"data-row": e, "data-column": n}});
                return o
            }

            _createGridCollection() {
                const t = [];
                for (let e = 0; e < 100; e++) {
                    const n = Math.floor(e / 10);
                    const i = e % 10;
                    const o = `${n + 1} × ${i + 1}`;
                    t.push(this._createGridButton(this.locale, n + 1, i + 1, o))
                }
                return this.createCollection(t)
            }
        }

        const nW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>';
        const iW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
        const oW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
        const rW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';

        class sW extends Ac {
            static get pluginName() {
                return "TableUI"
            }

            init() {
                const t = this.editor;
                const e = this.editor.t;
                const n = t.locale.contentLanguageDirection;
                const i = n === "ltr";
                t.ui.componentFactory.add("insertTable", (n => {
                    const i = t.commands.get("insertTable");
                    const o = qv(n);
                    o.bind("isEnabled").to(i);
                    o.buttonView.set({icon: nW, label: e("Insert table"), tooltip: true});
                    let r;
                    o.on("change:isOpen", (() => {
                        if (r) {
                            return
                        }
                        r = new eW(n);
                        o.panelView.children.add(r);
                        r.delegate("execute").to(o);
                        o.on("execute", (() => {
                            t.execute("insertTable", {rows: r.rows, columns: r.columns});
                            t.editing.view.focus()
                        }))
                    }));
                    return o
                }));
                t.ui.componentFactory.add("tableColumn", (t => {
                    const n = [{
                        type: "switchbutton",
                        model: {commandName: "setTableColumnHeader", label: e("Header column"), bindIsOn: true}
                    }, {type: "separator"}, {
                        type: "button",
                        model: {
                            commandName: i ? "insertTableColumnLeft" : "insertTableColumnRight",
                            label: e("Insert column left")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "insertTableColumnRight" : "insertTableColumnLeft",
                            label: e("Insert column right")
                        }
                    }, {
                        type: "button",
                        model: {commandName: "removeTableColumn", label: e("Delete column")}
                    }, {type: "button", model: {commandName: "selectTableColumn", label: e("Select column")}}];
                    return this._prepareDropdown(e("Column"), iW, n, t)
                }));
                t.ui.componentFactory.add("tableRow", (t => {
                    const n = [{
                        type: "switchbutton",
                        model: {commandName: "setTableRowHeader", label: e("Header row"), bindIsOn: true}
                    }, {type: "separator"}, {
                        type: "button",
                        model: {commandName: "insertTableRowAbove", label: e("Insert row above")}
                    }, {
                        type: "button",
                        model: {commandName: "insertTableRowBelow", label: e("Insert row below")}
                    }, {
                        type: "button",
                        model: {commandName: "removeTableRow", label: e("Delete row")}
                    }, {type: "button", model: {commandName: "selectTableRow", label: e("Select row")}}];
                    return this._prepareDropdown(e("Row"), oW, n, t)
                }));
                t.ui.componentFactory.add("mergeTableCells", (t => {
                    const n = [{
                        type: "button",
                        model: {commandName: "mergeTableCellUp", label: e("Merge cell up")}
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "mergeTableCellRight" : "mergeTableCellLeft",
                            label: e("Merge cell right")
                        }
                    }, {
                        type: "button",
                        model: {commandName: "mergeTableCellDown", label: e("Merge cell down")}
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "mergeTableCellLeft" : "mergeTableCellRight",
                            label: e("Merge cell left")
                        }
                    }, {type: "separator"}, {
                        type: "button",
                        model: {commandName: "splitTableCellVertically", label: e("Split cell vertically")}
                    }, {
                        type: "button",
                        model: {commandName: "splitTableCellHorizontally", label: e("Split cell horizontally")}
                    }];
                    return this._prepareMergeSplitButtonDropdown(e("Merge cells"), rW, n, t)
                }))
            }

            _prepareDropdown(t, e, n, i) {
                const o = this.editor;
                const r = qv(i);
                const s = this._fillDropdownWithListOptions(r, n);
                r.buttonView.set({label: t, icon: e, tooltip: true});
                r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t))));
                this.listenTo(r, "execute", (t => {
                    o.execute(t.source.commandName);
                    if (!(t.source instanceof WC)) {
                        o.editing.view.focus()
                    }
                }));
                return r
            }

            _prepareMergeSplitButtonDropdown(t, e, n, i) {
                const o = this.editor;
                const r = qv(i, rv);
                const s = "mergeTableCells";
                const a = o.commands.get(s);
                const l = this._fillDropdownWithListOptions(r, n);
                r.buttonView.set({label: t, icon: e, tooltip: true, isEnabled: true});
                r.bind("isEnabled").toMany([a, ...l], "isEnabled", ((...t) => t.some((t => t))));
                this.listenTo(r.buttonView, "execute", (() => {
                    o.execute(s);
                    o.editing.view.focus()
                }));
                this.listenTo(r, "execute", (t => {
                    o.execute(t.source.commandName);
                    o.editing.view.focus()
                }));
                return r
            }

            _fillDropdownWithListOptions(t, e) {
                const n = this.editor;
                const i = [];
                const o = new rc;
                for (const t of e) {
                    aW(t, n, i, o)
                }
                $v(t, o, n.ui.componentFactory);
                return i
            }
        }

        function aW(t, e, n, i) {
            const o = t.model = new Fy(t.model);
            const {commandName: r, bindIsOn: s} = t.model;
            if (t.type === "button" || t.type === "switchbutton") {
                const t = e.commands.get(r);
                n.push(t);
                o.set({commandName: r});
                o.bind("isEnabled").to(t);
                if (s) {
                    o.bind("isOn").to(t, "value")
                }
            }
            o.set({withText: true});
            i.add(t)
        }

        var lW = n(5593);
        var cW = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        cW.insert = "head";
        cW.singleton = true;
        var dW = Bc()(lW.Z, cW);
        const uW = lW.Z.locals || {};

        class hW extends Ac {
            static get pluginName() {
                return "TableSelection"
            }

            static get requires() {
                return [uH, uH]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                this.listenTo(e, "deleteContent", ((t, e) => this._handleDeleteContent(t, e)), {priority: "high"});
                this.listenTo(n.document, "insertText", ((t, e) => this._handleInsertTextEvent(t, e)), {priority: "high"});
                this._defineSelectionConverter();
                this._enablePluginDisabling()
            }

            getSelectedTableCells() {
                const t = this.editor.plugins.get(uH);
                const e = this.editor.model.document.selection;
                const n = t.getSelectedTableCells(e);
                if (n.length == 0) {
                    return null
                }
                return n
            }

            getSelectionAsFragment() {
                const t = this.editor.plugins.get(uH);
                const e = this.getSelectedTableCells();
                if (!e) {
                    return null
                }
                return this.editor.model.change((n => {
                    const i = n.createDocumentFragment();
                    const {first: o, last: r} = t.getColumnIndexes(e);
                    const {first: s, last: a} = t.getRowIndexes(e);
                    const l = e[0].findAncestor("table");
                    let c = a;
                    let d = r;
                    if (t.isSelectionRectangular(e)) {
                        const t = {firstColumn: o, lastColumn: r, firstRow: s, lastRow: a};
                        c = YM(l, t);
                        d = QM(l, t)
                    }
                    const u = {startRow: s, startColumn: o, endRow: c, endColumn: d};
                    const h = HM(l, u, n);
                    n.insert(h, i, 0);
                    return i
                }))
            }

            setCellSelection(t, e) {
                const n = this._getCellsToSelect(t, e);
                this.editor.model.change((t => {
                    t.setSelection(n.cells.map((e => t.createRangeOn(e))), {backward: n.backward})
                }))
            }

            getFocusCell() {
                const t = this.editor.model.document.selection;
                const e = [...t.getRanges()].pop();
                const n = e.getContainedElement();
                if (n && n.is("element", "tableCell")) {
                    return n
                }
                return null
            }

            getAnchorCell() {
                const t = this.editor.model.document.selection;
                const e = sc(t.getRanges());
                const n = e.getContainedElement();
                if (n && n.is("element", "tableCell")) {
                    return n
                }
                return null
            }

            _defineSelectionConverter() {
                const t = this.editor;
                const e = new Set;
                t.conversion.for("editingDowncast").add((t => t.on("selection", ((t, i, o) => {
                    const r = o.writer;
                    n(r);
                    const s = this.getSelectedTableCells();
                    if (!s) {
                        return
                    }
                    for (const t of s) {
                        const n = o.mapper.toViewElement(t);
                        r.addClass("ck-editor__editable_selected", n);
                        e.add(n)
                    }
                    const a = o.mapper.toViewElement(s[s.length - 1]);
                    r.setSelection(a, 0)
                }), {priority: "lowest"})));

                function n(t) {
                    for (const n of e) {
                        t.removeClass("ck-editor__editable_selected", n)
                    }
                    e.clear()
                }
            }

            _enablePluginDisabling() {
                const t = this.editor;
                this.on("change:isEnabled", (() => {
                    if (!this.isEnabled) {
                        const e = this.getSelectedTableCells();
                        if (!e) {
                            return
                        }
                        t.model.change((n => {
                            const i = n.createPositionAt(e[0], 0);
                            const o = t.model.schema.getNearestSelectionRange(i);
                            n.setSelection(o)
                        }))
                    }
                }))
            }

            _handleDeleteContent(t, e) {
                const n = this.editor.plugins.get(uH);
                const [i, o] = e;
                const r = this.editor.model;
                const s = !o || o.direction == "backward";
                const a = n.getSelectedTableCells(i);
                if (!a.length) {
                    return
                }
                t.stop();
                r.change((t => {
                    const e = a[s ? a.length - 1 : 0];
                    r.change((t => {
                        for (const e of a) {
                            r.deleteContent(t.createSelection(e, "in"))
                        }
                    }));
                    const n = r.schema.getNearestSelectionRange(t.createPositionAt(e, 0));
                    if (i.is("documentSelection")) {
                        t.setSelection(n)
                    } else {
                        i.setTo(n)
                    }
                }))
            }

            _handleInsertTextEvent(t, e) {
                const n = this.editor;
                const i = n.model;
                const o = i.document.selection;
                const r = this.getSelectedTableCells(o);
                if (!r) {
                    return
                }
                const s = n.editing.view;
                const a = n.editing.mapper;
                const l = r.map((t => s.createRangeOn(a.toViewElement(t))));
                e.selection = s.createSelection(l)
            }

            _getCellsToSelect(t, e) {
                const n = this.editor.plugins.get("TableUtils");
                const i = n.getCellLocation(t);
                const o = n.getCellLocation(e);
                const r = Math.min(i.row, o.row);
                const s = Math.max(i.row, o.row);
                const a = Math.min(i.column, o.column);
                const l = Math.max(i.column, o.column);
                const c = new Array(s - r + 1).fill(null).map((() => []));
                const d = {startRow: r, endRow: s, startColumn: a, endColumn: l};
                for (const {row: e, cell: n} of new SM(t.findAncestor("table"), d)) {
                    c[e - r].push(n)
                }
                const u = o.row < i.row;
                const h = o.column < i.column;
                if (u) {
                    c.reverse()
                }
                if (h) {
                    c.forEach((t => t.reverse()))
                }
                return {cells: c.flat(), backward: u || h}
            }
        }

        class fW extends Ac {
            static get pluginName() {
                return "TableClipboard"
            }

            static get requires() {
                return [hW, uH]
            }

            init() {
                const t = this.editor;
                const e = t.editing.view.document;
                this.listenTo(e, "copy", ((t, e) => this._onCopyCut(t, e)));
                this.listenTo(e, "cut", ((t, e) => this._onCopyCut(t, e)));
                this.listenTo(t.model, "insertContent", ((t, e) => this._onInsertContent(t, ...e)), {priority: "high"});
                this.decorate("_replaceTableSlotCell")
            }

            _onCopyCut(t, e) {
                const n = this.editor.plugins.get(hW);
                if (!n.getSelectedTableCells()) {
                    return
                }
                if (t.name == "cut" && this.editor.isReadOnly) {
                    return
                }
                e.preventDefault();
                t.stop();
                const i = this.editor.data;
                const o = this.editor.editing.view.document;
                const r = i.toView(n.getSelectionAsFragment());
                o.fire("clipboardOutput", {dataTransfer: e.dataTransfer, content: r, method: t.name})
            }

            _onInsertContent(t, e, n) {
                if (n && !n.is("documentSelection")) {
                    return
                }
                const i = this.editor.model;
                const o = this.editor.plugins.get(uH);
                let r = gW(e, i);
                if (!r) {
                    return
                }
                const s = o.getSelectionAffectedTableCells(i.document.selection);
                if (!s.length) {
                    JM(r, o);
                    return
                }
                t.stop();
                i.change((t => {
                    const e = {width: o.getColumns(r), height: o.getRows(r)};
                    const n = mW(s, e, t, o);
                    const i = n.lastRow - n.firstRow + 1;
                    const a = n.lastColumn - n.firstColumn + 1;
                    const l = {
                        startRow: 0,
                        startColumn: 0,
                        endRow: Math.min(i, e.height) - 1,
                        endColumn: Math.min(a, e.width) - 1
                    };
                    r = HM(r, l, t);
                    const c = s[0].findAncestor("table");
                    const d = this._replaceSelectedCellsWithPasted(r, e, c, n, t);
                    if (this.editor.plugins.get("TableSelection").isEnabled) {
                        const e = o.sortRanges(d.map((e => t.createRangeOn(e))));
                        t.setSelection(e)
                    } else {
                        t.setSelection(d[0], 0)
                    }
                }))
            }

            _replaceSelectedCellsWithPasted(t, e, n, i, o) {
                const {width: r, height: s} = e;
                const a = bW(t, r, s);
                const l = [...new SM(n, {
                    startRow: i.firstRow,
                    endRow: i.lastRow,
                    startColumn: i.firstColumn,
                    endColumn: i.lastColumn,
                    includeAllSlots: true
                })];
                const c = [];
                let d;
                for (const t of l) {
                    const {row: e, column: n} = t;
                    if (n === i.firstColumn) {
                        d = t.getPositionBefore()
                    }
                    const l = e - i.firstRow;
                    const u = n - i.firstColumn;
                    const h = a[l % s][u % r];
                    const f = h ? o.cloneElement(h) : null;
                    const g = this._replaceTableSlotCell(t, f, d, o);
                    if (!g) {
                        continue
                    }
                    UM(g, e, n, i.lastRow, i.lastColumn, o);
                    c.push(g);
                    d = o.createPositionAfter(g)
                }
                const u = parseInt(n.getAttribute("headingRows") || 0);
                const h = parseInt(n.getAttribute("headingColumns") || 0);
                const f = i.firstRow < u && u <= i.lastRow;
                const g = i.firstColumn < h && h <= i.lastColumn;
                if (f) {
                    const t = {first: i.firstColumn, last: i.lastColumn};
                    const e = wW(n, u, t, o, i.firstRow);
                    c.push(...e)
                }
                if (g) {
                    const t = {first: i.firstRow, last: i.lastRow};
                    const e = _W(n, h, t, o);
                    c.push(...e)
                }
                return c
            }

            _replaceTableSlotCell(t, e, n, i) {
                const {cell: o, isAnchor: r} = t;
                if (r) {
                    i.remove(o)
                }
                if (!e) {
                    return null
                }
                i.insert(e, n);
                return e
            }

            getTableIfOnlyTableInContent(t, e) {
                return gW(t, e)
            }
        }

        function gW(t, e) {
            if (!t.is("documentFragment") && !t.is("element")) {
                return null
            }
            if (t.is("element", "table")) {
                return t
            }
            if (t.childCount == 1 && t.getChild(0).is("element", "table")) {
                return t.getChild(0)
            }
            const n = e.createRangeIn(t);
            for (const t of n.getItems()) {
                if (t.is("element", "table")) {
                    const i = e.createRange(n.start, e.createPositionBefore(t));
                    if (e.hasContent(i, {ignoreWhitespaces: true})) {
                        return null
                    }
                    const o = e.createRange(e.createPositionAfter(t), n.end);
                    if (e.hasContent(o, {ignoreWhitespaces: true})) {
                        return null
                    }
                    return t
                }
            }
            return null
        }

        function mW(t, e, n, i) {
            const o = t[0].findAncestor("table");
            const r = i.getColumnIndexes(t);
            const s = i.getRowIndexes(t);
            const a = {firstColumn: r.first, lastColumn: r.last, firstRow: s.first, lastRow: s.last};
            const l = t.length === 1;
            if (l) {
                a.lastRow += e.height - 1;
                a.lastColumn += e.width - 1;
                pW(o, a.lastRow + 1, a.lastColumn + 1, i)
            }
            if (l || !i.isSelectionRectangular(t)) {
                kW(o, a, n)
            } else {
                a.lastRow = YM(o, a);
                a.lastColumn = QM(o, a)
            }
            return a
        }

        function pW(t, e, n, i) {
            const o = i.getColumns(t);
            const r = i.getRows(t);
            if (n > o) {
                i.insertColumns(t, {at: o, columns: n - o})
            }
            if (e > r) {
                i.insertRows(t, {at: r, rows: e - r})
            }
        }

        function bW(t, e, n) {
            const i = new Array(n).fill(null).map((() => new Array(e).fill(null)));
            for (const {column: e, row: n, cell: o} of new SM(t)) {
                i[n][e] = o
            }
            return i
        }

        function kW(t, e, n) {
            const {firstRow: i, lastRow: o, firstColumn: r, lastColumn: s} = e;
            const a = {first: i, last: o};
            const l = {first: r, last: s};
            _W(t, r, a, n);
            _W(t, s + 1, a, n);
            wW(t, i, l, n);
            wW(t, o + 1, l, n, i)
        }

        function wW(t, e, n, i, o = 0) {
            if (e < 1) {
                return
            }
            const r = WM(t, e, o);
            const s = r.filter((({column: t, cellWidth: e}) => AW(t, e, n)));
            return s.map((({cell: t}) => qM(t, e, i)))
        }

        function _W(t, e, n, i) {
            if (e < 1) {
                return
            }
            const o = jM(t, e);
            const r = o.filter((({row: t, cellHeight: e}) => AW(t, e, n)));
            return r.map((({cell: t, column: n}) => $M(t, n, e, i)))
        }

        function AW(t, e, n) {
            const i = t + e - 1;
            const {first: o, last: r} = n;
            const s = t >= o && t <= r;
            const a = t < o && i >= o;
            return s || a
        }

        class CW extends Ac {
            static get pluginName() {
                return "TableKeyboard"
            }

            static get requires() {
                return [hW, uH]
            }

            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                this.listenTo(e, "arrowKey", ((...t) => this._onArrowKey(...t)), {context: "table"});
                this.listenTo(e, "tab", ((...t) => this._handleTabOnSelectedTable(...t)), {context: "figure"});
                this.listenTo(e, "tab", ((...t) => this._handleTab(...t)), {context: ["th", "td"]})
            }

            _handleTabOnSelectedTable(t, e) {
                const n = this.editor;
                const i = n.model.document.selection;
                const o = i.getSelectedElement();
                if (!o || !o.is("element", "table")) {
                    return
                }
                e.preventDefault();
                e.stopPropagation();
                t.stop();
                n.model.change((t => {
                    t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)))
                }))
            }

            _handleTab(t, e) {
                const n = this.editor;
                const i = this.editor.plugins.get(uH);
                const o = n.model.document.selection;
                const r = !e.shiftKey;
                let s = i.getTableCellsContainingSelection(o)[0];
                if (!s) {
                    s = this.editor.plugins.get("TableSelection").getFocusCell()
                }
                if (!s) {
                    return
                }
                e.preventDefault();
                e.stopPropagation();
                t.stop();
                const a = s.parent;
                const l = a.parent;
                const c = l.getChildIndex(a);
                const d = a.getChildIndex(s);
                const u = d === 0;
                if (!r && u && c === 0) {
                    n.model.change((t => {
                        t.setSelection(t.createRangeOn(l))
                    }));
                    return
                }
                const h = d === a.childCount - 1;
                const f = c === i.getRows(l) - 1;
                if (r && f && h) {
                    n.execute("insertTableRowBelow");
                    if (c === i.getRows(l) - 1) {
                        n.model.change((t => {
                            t.setSelection(t.createRangeOn(l))
                        }));
                        return
                    }
                }
                let g;
                if (r && h) {
                    const t = l.getChild(c + 1);
                    g = t.getChild(0)
                } else if (!r && u) {
                    const t = l.getChild(c - 1);
                    g = t.getChild(t.childCount - 1)
                } else {
                    g = a.getChild(d + (r ? 1 : -1))
                }
                n.model.change((t => {
                    t.setSelection(t.createRangeIn(g))
                }))
            }

            _onArrowKey(t, e) {
                const n = this.editor;
                const i = e.keyCode;
                const o = jl(i, n.locale.contentLanguageDirection);
                const r = this._handleArrowKeys(o, e.shiftKey);
                if (r) {
                    e.preventDefault();
                    e.stopPropagation();
                    t.stop()
                }
            }

            _handleArrowKeys(t, e) {
                const n = this.editor.plugins.get(uH);
                const i = this.editor.model;
                const o = i.document.selection;
                const r = ["right", "down"].includes(t);
                const s = n.getSelectedTableCells(o);
                if (s.length) {
                    let n;
                    if (e) {
                        n = this.editor.plugins.get("TableSelection").getFocusCell()
                    } else {
                        n = r ? s[s.length - 1] : s[0]
                    }
                    this._navigateFromCellInDirection(n, t, e);
                    return true
                }
                const a = o.focus.findAncestor("tableCell");
                if (!a) {
                    return false
                }
                if (!o.isCollapsed) {
                    if (e) {
                        if (o.isBackward == r && !o.containsEntireContent(a)) {
                            return false
                        }
                    } else {
                        const t = o.getSelectedElement();
                        if (!t || !i.schema.isObject(t)) {
                            return false
                        }
                    }
                }
                if (this._isSelectionAtCellEdge(o, a, r)) {
                    this._navigateFromCellInDirection(a, t, e);
                    return true
                }
                return false
            }

            _isSelectionAtCellEdge(t, e, n) {
                const i = this.editor.model;
                const o = this.editor.model.schema;
                const r = n ? t.getLastPosition() : t.getFirstPosition();
                if (!o.getLimitElement(r).is("element", "tableCell")) {
                    const t = i.createPositionAt(e, n ? "end" : 0);
                    return t.isTouching(r)
                }
                const s = i.createSelection(r);
                i.modifySelection(s, {direction: n ? "forward" : "backward"});
                return r.isEqual(s.focus)
            }

            _navigateFromCellInDirection(t, e, n = false) {
                const i = this.editor.model;
                const o = t.findAncestor("table");
                const r = [...new SM(o, {includeAllSlots: true})];
                const {row: s, column: a} = r[r.length - 1];
                const l = r.find((({cell: e}) => e == t));
                let {row: c, column: d} = l;
                switch (e) {
                    case"left":
                        d--;
                        break;
                    case"up":
                        c--;
                        break;
                    case"right":
                        d += l.cellWidth;
                        break;
                    case"down":
                        c += l.cellHeight;
                        break
                }
                const u = c < 0 || c > s;
                const h = d < 0 && c <= 0;
                const f = d > a && c >= s;
                if (u || h || f) {
                    i.change((t => {
                        t.setSelection(t.createRangeOn(o))
                    }));
                    return
                }
                if (d < 0) {
                    d = n ? 0 : a;
                    c--
                } else if (d > a) {
                    d = n ? a : 0;
                    c++
                }
                const g = r.find((t => t.row == c && t.column == d)).cell;
                const m = ["right", "down"].includes(e);
                const p = this.editor.plugins.get("TableSelection");
                if (n && p.isEnabled) {
                    const e = p.getAnchorCell() || t;
                    p.setCellSelection(e, g)
                } else {
                    const t = i.createPositionAt(g, m ? 0 : "end");
                    i.change((e => {
                        e.setSelection(t)
                    }))
                }
            }
        }

        class vW extends Pf {
            constructor(t) {
                super(t);
                this.domEventType = ["mousemove", "mouseleave"]
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        class yW extends Ac {
            static get pluginName() {
                return "TableMouse"
            }

            static get requires() {
                return [hW, uH]
            }

            init() {
                const t = this.editor;
                t.editing.view.addObserver(vW);
                this._enableShiftClickSelection();
                this._enableMouseDragSelection()
            }

            _enableShiftClickSelection() {
                const t = this.editor;
                const e = t.plugins.get(uH);
                let n = false;
                const i = t.plugins.get(hW);
                this.listenTo(t.editing.view.document, "mousedown", ((o, r) => {
                    const s = t.model.document.selection;
                    if (!this.isEnabled || !i.isEnabled) {
                        return
                    }
                    if (!r.domEvent.shiftKey) {
                        return
                    }
                    const a = i.getAnchorCell() || e.getTableCellsContainingSelection(s)[0];
                    if (!a) {
                        return
                    }
                    const l = this._getModelTableCellFromDomEvent(r);
                    if (l && xW(a, l)) {
                        n = true;
                        i.setCellSelection(a, l);
                        r.preventDefault()
                    }
                }));
                this.listenTo(t.editing.view.document, "mouseup", (() => {
                    n = false
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    if (n) {
                        t.stop()
                    }
                }), {priority: "highest"})
            }

            _enableMouseDragSelection() {
                const t = this.editor;
                let e, n;
                let i = false;
                let o = false;
                const r = t.plugins.get(hW);
                this.listenTo(t.editing.view.document, "mousedown", ((t, n) => {
                    if (!this.isEnabled || !r.isEnabled) {
                        return
                    }
                    if (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey) {
                        return
                    }
                    e = this._getModelTableCellFromDomEvent(n)
                }));
                this.listenTo(t.editing.view.document, "mousemove", ((t, s) => {
                    if (!s.domEvent.buttons) {
                        return
                    }
                    if (!e) {
                        return
                    }
                    const a = this._getModelTableCellFromDomEvent(s);
                    if (a && xW(e, a)) {
                        n = a;
                        if (!i && n != e) {
                            i = true
                        }
                    }
                    if (!i) {
                        return
                    }
                    o = true;
                    r.setCellSelection(e, n);
                    s.preventDefault()
                }));
                this.listenTo(t.editing.view.document, "mouseup", (() => {
                    i = false;
                    o = false;
                    e = null;
                    n = null
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    if (o) {
                        t.stop()
                    }
                }), {priority: "highest"})
            }

            _getModelTableCellFromDomEvent(t) {
                const e = t.target;
                const n = this.editor.editing.view.createPositionAt(e, 0);
                const i = this.editor.editing.mapper.toModelPosition(n);
                const o = i.parent;
                return o.findAncestor("tableCell", {includeSelf: true})
            }
        }

        function xW(t, e) {
            return t.parent.parent == e.parent.parent
        }

        var EW = n(4104);
        var SW = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        SW.insert = "head";
        SW.singleton = true;
        var DW = Bc()(EW.Z, SW);
        const TW = EW.Z.locals || {};

        class BW extends Ac {
            static get requires() {
                return [KH, sW, hW, yW, CW, fW, zI]
            }

            static get pluginName() {
                return "Table"
            }
        }

        function PW(t) {
            t.document.registerPostFixer((e => IW(e, t)))
        }

        function IW(t, e) {
            const n = e.document.differ.getChanges();
            let i = false;
            for (const e of n) {
                if (e.type != "insert") {
                    continue
                }
                const n = e.position.parent;
                if (n.is("element", "table") || e.name == "table") {
                    const n = e.name == "table" ? e.position.nodeAfter : e.position.parent;
                    const o = Array.from(n.getChildren()).filter((t => t.is("element", "caption")));
                    const r = o.shift();
                    if (!r) {
                        continue
                    }
                    for (const e of o) {
                        t.move(t.createRangeIn(e), r, "end");
                        t.remove(e)
                    }
                    if (r.nextSibling) {
                        t.move(t.createRangeOn(r), n, "end");
                        i = true
                    }
                    i = !!o.length || i
                }
            }
            return i
        }

        function RW(t) {
            return !!t && t.is("element", "table")
        }

        function zW(t) {
            for (const e of t.getChildren()) {
                if (e.is("element", "caption")) {
                    return e
                }
            }
            return null
        }

        function VW(t) {
            const e = LW(t);
            if (!e) {
                return null
            }
            return zW(e)
        }

        function FW(t) {
            const e = t.parent;
            if (t.name == "figcaption" && e && e.name == "figure" && e.hasClass("table")) {
                return {name: true}
            }
            if (t.name == "caption" && e && e.name == "table") {
                return {name: true}
            }
            return null
        }

        function LW(t) {
            const e = t.getSelectedElement();
            if (e && e.is("element", "table")) {
                return e
            }
            return t.getFirstPosition().findAncestor("table")
        }

        class OW extends vc {
            refresh() {
                const t = this.editor;
                const e = LW(t.model.document.selection);
                this.isEnabled = !!e;
                if (!this.isEnabled) {
                    this.value = false
                } else {
                    this.value = !!zW(e)
                }
            }

            execute(t = {}) {
                const {focusCaptionOnShow: e} = t;
                this.editor.model.change((t => {
                    if (this.value) {
                        this._hideTableCaption(t)
                    } else {
                        this._showTableCaption(t, e)
                    }
                }))
            }

            _showTableCaption(t, e) {
                const n = this.editor.model;
                const i = LW(n.document.selection);
                const o = this.editor.plugins.get("TableCaptionEditing");
                const r = o._getSavedCaption(i);
                const s = r || t.createElement("caption");
                n.insertContent(s, i, "end");
                if (e) {
                    t.setSelection(s, "in")
                }
            }

            _hideTableCaption(t) {
                const e = this.editor.model;
                const n = LW(e.document.selection);
                const i = this.editor.plugins.get("TableCaptionEditing");
                const o = zW(n);
                i._saveCaption(n, o);
                e.deleteContent(t.createSelection(o, "on"))
            }
        }

        class NW extends Ac {
            static get pluginName() {
                return "TableCaptionEditing"
            }

            constructor(t) {
                super(t);
                this._savedCaptionsMap = new WeakMap
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.editing.view;
                const i = t.t;
                if (!e.isRegistered("caption")) {
                    e.register("caption", {allowIn: "table", allowContentOf: "$block", isLimit: true})
                } else {
                    e.extend("caption", {allowIn: "table"})
                }
                t.commands.add("toggleTableCaption", new OW(this.editor));
                t.conversion.for("upcast").elementToElement({view: FW, model: "caption"});
                t.conversion.for("dataDowncast").elementToElement({
                    model: "caption", view: (t, {writer: e}) => {
                        if (!RW(t.parent)) {
                            return null
                        }
                        return e.createContainerElement("figcaption")
                    }
                });
                t.conversion.for("editingDowncast").elementToElement({
                    model: "caption", view: (t, {writer: e}) => {
                        if (!RW(t.parent)) {
                            return null
                        }
                        const o = e.createEditableElement("figcaption");
                        e.setCustomProperty("tableCaption", true, o);
                        Fc({view: n, element: o, text: i("Enter table caption"), keepOnFocus: true});
                        return tI(o, e)
                    }
                });
                PW(t.model)
            }

            _getSavedCaption(t) {
                const e = this._savedCaptionsMap.get(t);
                return e ? mm.fromJSON(e) : null
            }

            _saveCaption(t, e) {
                this._savedCaptionsMap.set(t, e.toJSON())
            }
        }

        class MW extends Ac {
            static get pluginName() {
                return "TableCaptionUI"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = t.t;
                t.ui.componentFactory.add("toggleTableCaption", (i => {
                    const o = t.commands.get("toggleTableCaption");
                    const r = new LC(i);
                    r.set({icon: CC.caption, tooltip: true, isToggleable: true});
                    r.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
                    r.bind("label").to(o, "value", (t => t ? n("Toggle caption off") : n("Toggle caption on")));
                    this.listenTo(r, "execute", (() => {
                        t.execute("toggleTableCaption", {focusCaptionOnShow: true});
                        if (o.value) {
                            const n = VW(t.model.document.selection);
                            const i = t.editing.mapper.toViewElement(n);
                            if (!i) {
                                return
                            }
                            e.scrollToTheSelection();
                            e.change((t => {
                                t.addClass("table__caption_highlighted", i)
                            }))
                        }
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }
        }

        var HW = n(9888);
        var WW = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        WW.insert = "head";
        WW.singleton = true;
        var qW = Bc()(HW.Z, WW);
        const jW = HW.Z.locals || {};

        class $W extends Ac {
            static get pluginName() {
                return "TableCaption"
            }

            static get requires() {
                return [NW, MW]
            }
        }

        var UW = n(4082);
        var GW = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        GW.insert = "head";
        GW.singleton = true;
        var KW = Bc()(UW.Z, GW);
        const ZW = UW.Z.locals || {};

        class JW extends pA {
            constructor(t, e) {
                super(t);
                this.set("value", "");
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.set("isEmpty", true);
                this.options = e;
                this.focusTracker = new ac;
                this._focusables = new F_;
                this.dropdownView = this._createDropdownView();
                this.inputView = this._createInputTextView();
                this.keystrokes = new lc;
                this._stillTyping = false;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-input-color"]},
                    children: [this.dropdownView, this.inputView]
                });
                this.on("change:value", ((t, e, n) => this._setInputValue(n)))
            }

            render() {
                super.render();
                this.keystrokes.listenTo(this.dropdownView.panelView.element)
            }

            focus() {
                this.inputView.focus()
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            _createDropdownView() {
                const t = this.locale;
                const e = t.t;
                const n = this.bindTemplate;
                const i = this._createColorGrid(t);
                const o = qv(t);
                const r = new pA;
                const s = this._createRemoveColorButton();
                r.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-input-color__button__preview"],
                        style: {backgroundColor: n.to("value")}
                    },
                    children: [{
                        tag: "span",
                        attributes: {class: ["ck", "ck-input-color__button__preview__no-color-indicator", n.if("value", "ck-hidden", (t => t != ""))]}
                    }]
                });
                o.buttonView.extendTemplate({attributes: {class: "ck-input-color__button"}});
                o.buttonView.children.add(r);
                o.buttonView.label = e("Color picker");
                o.buttonView.tooltip = true;
                o.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw";
                o.panelView.children.add(s);
                o.panelView.children.add(i);
                o.bind("isEnabled").to(this, "isReadOnly", (t => !t));
                this._focusables.add(s);
                this._focusables.add(i);
                this.focusTracker.add(s.element);
                this.focusTracker.add(i.element);
                return o
            }

            _createInputTextView() {
                const t = this.locale;
                const e = new yy(t);
                e.extendTemplate({on: {blur: e.bindTemplate.to("blur")}});
                e.value = this.value;
                e.bind("isReadOnly", "hasError").to(this);
                this.bind("isFocused", "isEmpty").to(e);
                e.on("input", (() => {
                    const t = e.element.value;
                    const n = this.options.colorDefinitions.find((e => t === e.label));
                    this._stillTyping = true;
                    this.value = n && n.color || t
                }));
                e.on("blur", (() => {
                    this._stillTyping = false;
                    this._setInputValue(e.element.value)
                }));
                e.delegate("input").to(this);
                return e
            }

            _createRemoveColorButton() {
                const t = this.locale;
                const e = t.t;
                const n = new LC(t);
                const i = this.options.defaultColorValue || "";
                const o = i ? e("Restore default") : e("Remove color");
                n.class = "ck-input-color__remove-color";
                n.withText = true;
                n.icon = CC.eraser;
                n.label = o;
                n.on("execute", (() => {
                    this.value = i;
                    this.dropdownView.isOpen = false;
                    this.fire("input")
                }));
                return n
            }

            _createColorGrid(t) {
                const e = new QC(t, {colorDefinitions: this.options.colorDefinitions, columns: this.options.columns});
                e.on("execute", ((t, e) => {
                    this.value = e.value;
                    this.dropdownView.isOpen = false;
                    this.fire("input")
                }));
                e.bind("selectedColor").to(this, "value");
                return e
            }

            _setInputValue(t) {
                if (!this._stillTyping) {
                    const e = YW(t);
                    const n = this.options.colorDefinitions.find((t => e === YW(t.color)));
                    if (n) {
                        this.inputView.value = n.label
                    } else {
                        this.inputView.value = t || ""
                    }
                }
            }
        }

        function YW(t) {
            return t.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ")
        }

        const QW = t => t === "";

        function XW(t) {
            return {
                none: t("None"),
                solid: t("Solid"),
                dotted: t("Dotted"),
                dashed: t("Dashed"),
                double: t("Double"),
                groove: t("Groove"),
                ridge: t("Ridge"),
                inset: t("Inset"),
                outset: t("Outset")
            }
        }

        function tq(t) {
            return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".')
        }

        function eq(t) {
            return t('The value is invalid. Try "10px" or "2em" or simply "2".')
        }

        function nq(t) {
            t = t.trim();
            return QW(t) || Gw(t)
        }

        function iq(t) {
            t = t.trim();
            return QW(t) || cq(t) || Yw(t) || Xw(t)
        }

        function oq(t) {
            t = t.trim();
            return QW(t) || cq(t) || Yw(t)
        }

        function rq(t, e) {
            const n = new rc;
            const i = XW(t.t);
            for (const o in i) {
                const r = {type: "button", model: new Fy({_borderStyleValue: o, label: i[o], withText: true})};
                if (o === "none") {
                    r.model.bind("isOn").to(t, "borderStyle", (t => {
                        if (e === "none") {
                            return !t
                        }
                        return t === o
                    }))
                } else {
                    r.model.bind("isOn").to(t, "borderStyle", (t => t === o))
                }
                n.add(r)
            }
            return n
        }

        function sq(t) {
            const {view: e, icons: n, toolbar: i, labels: o, propertyName: r, nameToValue: s, defaultValue: a} = t;
            for (const t in o) {
                const l = new LC(e.locale);
                l.set({label: o[t], icon: n[t], tooltip: o[t]});
                const c = s ? s(t) : t;
                l.bind("isOn").to(e, r, (t => {
                    let e = t;
                    if (t === "" && a) {
                        e = a
                    }
                    return c === e
                }));
                l.on("execute", (() => {
                    e[r] = c
                }));
                i.items.add(l)
            }
        }

        const aq = [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
            color: "hsl(0, 0%, 30%)",
            label: "Dim grey"
        }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
            color: "hsl(0, 0%, 90%)",
            label: "Light grey"
        }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
            color: "hsl(0, 75%, 60%)",
            label: "Red"
        }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
            color: "hsl(60, 75%, 60%)",
            label: "Yellow"
        }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
            color: "hsl(120, 75%, 60%)",
            label: "Green"
        }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
            color: "hsl(180, 75%, 60%)",
            label: "Turquoise"
        }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
            color: "hsl(240, 75%, 60%)",
            label: "Blue"
        }, {color: "hsl(270, 75%, 60%)", label: "Purple"}];

        function lq(t) {
            return (e, n, i) => {
                const o = new JW(e.locale, {
                    colorDefinitions: dq(t.colorConfig),
                    columns: t.columns,
                    defaultColorValue: t.defaultColorValue
                });
                o.inputView.set({id: n, ariaDescribedById: i});
                o.bind("isReadOnly").to(e, "isEnabled", (t => !t));
                o.bind("hasError").to(e, "errorText", (t => !!t));
                o.on("input", (() => {
                    e.errorText = null
                }));
                e.bind("isEmpty", "isFocused").to(o);
                return o
            }
        }

        function cq(t) {
            const e = parseFloat(t);
            return !Number.isNaN(e) && t === String(e)
        }

        function dq(t) {
            return t.map((t => ({color: t.model, label: t.label, options: {hasBorder: t.hasBorder}})))
        }

        var uq = n(9865);
        var hq = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        hq.insert = "head";
        hq.singleton = true;
        var fq = Bc()(uq.Z, hq);
        const gq = uq.Z.locals || {};

        class mq extends pA {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("class", e.class || null);
                this.children = this.createCollection();
                if (e.children) {
                    e.children.forEach((t => this.children.add(t)))
                }
                this.set("_role", null);
                this.set("_ariaLabelledBy", null);
                if (e.labelView) {
                    this.set({_role: "group", _ariaLabelledBy: e.labelView.id})
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-form__row", n.to("class")],
                        role: n.to("_role"),
                        "aria-labelledby": n.to("_ariaLabelledBy")
                    },
                    children: this.children
                })
            }
        }

        var pq = n(4880);
        var bq = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        bq.insert = "head";
        bq.singleton = true;
        var kq = Bc()(pq.Z, bq);
        const wq = pq.Z.locals || {};
        var _q = n(198);
        var Aq = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Aq.insert = "head";
        Aq.singleton = true;
        var Cq = Bc()(_q.Z, Aq);
        const vq = _q.Z.locals || {};
        var yq = n(5737);
        var xq = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        xq.insert = "head";
        xq.singleton = true;
        var Eq = Bc()(yq.Z, xq);
        const Sq = yq.Z.locals || {};
        const Dq = {
            left: CC.alignLeft,
            center: CC.alignCenter,
            right: CC.alignRight,
            justify: CC.alignJustify,
            top: CC.alignTop,
            middle: CC.alignMiddle,
            bottom: CC.alignBottom
        };

        class Tq extends pA {
            constructor(t, e) {
                super(t);
                this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    padding: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    horizontalAlignment: "",
                    verticalAlignment: ""
                });
                this.options = e;
                const {
                    borderStyleDropdown: n,
                    borderWidthInput: i,
                    borderColorInput: o,
                    borderRowLabel: r
                } = this._createBorderFields();
                const {backgroundRowLabel: s, backgroundInput: a} = this._createBackgroundFields();
                const {
                    widthInput: l,
                    operatorLabel: c,
                    heightInput: d,
                    dimensionsLabel: u
                } = this._createDimensionFields();
                const {
                    horizontalAlignmentToolbar: h,
                    verticalAlignmentToolbar: f,
                    alignmentLabel: g
                } = this._createAlignmentFields();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.children = this.createCollection();
                this.borderStyleDropdown = n;
                this.borderWidthInput = i;
                this.borderColorInput = o;
                this.backgroundInput = a;
                this.paddingInput = this._createPaddingField();
                this.widthInput = l;
                this.heightInput = d;
                this.horizontalAlignmentToolbar = h;
                this.verticalAlignmentToolbar = f;
                const {saveButtonView: m, cancelButtonView: p} = this._createActionButtons();
                this.saveButtonView = m;
                this.cancelButtonView = p;
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.children.add(new by(t, {label: this.t("Cell properties")}));
                this.children.add(new mq(t, {
                    labelView: r,
                    children: [r, n, o, i],
                    class: "ck-table-form__border-row"
                }));
                this.children.add(new mq(t, {labelView: s, children: [s, a], class: "ck-table-form__background-row"}));
                this.children.add(new mq(t, {
                    children: [new mq(t, {
                        labelView: u,
                        children: [u, l, c, d],
                        class: "ck-table-form__dimensions-row"
                    }), new mq(t, {children: [this.paddingInput], class: "ck-table-cell-properties-form__padding-row"})]
                }));
                this.children.add(new mq(t, {
                    labelView: g,
                    children: [g, h, f],
                    class: "ck-table-cell-properties-form__alignment-row"
                }));
                this.children.add(new mq(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                }));
                this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"],
                        tabindex: "-1"
                    },
                    children: this.children
                })
            }

            render() {
                super.render();
                xC({view: this});
                [this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createBorderFields() {
                const t = this.options.defaultTableCellProperties;
                const e = {style: t.borderStyle, width: t.borderWidth, color: t.borderColor};
                const n = lq({colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e.color});
                const i = this.locale;
                const o = this.t;
                const r = new cy(i);
                r.text = o("Border");
                const s = XW(o);
                const a = new Py(i, zy);
                a.set({label: o("Style"), class: "ck-table-form__border-style"});
                a.fieldView.buttonView.set({isOn: false, withText: true, tooltip: o("Style")});
                a.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => s[t ? t : "none"]));
                a.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                }));
                a.bind("isEmpty").to(this, "borderStyle", (t => !t));
                $v(a.fieldView, rq(this, e.style));
                const l = new Py(i, Iy);
                l.set({label: o("Width"), class: "ck-table-form__border-width"});
                l.fieldView.bind("value").to(this, "borderWidth");
                l.bind("isEnabled").to(this, "borderStyle", Bq);
                l.fieldView.on("input", (() => {
                    this.borderWidth = l.fieldView.element.value
                }));
                const c = new Py(i, n);
                c.set({label: o("Color"), class: "ck-table-form__border-color"});
                c.fieldView.bind("value").to(this, "borderColor");
                c.bind("isEnabled").to(this, "borderStyle", Bq);
                c.fieldView.on("input", (() => {
                    this.borderColor = c.fieldView.value
                }));
                this.on("change:borderStyle", ((t, n, i, o) => {
                    if (!Bq(i)) {
                        this.borderColor = "";
                        this.borderWidth = ""
                    }
                    if (!Bq(o)) {
                        this.borderColor = e.color;
                        this.borderWidth = e.width
                    }
                }));
                return {borderRowLabel: r, borderStyleDropdown: a, borderColorInput: c, borderWidthInput: l}
            }

            _createBackgroundFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Background");
                const i = lq({
                    colorConfig: this.options.backgroundColors,
                    columns: 5,
                    defaultColorValue: this.options.defaultTableCellProperties.backgroundColor
                });
                const o = new Py(t, i);
                o.set({label: e("Color"), class: "ck-table-cell-properties-form__background"});
                o.fieldView.bind("value").to(this, "backgroundColor");
                o.fieldView.on("input", (() => {
                    this.backgroundColor = o.fieldView.value
                }));
                return {backgroundRowLabel: n, backgroundInput: o}
            }

            _createDimensionFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Dimensions");
                const i = new Py(t, Iy);
                i.set({label: e("Width"), class: "ck-table-form__dimensions-row__width"});
                i.fieldView.bind("value").to(this, "width");
                i.fieldView.on("input", (() => {
                    this.width = i.fieldView.element.value
                }));
                const o = new pA(t);
                o.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck-table-form__dimension-operator"]},
                    children: [{text: "×"}]
                });
                const r = new Py(t, Iy);
                r.set({label: e("Height"), class: "ck-table-form__dimensions-row__height"});
                r.fieldView.bind("value").to(this, "height");
                r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                }));
                return {dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r}
            }

            _createPaddingField() {
                const t = this.locale;
                const e = this.t;
                const n = new Py(t, Iy);
                n.set({label: e("Padding"), class: "ck-table-cell-properties-form__padding"});
                n.fieldView.bind("value").to(this, "padding");
                n.fieldView.on("input", (() => {
                    this.padding = n.fieldView.element.value
                }));
                return n
            }

            _createAlignmentFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Table cell text alignment");
                const i = new yv(t);
                const o = this.locale.contentLanguageDirection === "rtl";
                i.set({isCompact: true, ariaLabel: e("Horizontal text alignment toolbar")});
                sq({
                    view: this,
                    icons: Dq,
                    toolbar: i,
                    labels: this._horizontalAlignmentLabels,
                    propertyName: "horizontalAlignment",
                    nameToValue: t => {
                        if (o) {
                            if (t === "left") {
                                return "right"
                            } else if (t === "right") {
                                return "left"
                            }
                        }
                        return t
                    },
                    defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
                });
                const r = new yv(t);
                r.set({isCompact: true, ariaLabel: e("Vertical text alignment toolbar")});
                sq({
                    view: this,
                    icons: Dq,
                    toolbar: r,
                    labels: this._verticalAlignmentLabels,
                    propertyName: "verticalAlignment",
                    defaultValue: this.options.defaultTableCellProperties.verticalAlignment
                });
                return {horizontalAlignmentToolbar: i, verticalAlignmentToolbar: r, alignmentLabel: n}
            }

            _createActionButtons() {
                const t = this.locale;
                const e = this.t;
                const n = new LC(t);
                const i = new LC(t);
                const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
                n.set({label: e("Save"), icon: CC.check, class: "ck-button-save", type: "submit", withText: true});
                n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t))));
                i.set({label: e("Cancel"), icon: CC.cancel, class: "ck-button-cancel", withText: true});
                i.delegate("execute").to(this, "cancel");
                return {saveButtonView: n, cancelButtonView: i}
            }

            get _horizontalAlignmentLabels() {
                const t = this.locale;
                const e = this.t;
                const n = e("Align cell text to the left");
                const i = e("Align cell text to the center");
                const o = e("Align cell text to the right");
                const r = e("Justify cell text");
                if (t.uiLanguageDirection === "rtl") {
                    return {right: o, center: i, left: n, justify: r}
                } else {
                    return {left: n, center: i, right: o, justify: r}
                }
            }

            get _verticalAlignmentLabels() {
                const t = this.t;
                return {
                    top: t("Align cell text to the top"),
                    middle: t("Align cell text to the middle"),
                    bottom: t("Align cell text to the bottom")
                }
            }
        }

        function Bq(t) {
            return t !== "none"
        }

        function Pq(t) {
            const e = t.getSelectedElement();
            if (e && Rq(e)) {
                return e
            }
            return null
        }

        function Iq(t) {
            const e = t.getFirstPosition();
            if (!e) {
                return null
            }
            let n = e.parent;
            while (n) {
                if (n.is("element") && Rq(n)) {
                    return n
                }
                n = n.parent
            }
            return null
        }

        function Rq(t) {
            return !!t.getCustomProperty("table") && GP(t)
        }

        const zq = vA.defaultPositions;
        const Vq = [zq.northArrowSouth, zq.northArrowSouthWest, zq.northArrowSouthEast, zq.southArrowNorth, zq.southArrowNorthWest, zq.southArrowNorthEast, zq.viewportStickyNorth];

        function Fq(t, e) {
            const n = t.plugins.get("ContextualBalloon");
            if (Iq(t.editing.view.document.selection)) {
                let i;
                if (e === "cell") {
                    i = Oq(t)
                } else {
                    i = Lq(t)
                }
                n.updatePosition(i)
            }
        }

        function Lq(t) {
            const e = t.model.document.selection.getFirstPosition();
            const n = e.findAncestor("table");
            const i = t.editing.mapper.toViewElement(n);
            return {target: t.editing.view.domConverter.mapViewToDom(i), positions: Vq}
        }

        function Oq(t) {
            const e = t.editing.mapper;
            const n = t.editing.view.domConverter;
            const i = t.model.document.selection;
            if (i.rangeCount > 1) {
                return {target: () => Mq(i.getRanges(), t), positions: Vq}
            }
            const o = Nq(i.getFirstPosition());
            const r = e.toViewElement(o);
            return {target: n.mapViewToDom(r), positions: Vq}
        }

        function Nq(t) {
            const e = t.nodeAfter && t.nodeAfter.is("element", "tableCell");
            return e ? t.nodeAfter : t.findAncestor("tableCell")
        }

        function Mq(t, e) {
            const n = e.editing.mapper;
            const i = e.editing.view.domConverter;
            const o = Array.from(t).map((t => {
                const e = Nq(t.start);
                const o = n.toViewElement(e);
                return new sl(i.mapViewToDom(o))
            }));
            return sl.getBoundingRect(o)
        }

        const Hq = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';

        function Wq(t) {
            if (!t || !it(t)) {
                return t
            }
            const {top: e, right: n, bottom: i, left: o} = t;
            if (e == n && n == i && i == o) {
                return e
            }
        }

        function qq(t, e) {
            const n = parseFloat(t);
            if (Number.isNaN(n)) {
                return t
            }
            if (String(n) !== String(t)) {
                return t
            }
            return `${n}${e}`
        }

        function jq(t, e = {}) {
            const n = Object.assign({
                borderStyle: "none",
                borderWidth: "",
                borderColor: "",
                backgroundColor: "",
                width: "",
                height: ""
            }, t);
            if (e.includeAlignmentProperty && !n.alignment) {
                n.alignment = "center"
            }
            if (e.includePaddingProperty && !n.padding) {
                n.padding = ""
            }
            if (e.includeVerticalAlignmentProperty && !n.verticalAlignment) {
                n.verticalAlignment = "middle"
            }
            if (e.includeHorizontalAlignmentProperty && !n.horizontalAlignment) {
                n.horizontalAlignment = e.isRightToLeftContent ? "right" : "left"
            }
            return n
        }

        const $q = 500;
        const Uq = {
            borderStyle: "tableCellBorderStyle",
            borderColor: "tableCellBorderColor",
            borderWidth: "tableCellBorderWidth",
            height: "tableCellHeight",
            width: "tableCellWidth",
            padding: "tableCellPadding",
            backgroundColor: "tableCellBackgroundColor",
            horizontalAlignment: "tableCellHorizontalAlignment",
            verticalAlignment: "tableCellVerticalAlignment"
        };

        class Gq extends Ac {
            static get requires() {
                return [Ky]
            }

            static get pluginName() {
                return "TableCellPropertiesUI"
            }

            constructor(t) {
                super(t);
                t.config.define("table.tableCellProperties", {borderColors: aq, backgroundColors: aq})
            }

            init() {
                const t = this.editor;
                const e = t.t;
                this._defaultTableCellProperties = jq(t.config.get("table.tableCellProperties.defaultProperties"), {
                    includeVerticalAlignmentProperty: true,
                    includeHorizontalAlignmentProperty: true,
                    includePaddingProperty: true,
                    isRightToLeftContent: t.locale.contentLanguageDirection === "rtl"
                });
                this._balloon = t.plugins.get(Ky);
                this.view = this._createPropertiesView();
                this._undoStepBatch = null;
                t.ui.componentFactory.add("tableCellProperties", (n => {
                    const i = new LC(n);
                    i.set({label: e("Cell properties"), icon: Hq, tooltip: true});
                    this.listenTo(i, "execute", (() => this._showView()));
                    const o = Object.values(Uq).map((e => t.commands.get(e)));
                    i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t))));
                    return i
                }))
            }

            destroy() {
                super.destroy();
                this.view.destroy()
            }

            _createPropertiesView() {
                const t = this.editor;
                const e = t.editing.view.document;
                const n = t.config.get("table.tableCellProperties");
                const i = jC(n.borderColors);
                const o = qC(t.locale, i);
                const r = jC(n.backgroundColors);
                const s = qC(t.locale, r);
                const a = new Tq(t.locale, {
                    borderColors: o,
                    backgroundColors: s,
                    defaultTableCellProperties: this._defaultTableCellProperties
                });
                const l = t.t;
                a.render();
                this.listenTo(a, "submit", (() => {
                    this._hideView()
                }));
                this.listenTo(a, "cancel", (() => {
                    if (this._undoStepBatch.operations.length) {
                        t.execute("undo", this._undoStepBatch)
                    }
                    this._hideView()
                }));
                a.keystrokes.set("Esc", ((t, e) => {
                    this._hideView();
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!Iq(e.selection)) {
                        this._hideView()
                    } else if (this._isViewVisible) {
                        Fq(t, "cell")
                    }
                }));
                vC({
                    emitter: a,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const c = tq(l);
                const d = eq(l);
                a.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle", this._defaultTableCellProperties.borderStyle));
                a.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderColorInput,
                    commandName: "tableCellBorderColor",
                    errorText: c,
                    validator: nq,
                    defaultValue: this._defaultTableCellProperties.borderColor
                }));
                a.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderWidthInput,
                    commandName: "tableCellBorderWidth",
                    errorText: d,
                    validator: oq,
                    defaultValue: this._defaultTableCellProperties.borderWidth
                }));
                a.on("change:padding", this._getValidatedPropertyChangeCallback({
                    viewField: a.paddingInput,
                    commandName: "tableCellPadding",
                    errorText: d,
                    validator: iq,
                    defaultValue: this._defaultTableCellProperties.padding
                }));
                a.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: a.widthInput,
                    commandName: "tableCellWidth",
                    errorText: d,
                    validator: iq,
                    defaultValue: this._defaultTableCellProperties.width
                }));
                a.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: a.heightInput,
                    commandName: "tableCellHeight",
                    errorText: d,
                    validator: iq,
                    defaultValue: this._defaultTableCellProperties.height
                }));
                a.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.backgroundInput,
                    commandName: "tableCellBackgroundColor",
                    errorText: c,
                    validator: nq,
                    defaultValue: this._defaultTableCellProperties.backgroundColor
                }));
                a.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment", this._defaultTableCellProperties.horizontalAlignment));
                a.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment", this._defaultTableCellProperties.verticalAlignment));
                return a
            }

            _fillViewFormFromCommandValues() {
                const t = this.editor.commands;
                const e = t.get("tableCellBorderStyle");
                Object.entries(Uq).map((([e, n]) => {
                    const i = this._defaultTableCellProperties[e] || "";
                    return [e, t.get(n).value || i]
                })).forEach((([t, n]) => {
                    if ((t === "borderColor" || t === "borderWidth") && e.value === "none") {
                        return
                    }
                    this.view.set(t, n)
                }))
            }

            _showView() {
                const t = this.editor;
                this._fillViewFormFromCommandValues();
                this._balloon.add({view: this.view, position: Oq(t)});
                this._undoStepBatch = t.model.createBatch();
                this.view.focus()
            }

            _hideView() {
                if (!this._isViewInBalloon) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.view.saveButtonView.focus();
                this._balloon.remove(this.view);
                this.editor.editing.view.focus()
            }

            get _isViewVisible() {
                return this._balloon.visibleView === this.view
            }

            get _isViewInBalloon() {
                return this._balloon.hasView(this.view)
            }

            _getPropertyChangeCallback(t, e) {
                return (n, i, o, r) => {
                    if (!r && e === o) {
                        return
                    }
                    this.editor.execute(t, {value: o, batch: this._undoStepBatch})
                }
            }

            _getValidatedPropertyChangeCallback(t) {
                const {commandName: e, viewField: n, validator: i, errorText: o, defaultValue: r} = t;
                const s = Qf((() => {
                    n.errorText = o
                }), $q);
                return (t, o, a, l) => {
                    s.cancel();
                    if (!l && r === a) {
                        return
                    }
                    if (i(a)) {
                        this.editor.execute(e, {value: a, batch: this._undoStepBatch});
                        n.errorText = null
                    } else {
                        s()
                    }
                }
            }
        }

        class Kq extends vc {
            constructor(t, e, n) {
                super(t);
                this.attributeName = e;
                this._defaultValue = n
            }

            refresh() {
                const t = this.editor;
                const e = this.editor.plugins.get("TableUtils");
                const n = e.getSelectionAffectedTableCells(t.model.document.selection);
                this.isEnabled = !!n.length;
                this.value = this._getSingleValue(n)
            }

            execute(t = {}) {
                const {value: e, batch: n} = t;
                const i = this.editor.model;
                const o = this.editor.plugins.get("TableUtils");
                const r = o.getSelectionAffectedTableCells(i.document.selection);
                const s = this._getValueToSet(e);
                i.enqueueChange(n, (t => {
                    if (s) {
                        r.forEach((e => t.setAttribute(this.attributeName, s, e)))
                    } else {
                        r.forEach((e => t.removeAttribute(this.attributeName, e)))
                    }
                }))
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                const e = t.getAttribute(this.attributeName);
                if (e === this._defaultValue) {
                    return
                }
                return e
            }

            _getValueToSet(t) {
                if (t === this._defaultValue) {
                    return
                }
                return t
            }

            _getSingleValue(t) {
                const e = this._getAttribute(t[0]);
                const n = t.every((t => this._getAttribute(t) === e));
                return n ? e : undefined
            }
        }

        class Zq extends Kq {
            constructor(t, e) {
                super(t, "tableCellWidth", e)
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        class Jq extends Ac {
            static get pluginName() {
                return "TableCellWidthEditing"
            }

            static get requires() {
                return [KH]
            }

            init() {
                const t = this.editor;
                const e = jq(t.config.get("table.tableCellProperties.defaultProperties"));
                wM(t.model.schema, t.conversion, {
                    modelAttribute: "tableCellWidth",
                    styleName: "width",
                    defaultValue: e.width
                });
                t.commands.add("tableCellWidth", new Zq(t, e.width))
            }
        }

        class Yq extends Kq {
            constructor(t, e) {
                super(t, "tableCellPadding", e)
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        class Qq extends Kq {
            constructor(t, e) {
                super(t, "tableCellHeight", e)
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return null
                }
                return t
            }
        }

        class Xq extends Kq {
            constructor(t, e) {
                super(t, "tableCellBackgroundColor", e)
            }
        }

        class tj extends Kq {
            constructor(t, e) {
                super(t, "tableCellVerticalAlignment", e)
            }
        }

        class ej extends Kq {
            constructor(t, e) {
                super(t, "tableCellHorizontalAlignment", e)
            }
        }

        class nj extends Kq {
            constructor(t, e) {
                super(t, "tableCellBorderStyle", e)
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }
        }

        class ij extends Kq {
            constructor(t, e) {
                super(t, "tableCellBorderColor", e)
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }
        }

        class oj extends Kq {
            constructor(t, e) {
                super(t, "tableCellBorderWidth", e)
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        const rj = /^(top|middle|bottom)$/;
        const sj = /^(left|center|right|justify)$/;

        class aj extends Ac {
            static get pluginName() {
                return "TableCellPropertiesEditing"
            }

            static get requires() {
                return [KH, Jq]
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                t.config.define("table.tableCellProperties.defaultProperties", {});
                const i = jq(t.config.get("table.tableCellProperties.defaultProperties"), {
                    includeVerticalAlignmentProperty: true,
                    includeHorizontalAlignmentProperty: true,
                    includePaddingProperty: true,
                    isRightToLeftContent: t.locale.contentLanguageDirection === "rtl"
                });
                t.data.addStyleProcessorRules(b_);
                lj(e, n, {color: i.borderColor, style: i.borderStyle, width: i.borderWidth});
                t.commands.add("tableCellBorderStyle", new nj(t, i.borderStyle));
                t.commands.add("tableCellBorderColor", new ij(t, i.borderColor));
                t.commands.add("tableCellBorderWidth", new oj(t, i.borderWidth));
                wM(e, n, {modelAttribute: "tableCellHeight", styleName: "height", defaultValue: i.height});
                t.commands.add("tableCellHeight", new Qq(t, i.height));
                t.data.addStyleProcessorRules(B_);
                wM(e, n, {
                    modelAttribute: "tableCellPadding",
                    styleName: "padding",
                    reduceBoxSides: true,
                    defaultValue: i.padding
                });
                t.commands.add("tableCellPadding", new Yq(t, i.padding));
                t.data.addStyleProcessorRules(f_);
                wM(e, n, {
                    modelAttribute: "tableCellBackgroundColor",
                    styleName: "background-color",
                    defaultValue: i.backgroundColor
                });
                t.commands.add("tableCellBackgroundColor", new Xq(t, i.backgroundColor));
                cj(e, n, i.horizontalAlignment);
                t.commands.add("tableCellHorizontalAlignment", new ej(t, i.horizontalAlignment));
                dj(e, n, i.verticalAlignment);
                t.commands.add("tableCellVerticalAlignment", new tj(t, i.verticalAlignment))
            }
        }

        function lj(t, e, n) {
            const i = {width: "tableCellBorderWidth", color: "tableCellBorderColor", style: "tableCellBorderStyle"};
            t.extend("tableCell", {allowAttributes: Object.values(i)});
            hM(e, "td", i, n);
            hM(e, "th", i, n);
            fM(e, {modelElement: "tableCell", modelAttribute: i.style, styleName: "border-style"});
            fM(e, {modelElement: "tableCell", modelAttribute: i.color, styleName: "border-color"});
            fM(e, {modelElement: "tableCell", modelAttribute: i.width, styleName: "border-width"})
        }

        function cj(t, e, n) {
            t.extend("tableCell", {allowAttributes: ["tableCellHorizontalAlignment"]});
            e.for("downcast").attributeToAttribute({
                model: {name: "tableCell", key: "tableCellHorizontalAlignment"},
                view: t => ({key: "style", value: {"text-align": t}})
            });
            e.for("upcast").attributeToAttribute({
                view: {name: /^(td|th)$/, styles: {"text-align": sj}},
                model: {
                    key: "tableCellHorizontalAlignment", value: t => {
                        const e = t.getStyle("text-align");
                        return e === n ? null : e
                    }
                }
            }).attributeToAttribute({
                view: {name: /^(td|th)$/, attributes: {align: sj}},
                model: {
                    key: "tableCellHorizontalAlignment", value: t => {
                        const e = t.getAttribute("align");
                        return e === n ? null : e
                    }
                }
            })
        }

        function dj(t, e, n) {
            t.extend("tableCell", {allowAttributes: ["tableCellVerticalAlignment"]});
            e.for("downcast").attributeToAttribute({
                model: {name: "tableCell", key: "tableCellVerticalAlignment"},
                view: t => ({key: "style", value: {"vertical-align": t}})
            });
            e.for("upcast").attributeToAttribute({
                view: {name: /^(td|th)$/, styles: {"vertical-align": rj}},
                model: {
                    key: "tableCellVerticalAlignment", value: t => {
                        const e = t.getStyle("vertical-align");
                        return e === n ? null : e
                    }
                }
            }).attributeToAttribute({
                view: {name: /^(td|th)$/, attributes: {valign: rj}},
                model: {
                    key: "tableCellVerticalAlignment", value: t => {
                        const e = t.getAttribute("valign");
                        return e === n ? null : e
                    }
                }
            })
        }

        class uj extends Ac {
            static get pluginName() {
                return "TableCellProperties"
            }

            static get requires() {
                return [aj, Gq]
            }
        }

        class hj extends vc {
            constructor(t, e, n) {
                super(t);
                this.attributeName = e;
                this._defaultValue = n
            }

            refresh() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = e.getFirstPosition().findAncestor("table");
                this.isEnabled = !!n;
                this.value = this._getValue(n)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document.selection;
                const {value: i, batch: o} = t;
                const r = n.getFirstPosition().findAncestor("table");
                const s = this._getValueToSet(i);
                e.enqueueChange(o, (t => {
                    if (s) {
                        t.setAttribute(this.attributeName, s, r)
                    } else {
                        t.removeAttribute(this.attributeName, r)
                    }
                }))
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                const e = t.getAttribute(this.attributeName);
                if (e === this._defaultValue) {
                    return
                }
                return e
            }

            _getValueToSet(t) {
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        class fj extends hj {
            constructor(t, e) {
                super(t, "tableWidth", e)
            }

            refresh() {
                this.isEnabled = true
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = t.table || e.document.selection.getSelectedElement();
                const {tableWidth: i, columnWidths: o} = t;
                e.change((t => {
                    if (i) {
                        t.setAttribute(this.attributeName, i, n)
                    } else {
                        t.removeAttribute(this.attributeName, n)
                    }
                    if (o) {
                        t.setAttribute("columnWidths", o, n)
                    } else {
                        t.removeAttribute("columnWidths", n)
                    }
                }))
            }
        }

        class gj extends hj {
            constructor(t, e) {
                super(t, "columnWidths", e)
            }

            refresh() {
                this.isEnabled = true
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = t.table || e.document.selection.getSelectedElement();
                const {columnWidths: i} = t;
                e.change((t => {
                    if (i) {
                        t.setAttribute(this.attributeName, i, n)
                    } else {
                        t.removeAttribute(this.attributeName, n)
                    }
                }))
            }
        }

        const mj = 5;
        const pj = 40;
        const bj = 2;

        function kj(t) {
            const e = new Set;
            for (const n of t.document.differ.getChanges()) {
                let i = null;
                switch (n.type) {
                    case"insert":
                        i = ["table", "tableRow", "tableCell"].includes(n.name) ? n.position : null;
                        break;
                    case"remove":
                        i = ["tableRow", "tableCell"].includes(n.name) ? n.position : null;
                        break;
                    case"attribute":
                        if (n.range.start.nodeAfter) {
                            i = ["table", "tableRow", "tableCell"].includes(n.range.start.nodeAfter.name) ? n.range.start : null
                        }
                        break
                }
                if (!i) {
                    continue
                }
                const o = i.nodeAfter && i.nodeAfter.name === "table" ? i.nodeAfter : i.findAncestor("table");
                for (const n of t.createRangeOn(o).getItems()) {
                    if (n.is("element") && n.name === "table" && n.hasAttribute("columnWidths")) {
                        e.add(n)
                    }
                }
            }
            return e
        }

        function wj(t, e) {
            return pj * 100 / _j(t, e)
        }

        function _j(t, e) {
            const n = Aj(t, "tbody", e) || Aj(t, "thead", e);
            const i = e.editing.view.domConverter.mapViewToDom(n);
            return Cj(i)
        }

        function Aj(t, e, n) {
            const i = n.editing.mapper.toViewElement(t);
            const o = [...i.getChildren()].find((t => t.is("element", "table")));
            return [...o.getChildren()].find((t => t.is("element", e)))
        }

        function Cj(t) {
            const e = Xa.window.getComputedStyle(t);
            if (e.boxSizing === "border-box") {
                return parseFloat(e.width) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderLeftWidth) - parseFloat(e.borderRightWidth)
            } else {
                return parseFloat(e.width)
            }
        }

        function vj(t, e) {
            const n = e.getCellLocation(t).column;
            const i = t.getAttribute("colspan") || 1;
            return {leftEdge: n, rightEdge: n + i - 1}
        }

        function yj(t) {
            const e = Math.pow(10, bj);
            const n = parseFloat(t);
            return Math.round(n * e) / e
        }

        function xj(t, e, n) {
            if (t <= e) {
                return yj(e)
            }
            if (t >= n) {
                return yj(n)
            }
            return yj(t)
        }

        function Ej(t, e) {
            return Array(t).fill(e)
        }

        function Sj(t) {
            return t.map((t => parseFloat(t))).filter((t => !Number.isNaN(t))).reduce(((t, e) => t + e), 0)
        }

        function Dj(t) {
            t = Tj(t);
            const e = Sj(t);
            if (e === 100) {
                return t
            }
            return t.map((t => yj(t * 100 / e))).map(((t, e, n) => {
                const i = e === n.length - 1;
                if (!i) {
                    return t
                }
                const o = Sj(n);
                return yj(t + 100 - o)
            }))
        }

        function Tj(t) {
            const e = t.filter((t => t === "auto")).length;
            if (e === 0) {
                return t.map((t => yj(t)))
            }
            const n = Sj(t);
            const i = Math.max((100 - n) / e, mj);
            return t.map((t => t === "auto" ? i : t)).map((t => yj(t)))
        }

        function Bj(t, e) {
            let n = [...e.getChildren()].find((t => t.hasClass("ck-table-column-resizer")));
            if (n) {
                return
            }
            n = t.createUIElement("div", {class: "ck-table-column-resizer"});
            t.insert(t.createPositionAt(e, "end"), n)
        }

        function Pj(t) {
            const e = Xa.window.getComputedStyle(t);
            if (e.boxSizing === "border-box") {
                return parseInt(e.width)
            } else {
                return parseFloat(e.width) + parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) + parseFloat(e.borderWidth)
            }
        }

        function Ij(t) {
            return e => e.on("element:colgroup", ((e, n, i) => {
                const o = n.viewItem;
                if (!i.consumable.test(o, {name: true})) {
                    return
                }
                i.consumable.consume(o, {name: true});
                const r = n.modelCursor.findAncestor("table");
                const s = t.getColumns(r);
                let a = [...Array(s).keys()].map((t => {
                    const e = o.getChild(t);
                    if (!e || !e.is("element", "col")) {
                        return "auto"
                    }
                    const n = e.getStyle("width");
                    if (!n || !n.endsWith("%")) {
                        return "auto"
                    }
                    return n
                }));
                if (a.includes("auto")) {
                    a = Dj(a).map((t => t + "%"))
                }
                i.writer.setAttribute("columnWidths", a.join(","), r)
            }))
        }

        function Rj() {
            return t => t.on("attribute:columnWidths:table", ((t, e, n) => {
                const i = n.writer;
                const o = e.item;
                const r = [...n.mapper.toViewElement(o).getChildren()].find((t => t.is("element", "table")));
                if (e.attributeNewValue) {
                    zj(i, r, e.attributeNewValue);
                    i.addClass("ck-table-resized", r)
                } else {
                    Vj(i, r);
                    i.removeClass("ck-table-resized", r)
                }
            }))
        }

        function zj(t, e, n) {
            const i = n.split(",");
            let o = [...e.getChildren()].find((t => t.is("element", "colgroup")));
            if (!o) {
                o = t.createContainerElement("colgroup")
            } else {
                for (const e of [...o.getChildren()]) {
                    t.remove(e)
                }
            }
            for (const e of Array(i.length).keys()) {
                const n = t.createEmptyElement("col");
                t.setStyle("width", i[e], n);
                t.insert(t.createPositionAt(o, "end"), n)
            }
            t.insert(t.createPositionAt(e, "start"), o)
        }

        function Vj(t, e) {
            const n = [...e.getChildren()].find((t => t.is("element", "colgroup")));
            t.remove(n)
        }

        class Fj extends Ac {
            static get requires() {
                return [KH, uH]
            }

            static get pluginName() {
                return "TableColumnResizeEditing"
            }

            constructor(t) {
                super(t);
                this._isResizingActive = false;
                this.set("_isResizingAllowed", true);
                this._resizingData = null;
                this._domEmitter = Object.create(Ka);
                this._tableUtilsPlugin = t.plugins.get("TableUtils");
                this.on("change:_isResizingAllowed", ((e, n, i) => {
                    t.editing.view.change((e => {
                        e[i ? "removeClass" : "addClass"]("ck-column-resize_disabled", t.editing.view.document.getRoot())
                    }))
                }))
            }

            init() {
                this._extendSchema();
                this._registerPostFixer();
                this._registerConverters();
                this._registerResizingListeners();
                this._registerColgroupFixer();
                this._registerResizerInserter();
                const t = this.editor;
                const e = t.plugins.get("TableColumnResize");
                t.commands.add("resizeTableWidth", new fj(t));
                t.commands.add("resizeColumnWidths", new gj(t));
                const n = t.commands.get("resizeTableWidth");
                const i = t.commands.get("resizeColumnWidths");
                this.bind("_isResizingAllowed").to(t, "isReadOnly", e, "isEnabled", n, "isEnabled", i, "isEnabled", ((t, e, n, i) => !t && e && n && i))
            }

            destroy() {
                this._domEmitter.stopListening();
                super.destroy()
            }

            _extendSchema() {
                this.editor.model.schema.extend("table", {allowAttributes: ["tableWidth", "columnWidths"]})
            }

            _registerPostFixer() {
                const t = this.editor;
                const e = t.model;
                e.document.registerPostFixer((t => {
                    let i = false;
                    for (const o of kj(e)) {
                        const e = Dj(o.getAttribute("columnWidths").split(","));
                        n(e, o, this);
                        const r = e.map((t => `${t}%`)).join(",");
                        if (o.getAttribute("columnWidths") === r) {
                            continue
                        }
                        t.setAttribute("columnWidths", r, o);
                        i = true
                    }
                    return i
                }));

                function n(t, e, n) {
                    const o = n._tableUtilsPlugin.getColumns(e);
                    const r = o - t.length;
                    if (r === 0) {
                        return
                    }
                    const s = i(n.editor.model.document.differ, e);
                    for (const i of s) {
                        const r = o - t.length;
                        if (r === 0) {
                            continue
                        }
                        const s = r > 0;
                        const a = n._tableUtilsPlugin.getCellLocation(i).column;
                        if (s) {
                            const i = wj(e, n.editor);
                            const o = Ej(r, i);
                            t.splice(a, 0, ...o)
                        } else {
                            const e = t.splice(a, Math.abs(r));
                            t[a] += Sj(e)
                        }
                    }
                }

                function i(t, e) {
                    const n = new Set;
                    for (const i of t.getChanges()) {
                        if (i.type == "insert" && i.position.nodeAfter && i.position.nodeAfter.name == "tableCell" && i.position.nodeAfter.getAncestors().includes(e)) {
                            n.add(i.position.nodeAfter)
                        } else if (i.type == "remove") {
                            const t = i.position.nodeBefore || i.position.nodeAfter;
                            if (t.name == "tableCell" && t.getAncestors().includes(e)) {
                                n.add(t)
                            }
                        }
                    }
                    return n
                }
            }

            _registerConverters() {
                const t = this.editor;
                const e = t.conversion;
                const n = {
                    view: {name: "figure", key: "style", value: {width: /[\s\S]+/}},
                    model: {name: "table", key: "tableWidth", value: t => t.getStyle("width")}
                };
                const i = {
                    model: {name: "table", key: "tableWidth"},
                    view: t => ({name: "figure", key: "style", value: {width: t}})
                };
                e.for("upcast").attributeToAttribute(n);
                e.for("upcast").add(Ij(this._tableUtilsPlugin));
                e.for("downcast").attributeToAttribute(i);
                e.for("downcast").add(Rj())
            }

            _registerResizingListeners() {
                const t = this.editor.editing.view;
                t.addObserver(vW);
                t.document.on("mousedown", this._onMouseDownHandler.bind(this), {priority: "high"});
                this._domEmitter.listenTo(Xa.window.document, "mousemove", tR(this._onMouseMoveHandler.bind(this), 50));
                this._domEmitter.listenTo(Xa.window.document, "mouseup", this._onMouseUpHandler.bind(this))
            }

            _onMouseDownHandler(t, e) {
                const n = e.target;
                if (!n.hasClass("ck-table-column-resizer")) {
                    return
                }
                if (!this._isResizingAllowed) {
                    return
                }
                e.preventDefault();
                t.stop();
                const i = this.editor;
                const o = i.editing.mapper.toModelElement(n.findAncestor("figure"));
                const r = l(o, this._tableUtilsPlugin, i);
                const s = n.findAncestor("table");
                const a = i.editing.view;
                if (![...s.getChildren()].find((t => t.is("element", "colgroup")))) {
                    a.change((t => {
                        c(t, r, s)
                    }))
                }
                this._isResizingActive = true;
                this._resizingData = this._getResizingData(e, r);
                a.change((t => d(t, s, this._resizingData)));

                function l(t, e, n) {
                    const i = Array(e.getColumns(t));
                    const o = new SM(t);
                    for (const t of o) {
                        const e = n.editing.mapper.toViewElement(t.cell);
                        const o = n.editing.view.domConverter.mapViewToDom(e);
                        const r = Pj(o);
                        if (!i[t.column] || r < i[t.column]) {
                            i[t.column] = yj(r)
                        }
                    }
                    return i
                }

                function c(t, e, n) {
                    const i = t.createContainerElement("colgroup");
                    for (let n = 0; n < e.length; n++) {
                        const o = t.createEmptyElement("col");
                        const r = `${yj(e[n] / Sj(e) * 100)}%`;
                        t.setStyle("width", r, o);
                        t.insert(t.createPositionAt(i, "end"), o)
                    }
                    t.insert(t.createPositionAt(n, "start"), i)
                }

                function d(t, e, n) {
                    const i = n.widths.viewFigureWidth / n.widths.viewFigureParentWidth;
                    t.addClass("ck-table-resized", e);
                    t.addClass("ck-table-column-resizer__active", n.elements.viewResizer);
                    t.setStyle("width", `${yj(i * 100)}%`, e.findAncestor("figure"))
                }
            }

            _onMouseMoveHandler(t, e) {
                if (!this._isResizingActive) {
                    return
                }
                if (!this._isResizingAllowed) {
                    this._onMouseUpHandler();
                    return
                }
                const {
                    columnPosition: n,
                    flags: {isRightEdge: i, isTableCentered: o, isLtrContent: r},
                    elements: {viewFigure: s, viewLeftColumn: a, viewRightColumn: l},
                    widths: {viewFigureParentWidth: c, tableWidth: d, leftColumnWidth: u, rightColumnWidth: h}
                } = this._resizingData;
                const f = -u + pj;
                const g = i ? c - d : h - pj;
                const m = (r ? 1 : -1) * (i && o ? 2 : 1);
                const p = xj((e.clientX - n) * m, Math.min(f, 0), Math.max(g, 0));
                if (p === 0) {
                    return
                }
                this.editor.editing.view.change((t => {
                    const e = yj((u + p) * 100 / d);
                    t.setStyle("width", `${e}%`, a);
                    if (i) {
                        const e = yj((d + p) * 100 / c);
                        t.setStyle("width", `${e}%`, s)
                    } else {
                        const e = yj((h - p) * 100 / d);
                        t.setStyle("width", `${e}%`, l)
                    }
                }))
            }

            _onMouseUpHandler() {
                if (!this._isResizingActive) {
                    return
                }
                const {viewResizer: t, modelTable: e, viewFigure: n, viewColgroup: i} = this._resizingData.elements;
                const o = this.editor;
                const r = o.editing.view;
                const s = e.getAttribute("columnWidths");
                const a = [...i.getChildren()].map((t => t.getStyle("width"))).join(",");
                const l = s !== a;
                const c = e.getAttribute("tableWidth");
                const d = n.getStyle("width");
                const u = c !== d;
                if (l || u) {
                    if (this._isResizingAllowed) {
                        if (u) {
                            o.execute("resizeTableWidth", {table: e, tableWidth: `${yj(d)}%`, columnWidths: a})
                        } else {
                            o.execute("resizeColumnWidths", {columnWidths: a, table: e})
                        }
                    } else {
                        r.change((t => {
                            if (s) {
                                const e = s.split(",");
                                for (const n of i.getChildren()) {
                                    t.setStyle("width", e.shift(), n)
                                }
                            } else {
                                t.remove(i)
                            }
                            if (u) {
                                if (c) {
                                    t.setStyle("width", c, n)
                                } else {
                                    t.removeStyle("width", n)
                                }
                            }
                            if (!s && !c) {
                                t.removeClass("ck-table-resized", [...n.getChildren()].find((t => t.name === "table")))
                            }
                        }))
                    }
                }
                r.change((e => {
                    e.removeClass("ck-table-column-resizer__active", t)
                }));
                this._isResizingActive = false;
                this._resizingData = null
            }

            _getResizingData(t, e) {
                const n = this.editor;
                const i = t.domEvent.clientX;
                const o = t.target;
                const r = o.findAncestor("td") || o.findAncestor("th");
                const s = n.editing.mapper.toModelElement(r);
                const a = s.findAncestor("table");
                const l = vj(s, this._tableUtilsPlugin).rightEdge;
                const c = this._tableUtilsPlugin.getColumns(a) - 1;
                const d = l === c;
                const u = !a.hasAttribute("tableAlignment");
                const h = n.locale.contentLanguageDirection !== "rtl";
                const f = r.findAncestor("table");
                const g = f.findAncestor("figure");
                const m = [...f.getChildren()].find((t => t.is("element", "colgroup")));
                const p = m.getChild(l);
                const b = d ? undefined : m.getChild(l + 1);
                const k = Cj(n.editing.view.domConverter.mapViewToDom(g.parent));
                const w = Cj(n.editing.view.domConverter.mapViewToDom(g));
                const _ = _j(a, n);
                const A = e[l];
                const C = d ? undefined : e[l + 1];
                return {
                    columnPosition: i,
                    flags: {isRightEdge: d, isTableCentered: u, isLtrContent: h},
                    elements: {
                        viewResizer: o,
                        modelTable: a,
                        viewFigure: g,
                        viewColgroup: m,
                        viewLeftColumn: p,
                        viewRightColumn: b
                    },
                    widths: {
                        viewFigureParentWidth: k,
                        viewFigureWidth: w,
                        tableWidth: _,
                        leftColumnWidth: A,
                        rightColumnWidth: C
                    }
                }
            }

            _registerColgroupFixer() {
                const t = this.editor;
                this.listenTo(t.editing.view.document, "layoutChanged", (() => {
                    const e = t.editing.view.document.selection.getFirstPosition().getAncestors().reverse().find((t => t.name === "table"));
                    const n = e && [...e.getChildren()].find((t => t.is("element", "colgroup")));
                    const i = t.model.document.selection.getFirstPosition().findAncestor("table");
                    if (i && i.hasAttribute("columnWidths") && e && !n) {
                        t.editing.reconvertItem(i)
                    }
                }), {priority: "low"})
            }

            _registerResizerInserter() {
                const t = this.editor.editing.view;
                t.on("render", (() => {
                    for (const e of t.createRangeIn(t.document.getRoot())) {
                        if (!["td", "th"].includes(e.item.name)) {
                            continue
                        }
                        t.change((t => {
                            Bj(t, e.item)
                        }))
                    }
                }), {priority: "lowest"})
            }
        }

        var Lj = n(728);
        var Oj = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Oj.insert = "head";
        Oj.singleton = true;
        var Nj = Bc()(Lj.Z, Oj);
        const Mj = Lj.Z.locals || {};

        class Hj extends Ac {
            static get requires() {
                return [Fj, Jq]
            }

            static get pluginName() {
                return "TableColumnResize"
            }
        }

        class Wj extends hj {
            constructor(t, e) {
                super(t, "tableBackgroundColor", e)
            }
        }

        class qj extends hj {
            constructor(t, e) {
                super(t, "tableBorderColor", e)
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }
        }

        class jj extends hj {
            constructor(t, e) {
                super(t, "tableBorderStyle", e)
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }
        }

        class $j extends hj {
            constructor(t, e) {
                super(t, "tableBorderWidth", e)
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                const e = Wq(t.getAttribute(this.attributeName));
                if (e === this._defaultValue) {
                    return
                }
                return e
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        class Uj extends hj {
            constructor(t, e) {
                super(t, "tableWidth", e)
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return
                }
                return t
            }
        }

        class Gj extends hj {
            constructor(t, e) {
                super(t, "tableHeight", e)
            }

            _getValueToSet(t) {
                t = qq(t, "px");
                if (t === this._defaultValue) {
                    return null
                }
                return t
            }
        }

        class Kj extends hj {
            constructor(t, e) {
                super(t, "tableAlignment", e)
            }
        }

        const Zj = /^(left|center|right)$/;
        const Jj = /^(left|none|right)$/;

        class Yj extends Ac {
            static get pluginName() {
                return "TablePropertiesEditing"
            }

            static get requires() {
                return [KH]
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                t.config.define("table.tableProperties.defaultProperties", {});
                const i = jq(t.config.get("table.tableProperties.defaultProperties"), {includeAlignmentProperty: true});
                t.data.addStyleProcessorRules(b_);
                Qj(e, n, {color: i.borderColor, style: i.borderStyle, width: i.borderWidth});
                t.commands.add("tableBorderColor", new qj(t, i.borderColor));
                t.commands.add("tableBorderStyle", new jj(t, i.borderStyle));
                t.commands.add("tableBorderWidth", new $j(t, i.borderWidth));
                Xj(e, n, i.alignment);
                t.commands.add("tableAlignment", new Kj(t, i.alignment));
                e$(e, n, {modelAttribute: "tableWidth", styleName: "width", defaultValue: i.width});
                t.commands.add("tableWidth", new Uj(t, i.width));
                e$(e, n, {modelAttribute: "tableHeight", styleName: "height", defaultValue: i.height});
                t.commands.add("tableHeight", new Gj(t, i.height));
                t.data.addStyleProcessorRules(f_);
                t$(e, n, {
                    modelAttribute: "tableBackgroundColor",
                    styleName: "background-color",
                    defaultValue: i.backgroundColor
                });
                t.commands.add("tableBackgroundColor", new Wj(t, i.backgroundColor))
            }
        }

        function Qj(t, e, n) {
            const i = {width: "tableBorderWidth", color: "tableBorderColor", style: "tableBorderStyle"};
            t.extend("table", {allowAttributes: Object.values(i)});
            hM(e, "table", i, n);
            gM(e, {modelAttribute: i.color, styleName: "border-color"});
            gM(e, {modelAttribute: i.style, styleName: "border-style"});
            gM(e, {modelAttribute: i.width, styleName: "border-width"})
        }

        function Xj(t, e, n) {
            t.extend("table", {allowAttributes: ["tableAlignment"]});
            e.for("downcast").attributeToAttribute({
                model: {name: "table", key: "tableAlignment"},
                view: t => ({key: "style", value: {float: t === "center" ? "none" : t}}),
                converterPriority: "high"
            });
            e.for("upcast").attributeToAttribute({
                view: {name: /^(table|figure)$/, styles: {float: Jj}},
                model: {
                    key: "tableAlignment", value: t => {
                        let e = t.getStyle("float");
                        if (e === "none") {
                            e = "center"
                        }
                        return e === n ? null : e
                    }
                }
            }).attributeToAttribute({
                view: {attributes: {align: Zj}},
                model: {
                    name: "table", key: "tableAlignment", value: t => {
                        const e = t.getAttribute("align");
                        return e === n ? null : e
                    }
                }
            })
        }

        function t$(t, e, n) {
            const {modelAttribute: i} = n;
            t.extend("table", {allowAttributes: [i]});
            uM(e, {viewElement: "table", ...n});
            gM(e, n)
        }

        function e$(t, e, n) {
            const {modelAttribute: i} = n;
            t.extend("table", {allowAttributes: [i]});
            uM(e, {
                viewElement: /^(table|figure)$/,
                shouldUpcast: t => !(t.name == "table" && t.parent.name == "figure"), ...n
            });
            fM(e, {modelElement: "table", ...n})
        }

        var n$ = n(9221);
        var i$ = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        i$.insert = "head";
        i$.singleton = true;
        var o$ = Bc()(n$.Z, i$);
        const r$ = n$.Z.locals || {};
        const s$ = {left: CC.objectLeft, center: CC.objectCenter, right: CC.objectRight};

        class a$ extends pA {
            constructor(t, e) {
                super(t);
                this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    alignment: ""
                });
                this.options = e;
                const {
                    borderStyleDropdown: n,
                    borderWidthInput: i,
                    borderColorInput: o,
                    borderRowLabel: r
                } = this._createBorderFields();
                const {backgroundRowLabel: s, backgroundInput: a} = this._createBackgroundFields();
                const {
                    widthInput: l,
                    operatorLabel: c,
                    heightInput: d,
                    dimensionsLabel: u
                } = this._createDimensionFields();
                const {alignmentToolbar: h, alignmentLabel: f} = this._createAlignmentFields();
                this.focusTracker = new ac;
                this.keystrokes = new lc;
                this.children = this.createCollection();
                this.borderStyleDropdown = n;
                this.borderWidthInput = i;
                this.borderColorInput = o;
                this.backgroundInput = a;
                this.widthInput = l;
                this.heightInput = d;
                this.alignmentToolbar = h;
                const {saveButtonView: g, cancelButtonView: m} = this._createActionButtons();
                this.saveButtonView = g;
                this.cancelButtonView = m;
                this._focusables = new F_;
                this._focusCycler = new hv({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.children.add(new by(t, {label: this.t("Table properties")}));
                this.children.add(new mq(t, {
                    labelView: r,
                    children: [r, n, o, i],
                    class: "ck-table-form__border-row"
                }));
                this.children.add(new mq(t, {labelView: s, children: [s, a], class: "ck-table-form__background-row"}));
                this.children.add(new mq(t, {
                    children: [new mq(t, {
                        labelView: u,
                        children: [u, l, c, d],
                        class: "ck-table-form__dimensions-row"
                    }), new mq(t, {labelView: f, children: [f, h], class: "ck-table-properties-form__alignment-row"})]
                }));
                this.children.add(new mq(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                }));
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"], tabindex: "-1"},
                    children: this.children
                })
            }

            render() {
                super.render();
                xC({view: this});
                [this.borderStyleDropdown, this.borderColorInput, this.borderColorInput.fieldView.dropdownView.buttonView, this.borderWidthInput, this.backgroundInput, this.backgroundInput.fieldView.dropdownView.buttonView, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            destroy() {
                super.destroy();
                this.focusTracker.destroy();
                this.keystrokes.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createBorderFields() {
                const t = this.options.defaultTableProperties;
                const e = {style: t.borderStyle, width: t.borderWidth, color: t.borderColor};
                const n = lq({colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e.color});
                const i = this.locale;
                const o = this.t;
                const r = new cy(i);
                r.text = o("Border");
                const s = XW(this.t);
                const a = new Py(i, zy);
                a.set({label: o("Style"), class: "ck-table-form__border-style"});
                a.fieldView.buttonView.set({isOn: false, withText: true, tooltip: o("Style")});
                a.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => s[t ? t : "none"]));
                a.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                }));
                a.bind("isEmpty").to(this, "borderStyle", (t => !t));
                $v(a.fieldView, rq(this, e.style));
                const l = new Py(i, Iy);
                l.set({label: o("Width"), class: "ck-table-form__border-width"});
                l.fieldView.bind("value").to(this, "borderWidth");
                l.bind("isEnabled").to(this, "borderStyle", l$);
                l.fieldView.on("input", (() => {
                    this.borderWidth = l.fieldView.element.value
                }));
                const c = new Py(i, n);
                c.set({label: o("Color"), class: "ck-table-form__border-color"});
                c.fieldView.bind("value").to(this, "borderColor");
                c.bind("isEnabled").to(this, "borderStyle", l$);
                c.fieldView.on("input", (() => {
                    this.borderColor = c.fieldView.value
                }));
                this.on("change:borderStyle", ((t, n, i, o) => {
                    if (!l$(i)) {
                        this.borderColor = "";
                        this.borderWidth = ""
                    }
                    if (!l$(o)) {
                        this.borderColor = e.color;
                        this.borderWidth = e.width
                    }
                }));
                return {borderRowLabel: r, borderStyleDropdown: a, borderColorInput: c, borderWidthInput: l}
            }

            _createBackgroundFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Background");
                const i = lq({
                    colorConfig: this.options.backgroundColors,
                    columns: 5,
                    defaultColorValue: this.options.defaultTableProperties.backgroundColor
                });
                const o = new Py(t, i);
                o.set({label: e("Color"), class: "ck-table-properties-form__background"});
                o.fieldView.bind("value").to(this, "backgroundColor");
                o.fieldView.on("input", (() => {
                    this.backgroundColor = o.fieldView.value
                }));
                return {backgroundRowLabel: n, backgroundInput: o}
            }

            _createDimensionFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Dimensions");
                const i = new Py(t, Iy);
                i.set({label: e("Width"), class: "ck-table-form__dimensions-row__width"});
                i.fieldView.bind("value").to(this, "width");
                i.fieldView.on("input", (() => {
                    this.width = i.fieldView.element.value
                }));
                const o = new pA(t);
                o.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck-table-form__dimension-operator"]},
                    children: [{text: "×"}]
                });
                const r = new Py(t, Iy);
                r.set({label: e("Height"), class: "ck-table-form__dimensions-row__height"});
                r.fieldView.bind("value").to(this, "height");
                r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                }));
                return {dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r}
            }

            _createAlignmentFields() {
                const t = this.locale;
                const e = this.t;
                const n = new cy(t);
                n.text = e("Alignment");
                const i = new yv(t);
                i.set({isCompact: true, ariaLabel: e("Table alignment toolbar")});
                sq({
                    view: this,
                    icons: s$,
                    toolbar: i,
                    labels: this._alignmentLabels,
                    propertyName: "alignment",
                    defaultValue: this.options.defaultTableProperties.alignment
                });
                return {alignmentLabel: n, alignmentToolbar: i}
            }

            _createActionButtons() {
                const t = this.locale;
                const e = this.t;
                const n = new LC(t);
                const i = new LC(t);
                const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput];
                n.set({label: e("Save"), icon: CC.check, class: "ck-button-save", type: "submit", withText: true});
                n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t))));
                i.set({label: e("Cancel"), icon: CC.cancel, class: "ck-button-cancel", withText: true});
                i.delegate("execute").to(this, "cancel");
                return {saveButtonView: n, cancelButtonView: i}
            }

            get _alignmentLabels() {
                const t = this.locale;
                const e = this.t;
                const n = e("Align table to the left");
                const i = e("Center table");
                const o = e("Align table to the right");
                if (t.uiLanguageDirection === "rtl") {
                    return {right: o, center: i, left: n}
                } else {
                    return {left: n, center: i, right: o}
                }
            }
        }

        function l$(t) {
            return t !== "none"
        }

        const c$ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
        const d$ = 500;
        const u$ = {
            borderStyle: "tableBorderStyle",
            borderColor: "tableBorderColor",
            borderWidth: "tableBorderWidth",
            backgroundColor: "tableBackgroundColor",
            width: "tableWidth",
            height: "tableHeight",
            alignment: "tableAlignment"
        };

        class h$ extends Ac {
            static get requires() {
                return [Ky]
            }

            static get pluginName() {
                return "TablePropertiesUI"
            }

            constructor(t) {
                super(t);
                t.config.define("table.tableProperties", {borderColors: aq, backgroundColors: aq})
            }

            init() {
                const t = this.editor;
                const e = t.t;
                this._defaultTableProperties = jq(t.config.get("table.tableProperties.defaultProperties"), {includeAlignmentProperty: true});
                this._balloon = t.plugins.get(Ky);
                this.view = this._createPropertiesView();
                this._undoStepBatch = null;
                t.ui.componentFactory.add("tableProperties", (n => {
                    const i = new LC(n);
                    i.set({label: e("Table properties"), icon: c$, tooltip: true});
                    this.listenTo(i, "execute", (() => this._showView()));
                    const o = Object.values(u$).map((e => t.commands.get(e)));
                    i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t))));
                    return i
                }))
            }

            destroy() {
                super.destroy();
                this.view.destroy()
            }

            _createPropertiesView() {
                const t = this.editor;
                const e = t.config.get("table.tableProperties");
                const n = jC(e.borderColors);
                const i = qC(t.locale, n);
                const o = jC(e.backgroundColors);
                const r = qC(t.locale, o);
                const s = new a$(t.locale, {
                    borderColors: i,
                    backgroundColors: r,
                    defaultTableProperties: this._defaultTableProperties
                });
                const a = t.t;
                s.render();
                this.listenTo(s, "submit", (() => {
                    this._hideView()
                }));
                this.listenTo(s, "cancel", (() => {
                    if (this._undoStepBatch.operations.length) {
                        t.execute("undo", this._undoStepBatch)
                    }
                    this._hideView()
                }));
                s.keystrokes.set("Esc", ((t, e) => {
                    this._hideView();
                    e()
                }));
                vC({
                    emitter: s,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const l = tq(a);
                const c = eq(a);
                s.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle", this._defaultTableProperties.borderStyle));
                s.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderColorInput,
                    commandName: "tableBorderColor",
                    errorText: l,
                    validator: nq,
                    defaultValue: this._defaultTableProperties.borderColor
                }));
                s.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: s.borderWidthInput,
                    commandName: "tableBorderWidth",
                    errorText: c,
                    validator: oq,
                    defaultValue: this._defaultTableProperties.borderWidth
                }));
                s.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: s.backgroundInput,
                    commandName: "tableBackgroundColor",
                    errorText: l,
                    validator: nq,
                    defaultValue: this._defaultTableProperties.backgroundColor
                }));
                s.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: s.widthInput,
                    commandName: "tableWidth",
                    errorText: c,
                    validator: iq,
                    defaultValue: this._defaultTableProperties.width
                }));
                s.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: s.heightInput,
                    commandName: "tableHeight",
                    errorText: c,
                    validator: iq,
                    defaultValue: this._defaultTableProperties.height
                }));
                s.on("change:alignment", this._getPropertyChangeCallback("tableAlignment", this._defaultTableProperties.alignment));
                return s
            }

            _fillViewFormFromCommandValues() {
                const t = this.editor.commands;
                const e = t.get("tableBorderStyle");
                Object.entries(u$).map((([e, n]) => {
                    const i = this._defaultTableProperties[e] || "";
                    return [e, t.get(n).value || i]
                })).forEach((([t, n]) => {
                    if ((t === "borderColor" || t === "borderWidth") && e.value === "none") {
                        return
                    }
                    this.view.set(t, n)
                }))
            }

            _showView() {
                const t = this.editor;
                this.listenTo(t.ui, "update", (() => {
                    this._updateView()
                }));
                this._fillViewFormFromCommandValues();
                this._balloon.add({view: this.view, position: Lq(t)});
                this._undoStepBatch = t.model.createBatch();
                this.view.focus()
            }

            _hideView() {
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.view.saveButtonView.focus();
                this._balloon.remove(this.view);
                this.editor.editing.view.focus()
            }

            _updateView() {
                const t = this.editor;
                const e = t.editing.view.document;
                if (!Iq(e.selection)) {
                    this._hideView()
                } else if (this._isViewVisible) {
                    Fq(t, "table")
                }
            }

            get _isViewVisible() {
                return this._balloon.visibleView === this.view
            }

            get _isViewInBalloon() {
                return this._balloon.hasView(this.view)
            }

            _getPropertyChangeCallback(t, e) {
                return (n, i, o, r) => {
                    if (!r && e === o) {
                        return
                    }
                    this.editor.execute(t, {value: o, batch: this._undoStepBatch})
                }
            }

            _getValidatedPropertyChangeCallback(t) {
                const {commandName: e, viewField: n, validator: i, errorText: o, defaultValue: r} = t;
                const s = Qf((() => {
                    n.errorText = o
                }), d$);
                return (t, o, a, l) => {
                    s.cancel();
                    if (!l && r === a) {
                        return
                    }
                    if (i(a)) {
                        this.editor.execute(e, {value: a, batch: this._undoStepBatch});
                        n.errorText = null
                    } else {
                        s()
                    }
                }
            }
        }

        class f$ extends Ac {
            static get pluginName() {
                return "TableProperties"
            }

            static get requires() {
                return [Yj, h$]
            }
        }

        class g$ extends Ac {
            static get requires() {
                return [LI]
            }

            static get pluginName() {
                return "TableToolbar"
            }

            afterInit() {
                const t = this.editor;
                const e = t.t;
                const n = t.plugins.get(LI);
                const i = t.config.get("table.contentToolbar");
                const o = t.config.get("table.tableToolbar");
                if (i) {
                    n.register("tableContent", {ariaLabel: e("Table toolbar"), items: i, getRelatedElement: Iq})
                }
                if (o) {
                    n.register("table", {ariaLabel: e("Table toolbar"), items: o, getRelatedElement: Pq})
                }
            }
        }

        const m$ = new Set(["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]);

        class p$ extends Ac {
            static get pluginName() {
                return "Title"
            }

            static get requires() {
                return ["Paragraph"]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                this._bodyPlaceholder = null;
                e.schema.register("title", {isBlock: true, allowIn: "$root"});
                e.schema.register("title-content", {isBlock: true, allowIn: "title", allowAttributes: ["alignment"]});
                e.schema.extend("$text", {allowIn: "title-content"});
                e.schema.addAttributeCheck((t => {
                    if (t.endsWith("title-content $text")) {
                        return false
                    }
                }));
                t.editing.mapper.on("modelToViewPosition", k$(t.editing.view));
                t.data.mapper.on("modelToViewPosition", k$(t.editing.view));
                t.conversion.for("downcast").elementToElement({model: "title-content", view: "h1"});
                t.conversion.for("downcast").add((t => t.on("insert:title", ((t, e, n) => {
                    n.consumable.consume(e.item, t.name)
                }))));
                t.data.upcastDispatcher.on("element:h1", b$, {priority: "high"});
                t.data.upcastDispatcher.on("element:h2", b$, {priority: "high"});
                t.data.upcastDispatcher.on("element:h3", b$, {priority: "high"});
                e.document.registerPostFixer((t => this._fixTitleContent(t)));
                e.document.registerPostFixer((t => this._fixTitleElement(t)));
                e.document.registerPostFixer((t => this._fixBodyElement(t)));
                e.document.registerPostFixer((t => this._fixExtraParagraph(t)));
                this._attachPlaceholders();
                this._attachTabPressHandling()
            }

            getTitle(t = {}) {
                const e = this._getTitleElement();
                const n = e.getChild(0);
                return this.editor.data.stringify(n, t)
            }

            getBody(t = {}) {
                const e = this.editor;
                const n = e.data;
                const i = e.model;
                const o = e.model.document.getRoot();
                const r = e.editing.view;
                const s = new Rh(r.document);
                const a = i.createRangeIn(o);
                const l = s.createDocumentFragment();
                const c = i.createPositionAfter(o.getChild(0));
                const d = i.createRange(c, i.createPositionAt(o, "end"));
                const u = new Map;
                for (const t of i.markers) {
                    const e = d.getIntersection(t.getRange());
                    if (e) {
                        u.set(t.name, e)
                    }
                }
                n.mapper.clearBindings();
                n.mapper.bindElements(o, l);
                n.downcastDispatcher.convert(a, u, s, t);
                s.remove(s.createRangeOn(l.getChild(0)));
                return e.data.processor.toData(l)
            }

            _getTitleElement() {
                const t = this.editor.model.document.getRoot();
                for (const e of t.getChildren()) {
                    if (w$(e)) {
                        return e
                    }
                }
            }

            _fixTitleContent(t) {
                const e = this._getTitleElement();
                if (!e || e.maxOffset === 1) {
                    return false
                }
                const n = Array.from(e.getChildren());
                n.shift();
                for (const i of n) {
                    t.move(t.createRangeOn(i), e, "after");
                    t.rename(i, "paragraph")
                }
                return true
            }

            _fixTitleElement(t) {
                const e = this.editor.model;
                const n = e.document.getRoot();
                const i = Array.from(n.getChildren()).filter(w$);
                const o = i[0];
                const r = n.getChild(0);
                if (r.is("element", "title")) {
                    return A$(i, t, e)
                }
                if (!o && !m$.has(r.name)) {
                    const e = t.createElement("title");
                    t.insert(e, n);
                    t.insertElement("title-content", e);
                    return true
                }
                if (m$.has(r.name)) {
                    _$(r, t, e)
                } else {
                    t.move(t.createRangeOn(o), n, 0)
                }
                A$(i, t, e);
                return true
            }

            _fixBodyElement(t) {
                const e = this.editor.model.document.getRoot();
                if (e.childCount < 2) {
                    this._bodyPlaceholder = t.createElement("paragraph");
                    t.insert(this._bodyPlaceholder, e, 1);
                    return true
                }
                return false
            }

            _fixExtraParagraph(t) {
                const e = this.editor.model.document.getRoot();
                const n = this._bodyPlaceholder;
                if (v$(n, e)) {
                    this._bodyPlaceholder = null;
                    t.remove(n);
                    return true
                }
                return false
            }

            _attachPlaceholders() {
                const t = this.editor;
                const e = t.t;
                const n = t.editing.view;
                const i = n.document.getRoot();
                const o = t.sourceElement;
                const r = t.config.get("title.placeholder") || e("Type your title");
                const s = t.config.get("placeholder") || o && o.tagName.toLowerCase() === "textarea" && o.getAttribute("placeholder") || e("Type or paste your content here.");
                t.editing.downcastDispatcher.on("insert:title-content", ((t, e, i) => {
                    Fc({view: n, element: i.mapper.toViewElement(e.item), text: r, keepOnFocus: true})
                }));
                let a;
                n.document.registerPostFixer((t => {
                    const e = i.getChild(1);
                    let n = false;
                    if (e !== a) {
                        if (a) {
                            Nc(t, a);
                            t.removeAttribute("data-placeholder", a)
                        }
                        t.setAttribute("data-placeholder", s, e);
                        a = e;
                        n = true
                    }
                    if (Mc(e, true) && i.childCount === 2 && e.name === "p") {
                        n = Oc(t, e) ? true : n
                    } else {
                        n = Nc(t, e) ? true : n
                    }
                    return n
                }))
            }

            _attachTabPressHandling() {
                const t = this.editor;
                const e = t.model;
                t.keystrokes.set("TAB", ((t, n) => {
                    e.change((t => {
                        const i = e.document.selection;
                        const o = Array.from(i.getSelectedBlocks());
                        if (o.length === 1 && o[0].is("element", "title-content")) {
                            const i = e.document.getRoot().getChild(1);
                            t.setSelection(i, 0);
                            n()
                        }
                    }))
                }));
                t.keystrokes.set("SHIFT + TAB", ((n, i) => {
                    e.change((n => {
                        const o = e.document.selection;
                        if (!o.isCollapsed) {
                            return
                        }
                        const r = t.model.document.getRoot();
                        const s = sc(o.getSelectedBlocks());
                        const a = o.getFirstPosition();
                        const l = r.getChild(0);
                        const c = r.getChild(1);
                        if (s === c && a.isAtStart) {
                            n.setSelection(l.getChild(0), 0);
                            i()
                        }
                    }))
                }))
            }
        }

        function b$(t, e, n) {
            const i = e.modelCursor;
            const o = e.viewItem;
            if (!i.isAtStart || !i.parent.is("element", "$root")) {
                return
            }
            if (!n.consumable.consume(o, {name: true})) {
                return
            }
            const r = n.writer;
            const s = r.createElement("title");
            const a = r.createElement("title-content");
            r.append(a, s);
            r.insert(s, i);
            n.convertChildren(o, a);
            n.updateConversionResult(s, e)
        }

        function k$(t) {
            return (e, n) => {
                const i = n.modelPosition.parent;
                if (!i.is("element", "title")) {
                    return
                }
                const o = i.parent;
                const r = n.mapper.toViewElement(o);
                n.viewPosition = t.createPositionAt(r, 0);
                e.stop()
            }
        }

        function w$(t) {
            return t.is("element", "title")
        }

        function _$(t, e, n) {
            const i = e.createElement("title");
            e.insert(i, t, "before");
            e.insert(t, i, 0);
            e.rename(t, "title-content");
            n.schema.removeDisallowedAttributes([t], e)
        }

        function A$(t, e, n) {
            let i = false;
            for (const o of t) {
                if (o.index !== 0) {
                    C$(o, e, n);
                    i = true
                }
            }
            return i
        }

        function C$(t, e, n) {
            const i = t.getChild(0);
            if (i.isEmpty) {
                e.remove(t);
                return
            }
            e.move(e.createRangeOn(i), t, "before");
            e.rename(i, "paragraph");
            e.remove(t);
            n.schema.removeDisallowedAttributes([i], e)
        }

        function v$(t, e) {
            if (!t || !t.is("element", "paragraph") || t.childCount) {
                return false
            }
            if (e.childCount <= 2 || e.getChild(e.childCount - 1) !== t) {
                return false
            }
            return true
        }

        const y$ = "underline";

        class x$ extends Ac {
            static get pluginName() {
                return "UnderlineEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: y$});
                t.model.schema.setAttributeProperties(y$, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: y$,
                    view: "u",
                    upcastAlso: {styles: {"text-decoration": "underline"}}
                });
                t.commands.add(y$, new AD(t, y$));
                t.keystrokes.set("CTRL+U", "underline")
            }
        }

        const E$ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
        const S$ = "underline";

        class D$ extends Ac {
            static get pluginName() {
                return "UnderlineUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(S$, (n => {
                    const i = t.commands.get(S$);
                    const o = new LC(n);
                    o.set({label: e("Underline"), icon: E$, keystroke: "CTRL+U", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(S$);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class T$ extends Ac {
            static get requires() {
                return [x$, D$]
            }

            static get pluginName() {
                return "Underline"
            }
        }

        function B$(t) {
            if (t.is("$text") || t.is("$textProxy")) {
                return t.data
            }
            let e = "";
            let n = null;
            for (const i of t.getChildren()) {
                const t = B$(i);
                if (n && n.is("element")) {
                    e += "\n"
                }
                e += t;
                n = i
            }
            return e
        }

        class P$ extends Ac {
            constructor(t) {
                super(t);
                this.set("characters", 0);
                this.set("words", 0);
                Object.defineProperties(this, {
                    characters: {
                        get() {
                            return this.characters = this._getCharacters()
                        }
                    }, words: {
                        get() {
                            return this.words = this._getWords()
                        }
                    }
                });
                this.set("_wordsLabel");
                this.set("_charactersLabel");
                this._config = t.config.get("wordCount") || {};
                this._outputView = undefined;
                this._wordsMatchRegExp = r.features.isRegExpUnicodePropertySupported ? new RegExp("([\\p{L}\\p{N}]+\\S?)+", "gu") : /([a-zA-Z0-9À-ž]+\S?)+/gu
            }

            static get pluginName() {
                return "WordCount"
            }

            init() {
                const t = this.editor;
                t.model.document.on("change:data", tR(this._refreshStats.bind(this), 250));
                if (typeof this._config.onUpdate == "function") {
                    this.on("update", ((t, e) => {
                        this._config.onUpdate(e)
                    }))
                }
                if (Ha(this._config.container)) {
                    this._config.container.appendChild(this.wordCountContainer)
                }
            }

            destroy() {
                if (this._outputView) {
                    this._outputView.element.remove();
                    this._outputView.destroy()
                }
                super.destroy()
            }

            get wordCountContainer() {
                const t = this.editor;
                const e = t.t;
                const n = t.config.get("wordCount.displayWords");
                const i = t.config.get("wordCount.displayCharacters");
                const o = N_.bind(this, this);
                const r = [];
                if (!this._outputView) {
                    this._outputView = new pA;
                    if (n || n === undefined) {
                        this.bind("_wordsLabel").to(this, "words", (t => e("Words: %0", t)));
                        r.push({
                            tag: "div",
                            children: [{text: [o.to("_wordsLabel")]}],
                            attributes: {class: "ck-word-count__words"}
                        })
                    }
                    if (i || i === undefined) {
                        this.bind("_charactersLabel").to(this, "characters", (t => e("Characters: %0", t)));
                        r.push({
                            tag: "div",
                            children: [{text: [o.to("_charactersLabel")]}],
                            attributes: {class: "ck-word-count__characters"}
                        })
                    }
                    this._outputView.setTemplate({
                        tag: "div",
                        attributes: {class: ["ck", "ck-word-count"]},
                        children: r
                    });
                    this._outputView.render()
                }
                return this._outputView.element
            }

            _getCharacters() {
                const t = B$(this.editor.model.document.getRoot());
                return t.replace(/\n/g, "").length
            }

            _getWords() {
                const t = B$(this.editor.model.document.getRoot());
                const e = t.match(this._wordsMatchRegExp) || [];
                return e.length
            }

            _refreshStats() {
                const t = this.words = this._getWords();
                const e = this.characters = this._getCharacters();
                this.fire("update", {words: t, characters: e})
            }
        }

        class I$ extends Ax {
        }

        I$.builtinPlugins = [Nx, RE, WS, JS, _D, ED, LD, mT, wT, WB, IP, MR, pz, Oz, Kz, fV, BV, qV, eF, NF, XF, PL, kO, vO, TO, VO, gN, bV, _N, MN, HN, WN, UN, jN, qN, $N, QN, oM, dM, BW, $W, uj, Hj, f$, g$, wE, p$, T$, P$];
        I$.defaultConfig = {
            toolbar: {items: ["heading", "|", "undo", "redo", "alignment", "code", "codeBlock", "bold", "italic", "link", "bulletedList", "numberedList", "fontColor", "fontFamily", "fontSize", "horizontalLine", "highlight", "|", "outdent", "indent", "|", "imageUpload", "blockQuote", "insertTable", "removeFormat", "findAndReplace", "specialCharacters", "strikethrough", "subscript", "superscript", "underline"]},
            language: "en",
            table: {contentToolbar: ["tableColumn", "tableRow", "mergeTableCells", "tableCellProperties", "tableProperties"]}
        };
        const R$ = I$
    })();
    i = i["default"];
    return i
})()));
//# sourceMappingURL=ckeditor.js.map
